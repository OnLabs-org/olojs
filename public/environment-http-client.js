/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({"/bin/html":"/bin/html","/bin/math":"/bin/math","/bin/path":"/bin/path","vendors~/bin/markdown":"vendors~/bin/markdown","/bin/markdown":"/bin/markdown"}[chunkId]||chunkId) + ".bundle.js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/environment-http-client.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/document.js":
/*!*************************!*\
  !*** ./lib/document.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  # document module\n *  This module contains functions to load, parse and evaluate olo-documents.\n */\n\n\n\n/**\n *  ### document.expression\n *  This points to the expression module, but it could be any object implementing\n *  the following methods:\n *\n *  - expression.parse\n *  - expression.createContext\n *  - expression.stringify\n *  - expression.apply\n */\nexports.expression = __webpack_require__(/*! ./expression */ \"./lib/expression.js\");\n\n\n\n/**\n *  ### document.parse(source)\n *  The parse function takes a document source text as input and returns \n *  an `evaluate` function as output.\n *\n *  The `evaluate` function takes an expression context as input and\n *  returns the document namespace evaluated in that context.\n *\n *  The returned namespace can be then stringified by using the \n *  `document.expression.stringify` function.\n */\nexports.parse = function (source) {\n    source = String(source);\n    \n    // Find all the swan expressions in the source, store them in an array and\n    // replace them with a placeholder.\n    const parsedExpressions = [];\n    var parsedSource = source;\n    parsedSource = parsedSource.replace(/<%([\\s\\S]+?)%>/g, (match, expressionSource) => {  \n        let i = parsedExpressions.length;\n        parsedExpressions.push( this.expression.parse(expressionSource) );\n        return `<%${i}%>`;\n    }); \n    \n    // The returned `evaluate` function\n    return async (context) => {\n        const doc = {};\n        \n        // Evaluate each expression in the given context and replace the\n        // placeholder with the stringified expression value\n        var text = parsedSource;\n        for (let i=0; i<parsedExpressions.length; i++) {\n            let evaluateExpression = parsedExpressions[i];\n            try {\n                var value = await evaluateExpression(context);                                    \n            } catch (error) {\n                // Delegate error rendering to the custom `context.$renderError` function\n                var value = context.$renderError(error);\n            }\n            text = text.replace(`<%${i}%>`, await this.expression.stringify(value));\n        }\n        \n        // Transform the rendered text by passing it to the `context.__render__`\n        // decorator, if it exists.\n        if (context.__render__) {\n            text = await this.expression.apply(context.__render__, text);\n            text = await this.expression.stringify(text);            \n        }\n        \n        // Extract the document namespace, discarding the global context\n        // variables.  \n        const namespace = Object.assign({}, context);\n        \n        // Define the `__str__` name as the rendered text in order to make the \n        // namespace stringify to the rendered text.\n        namespace.__str__ = text;\n\n        // Return the document namespace\n        return namespace;\n    };               \n}\n\n\n\n/**\n *  ### document.createContext(namespace)\n *  Create and expression context suitable for document rendering.\n */\nexports.createContext = function (namespace={}) {\n    return this.expression.createContext(documentContext).$extend(namespace);\n}\n\nconst documentContext = {\n\n    $renderError (error) {\n        return `[!${error.message}]`;\n    },        \n};\n\n\n//# sourceURL=webpack:///./lib/document.js?");

/***/ }),

/***/ "./lib/environment.js":
/*!****************************!*\
  !*** ./lib/environment.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  # Envionment class\n *  This class defines:\n *  - a way to retrieve and modify documents from document stores\n *  - a common evaluation context for all the loaded documents\n */\n\nconst Path = __webpack_require__(/*! ./tools/path */ \"./lib/tools/path.js\");\nconst document = __webpack_require__(/*! ./document */ \"./lib/document.js\");\n\n\nclass Environment {\n    \n    /**\n     *  ### new Environment(config)\n     *  The config object should contain the followin properties:\n     *  - `config.paths`: an object mapping paths to path handlers\n     *  - `config.globals`: an object with all the properties and functions that will be added to the document contexts\n     *  Any other property of the config object is optional and, if present,\n     *  it will be added as it is to the environment instance.\n     *\n     *  ##### config.paths\n     *  The `paths` property of the config object should map paths to path handlers:\n     *\n     *  ```js\n     *  config.paths = {\n     *      \"/root/path1\": pathHandler1,\n     *      \"/root_path2\": pathHandler2,\n     *      \"/rp3\": pathHandler3,\n     *      ...\n     *  }\n     *  ```\n     *\n     *  The `pathHandler` can be any object with one or more of the following methods:\n     *  - `read`: method (synchronous or asynchronous) that maps a sub-path to an \n     *    olo-document source text. \n     *  - `write`: function that takes a sub-path and a source as arguments and\n     *    modifies the document source mapped to the give path\n     *  - `delete`: function that takes a sub-path as argument and deletes the\n     *    document mapped to the given path\n     *\n     *  Read, write and delete operations will be delegated to the proper \n     *  pathHandler function by the environment instance. \n     *\n     *  This makes an environment a stores hub that can be configured to \n     *  retrieve and modify documents and data stored in virtually any source.\n     */\n    constructor (config={}) {\n        \n        if (isObject(config.store) && isFunction(config.store.read)) {\n            this.store = config.store;\n        } else {\n            throw new Error(\"Invalid store\");\n        }\n        \n        this.globals = {};\n        if (isObject(config.globals)) {\n            for (let name in config.globals) {\n                this.globals[name] = config.globals[name];\n            }\n        }\n\n        this.cache = config.nocache ? null : new Map();\n        \n        for (let name in config) {\n            if (this[name] === undefined) this[name] = config[name];\n        }\n    }\n    \n\n    /**\n     *  ### Environment.prototype.readDocument(path)\n     *  This function takes a path, finds the first pathHandler matching the\n     *  path and returns `pathHandler.read(subPath)`.\n     *\n     *  Say you created an evironment `env` based on the followin config object ...\n     *  ```js\n     *  config.paths = {\n     *      \"/root/path1\": pathHandler1,\n     *      \"/root_path2\": pathHandler2,\n     *      \"/rp3\": pathHandler3,\n     *      ...\n     *  }\n     *  ```\n     *  ... then\n     * - `env.readDocument(\"/root/path1/path/to/docA\")` will result in calling `pathHandler1.read(\"/path/to/docA\")`\n     *   and returning the returned string as document source\n     * - `env.readDocument(\"/root_path2/path/to/docB\")` will result in calling `pathHandler2.read(\"/path/to/docB\")`\n     *   and returning the returned string as document source\n     * - `env.readDocument(\"/rp3/path/to/docC\")` will result in calling `pathHandler3.read(\"/path/to/docC\")`\n     *    and returning the returned string as document source\n     * ...\n     */\n    async readDocument (path) {\n        const docPath = Path.from(path);\n        const docPathStr = String(docPath);\n        \n        if (this.cache && this.cache.has(docPathStr)) {\n            return this.cache.get(docPathStr);\n        }\n        \n        const doc = await this.store.read(docPathStr);\n        \n        if (this.cache && docPathStr.slice(-1) !== \"/\") {\n            this.cache.set(docPathStr, doc);\n        }\n        \n        return doc;\n    }\n    \n    /**\n     *  ### Environment.prototype.writeDocument(path, source)\n     *  This function takes a path and an olo-document source, finds the first\n     *  pathHandler matching the path and calls `pathHandler.write(subPath, source)`.\n     *  \n     *  If source is an empty string, it will instead call `env.delete(path)`.\n     */\n    async writeDocument (path, source) {\n        source = String(source);\n    \n        if (source === \"\") {\n            return await this.deleteDocument(path);\n        }\n    \n        const docPath = Path.from(path);\n        if (isFunction(this.store.write)) {\n            await this.store.write(String(docPath), source);\n        } else {\n            throw new Error(`Write operation not defined`);\n        }\n    \n        const docPathStr = String(docPath);\n        if (this.cache && this.cache.has(docPathStr)) {\n            this.cache.set(docPathStr, source);\n        }\n    }\n    \n    /**\n     *  ### Environment.prototype.deleteDocument(path, source)\n     *  This function takes a path and an olo-document source, finds the first\n     *  pathHandler matching the path and calls `pathHandler.delete(subPath, source)`.\n     */\n    async deleteDocument (path) {\n        \n        const docPath = Path.from(path);\n        if (isFunction(this.store.delete)) {\n            await this.store.delete(String(docPath));\n        } else {\n            throw new Error(`Delete operation not defined`);\n        }\n    \n        const docPathStr = String(docPath);\n        if (this.cache && this.cache.has(docPathStr)) {\n            this.cache.delete(docPathStr);\n        }        \n    }    \n    \n    /**\n     *  ### Environment.prototype.createContext(path, presets={})\n     *  This function takes a document path and an optional namespace and \n     *  creates a namespace that can be used to evaluate a document source.\n     *\n     *  The environment context contains:\n     *  - All the names contained in `environment.globals` (from the config parameter)\n     *  - All the names contained in the `presets` object\n     *  - A `__path__` string, meant to represent the document path\n     *  - An `import` function that return `environment.load(fullPath)` after\n     *    resolving the passed path as relative to `__path__`\n     */    \n    createContext (docPath, presets={}) {\n        docPath = Path.from(docPath);\n        return document.createContext(this.globals)\n                .$assign({\n                    \"import\": (subPath, argns) => this.loadDocument(docPath.resolve(subPath), {argns})\n                })\n                .$extend(presets)\n                .$assign({\n                    __path__: String(docPath)\n                });\n    }\n    \n\n    /**\n     *  ### Environment.prototype.parseDocument(source) \n     *  This just calls `document.parse`. \n     */    \n    parseDocument (source) {\n        return document.parse(source);\n    }\n    \n\n    /**\n     *  ### Environment.prototype.stringifyDocumentExpression(value)\n     *  This just calls `document.expression.stringify`.\n     */    \n    stringifyDocumentExpression (value) {\n        return document.expression.stringify(value);\n    }\n\n    \n    /**\n     *  ### Environment.prototype.loadDocument(path, presets={})\n     *  This function reads and evaluates an olo-document, ther returns its\n     *  namespace.\n     */\n    async loadDocument (path, presets={}) {\n        const docPath = Path.from(path);\n        const source = await this.readDocument(docPath);\n        const evaluate = this.parseDocument(source);\n        const context = this.createContext(docPath, presets);\n        return await evaluate(context);        \n    }\n    \n\n    /**\n     *  ### Environment.prototype.renderDocument(path, presets={})\n     *  This function reads and evaluates an olo-document, ther returns its\n     *  stringified namespace. \n     */ \n    async renderDocument (path, presets={}) {\n        const docNS = await this.loadDocument(path, presets);\n        return await this.stringifyDocumentExpression(docNS);\n    }\n}\n\n\n\n\n\n//------\n//  SERVICE FUNCTIONS\n//------\n\nconst isObject = x => typeof x === \"object\" && x !== null & !Array.isArray(x);\n\nconst isString = x => typeof x === \"string\";\n\nconst isFunction = x => typeof x === \"function\";\n\n\n\n\n\nmodule.exports = Environment;\n\n\n//# sourceURL=webpack:///./lib/environment.js?");

/***/ }),

/***/ "./lib/expression.js":
/*!***************************!*\
  !*** ./lib/expression.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  # expression module\n *  This module provides functions to parse and evaluate [swan](./swan.md)\n *  expressions.\n */\n\n\nconst Parser = __webpack_require__(/*! ./expression/parser */ \"./lib/expression/parser.js\");\n\nconst parse = Parser({\n     \n     binaryOperations: {\n         \",\"  : {precedence:10, handler:\"$pair\"  },\n         \"=\"  : {precedence:11, handler:\"$set\"   },\n         \":\"  : {precedence:11, handler:\"$label\" },\n         \"->\" : {precedence:12, handler:\"$def\",  right:true},\n\n         \";\"  : {precedence:21, handler:\"$else\"},\n         \"?\"  : {precedence:22, handler:\"$if\"  },\n         \"|\"  : {precedence:23, handler:\"$or\"  },\n         \"&\"  : {precedence:23, handler:\"$and\" },\n         \"==\" : {precedence:24, handler:\"$eq\"  },\n         \"!=\" : {precedence:24, handler:\"$ne\"  },\n         \"<\"  : {precedence:24, handler:\"$lt\"  },\n         \"<=\" : {precedence:24, handler:\"$le\"  },\n         \">\"  : {precedence:24, handler:\"$gt\"  },\n         \">=\" : {precedence:24, handler:\"$ge\"  },\n         \"+\"  : {precedence:25, handler:\"$add\" },\n         \"-\"  : {precedence:25, handler:\"$sub\" },\n         \"*\"  : {precedence:26, handler:\"$mul\" },    \n         \"/\"  : {precedence:26, handler:\"$div\" },\n         \"%\"  : {precedence:26, handler:\"$mod\" },\n         \"^\"  : {precedence:27, handler:\"$pow\" },\n         \n         \".\"  : {precedence:30, handler:\"$dot\" },\n         \"\"   : {precedence:30, handler:\"$apply\" },\n     },\n     \n     voidHandler        : \"$nothing\",\n     nameHandler        : \"$name\",\n     stringHandler0     : \"$str0\",\n     stringHandler1     : \"$str1\",\n     stringHandler2     : \"$str2\",\n     numberHandler      : \"$numb\",\n     squareGroupHandler : \"$list\",\n     curlyGroupHandler  : \"$namespace\",\n });\n\nconst isValidName = name =>  /^[a-z_A-Z]+[a-z_A-Z0-9]*$/.test(name);\n\nclass Exception extends Error {};\n\nfunction raise (message) {\n    throw new Exception(message);\n}\n\nclass Tuple {\n    \n    constructor (...items) {\n        this._items = items.filter(item => !isNothing(item));\n    }\n    \n    isNothing () {\n        return this.normalize() === null;\n    }\n    \n    *[Symbol.iterator] () {\n        for (let item of this._items) {\n            if (item instanceof Tuple) {\n                for (let subItem of item) yield subItem;\n            } else if (!isNothing(item)) {\n                yield item;\n            }\n        }\n    }\n\n    normalize () {\n        const iterator = this[Symbol.iterator]();\n        const first = iterator.next();\n        if (first.done) return null;\n        return iterator.next().done ? first.value : this;\n    }    \n    \n    async map (fn) {\n        var retVals = NOTHING;\n        for (let item of this) {\n            retVals = Tuple.from(retVals, await fn(item));\n        }\n        return retVals;\n    }\n    \n    static from (...items) {\n        return new this(...items);\n    }\n}\n\nfunction normalize (value) {\n    return value instanceof Tuple ? value.normalize() : value;\n}\n\nconst NOTHING = new Tuple();\n\nfunction* pair (x, y) {\n    const iX = Tuple.from(x)[Symbol.iterator]();\n    const iY = Tuple.from(y)[Symbol.iterator]();\n    while (true) {\n        let x = iX.next();\n        let y = iY.next();\n        if (x.done && y.done) break;\n        yield {first:x.value, second:y.value};\n    }    \n}\n\nfunction type (value) {\n    \n    // if Nothing\n    if (value === null || value === undefined || Number.isNaN(value)) return \"NOTHING\";\n\n    // if primitive\n    switch (typeof value) {\n        case \"boolean\"  : return \"BOOLEAN\";\n        case \"number\"   : return \"NUMBER\";\n        case \"string\"   : return \"STRING\";\n    }    \n    \n    // It must be an object!\n    \n    // if Function\n    if (typeof value === \"function\") return \"FUNCTION\";\n    \n    // if List\n    if (Array.isArray(value)) return \"LIST\";\n    \n    // if iterable\n    if (value instanceof Tuple) return \"TUPLE\";\n\n    // if a primitive object\n    const tag = Object.prototype.toString.call(value);\n    if (tag === '[object Boolean]') return \"BOOLEAN\";\n    if (tag === '[object Number]') return \"NUMBER\";\n    if (tag === '[object String]') return \"STRING\";\n    \n    // It is a Namespace!\n    return \"NAMESPACE\";\n}\n\nfunction isNothing (value) {\n    const valueType = type(value);\n    if (valueType === 'NOTHING') return true;\n    if (valueType === 'TUPLE' && value.isNothing()) return true;\n    return false; \n}\n\nfunction getListItem (list, index) {\n    if (type(index) === 'TUPLE') {\n        let items = Array.from(index);\n        if (items.length !== 1) return NOTHING;\n        index = items[0];\n    }\n    if (type(index) !== 'NUMBER') return NOTHING;\n    index = index < 0 ? list.length + index : index;\n    return (0 <= index && index < list.length) ? list[Math.trunc(index)] : NOTHING;\n}\n\nfunction countNames (namespace) {\n    return Object.getOwnPropertyNames(namespace).length;\n}\n\nfunction apply (x, y) {\n    const xType = type(x);\n    switch (xType) {\n        case 'FUNCTION':  return x.call(this, ...Tuple.from(y));\n        case 'STRING':    return getListItem(x, y);\n        case 'LIST':      return getListItem(x, y);\n        case 'NAMESPACE': {\n            if (typeof x.__apply__ === 'function') {\n                return apply.call(this, x.__apply__, y);\n            }\n            y = normalize(y);\n            if (type(y) !== 'STRING') return NOTHING;\n            return isValidName(y) && x.hasOwnProperty(y) ? x[y] : NOTHING;\n        };\n        case 'TUPLE':     return x.map(xi => apply.call(this, xi, y));\n        default:          return raise(`Apply operation not defined on ${xType} type`);\n    }\n}\n\nfunction convertToBoolean (x) {\n    const xType = type(x);\n    switch (xType) {\n        case 'BOOLEAN':   return x;\n        case 'NUMBER':    return x !== 0;\n        case 'FUNCTION':  return true;\n        case 'STRING':    return x.length !== 0;\n        case 'LIST':      return x.length !== 0;\n        case 'NAMESPACE': return countNames(x) !== 0;\n        case 'TUPLE':     {\n            for (let item of x) {\n                if (convertToBoolean(item)) return true;\n            }\n            return false;            \n        };\n        default: return raise(`${xType} cannot be converted to BOOLEAN`);\n    }    \n}\n\nfunction stringify (x) {\n    const xType = type(x);\n    switch (xType) {\n        case 'BOOLEAN':   return x ? \"TRUE\" : \"FALSE\";\n        case 'NUMBER':    return String(x);\n        case 'FUNCTION':  return String.fromCharCode(0x2A0D);\n        case 'STRING':    return x;\n        case 'LIST':      return `[${x.length}]`;\n        case 'NAMESPACE': return type(x.__str__) === 'STRING' ? x.__str__ : `{${countNames(x)}}`;\n        default:          return raise(`${xType} cannot be converted to STRING`);\n    }        \n}\n\nfunction add (x, y) {\n    const xType = type(x); if (xType === 'NOTHING') return y;\n    const yType = type(y); if (yType === 'NOTHING') return x;\n    switch (`${xType}-${yType}`) {\n        case 'BOOLEAN-BOOLEAN': return x || y;\n        case 'NUMBER-NUMBER': return x + y;\n        case 'STRING-STRING': return x + y;\n        case 'LIST-LIST': return x.concat(y);\n        case 'NAMESPACE-NAMESPACE': return Object.assign({}, x, y);\n        default: return raise(`Sum operation not defined between ${xType} and ${yType}`);\n    }\n}\n\nfunction sub (x, y) {\n    const xType = type(x); if (xType === 'NOTHING') return NOTHING;\n    const yType = type(y); if (yType === 'NOTHING') return x;\n    switch (`${xType}-${yType}`) {\n        case 'NUMBER-NUMBER': return x - y;\n        default: return raise(`Subtraction operation not defined between ${xType} and ${yType}`);\n    }\n}\n\nfunction mul (x, y) {\n    const xType = type(x); if (xType === 'NOTHING') return NOTHING;\n    const yType = type(y); if (yType === 'NOTHING') return NOTHING;\n    switch (`${xType}-${yType}`) {\n        case 'BOOLEAN-BOOLEAN': return x && y;\n        case 'NUMBER-NUMBER': return x * y;\n        case 'NUMBER-STRING': return x < 0 ? \"\" : y.repeat(x); \n        case 'STRING-NUMBER': return y < 0 ? \"\" : x.repeat(y);\n        case 'LIST-NUMBER': return multiplyList(x,y);\n        case 'NUMBER-LIST': return multiplyList(y,x);\n        default: return raise(`Product operation not defined between ${xType} and ${yType}`);\n    }    \n}\n\nfunction multiplyList (list, n) {\n    var product = [];\n    for (let i=1; i<=n; i++) product = product.concat(list);\n    return product;    \n}\n\nfunction div (x, y) {\n    const xType = type(x); if (xType === 'NOTHING') return NOTHING;\n    const yType = type(y);\n    switch (`${xType}-${yType}`) {\n        case 'NUMBER-NUMBER': return x / y;\n        default: return raise(`Division operation not defined between ${xType} and ${yType}`);\n    }    \n}\n\nfunction mod (x, y) {\n    const xType = type(x); if (xType === 'NOTHING') return y;\n    const yType = type(y);\n    switch (`${xType}-${yType}`) {\n        case 'NUMBER-NUMBER': return x % y;\n        default: return raise(`Modulo operation not defined between ${xType} and ${yType}`);\n    }    \n}\n\nfunction pow (x, y) {\n    const xType = type(x); if (xType === 'NOTHING') return NOTHING;\n    const yType = type(y);\n    switch (`${xType}-${yType}`) {\n        case 'NUMBER-NUMBER': return x ** y;\n        default: return raise(`Exponentiation operation not defined between ${xType} and ${yType}`);\n    }    \n}\n\nfunction compare (x, y) {\n    const xType = type(x);\n    const yType = type(y);\n    if (xType === 'NOTHING') return yType === 'NOTHING' ? 0 : -1;\n    if (yType === 'NOTHING') return +1;\n    switch (`${xType}-${yType}`) {\n        case 'BOOLEAN-BOOLEAN': return x === y ? 0 : (x ? +1 : -1);\n        case 'NUMBER-NUMBER':   return x === y ? 0 : (x<y ? -1 : +1);\n        case 'STRING-STRING':   return x === y ? 0 : [x,y].sort()[0] === x ? -1 : +1;\n        case 'LIST-LIST':       return lexCompare(Tuple.from(...x), Tuple.from(...y));\n        default: return raise(`Comparison operation not defined between ${xType} and ${yType}`);\n    }    \n}\n\nfunction lexCompare (tuple1, tuple2) {\n    const pairs = Tuple.from(...pair(tuple1, tuple2));\n    for (let pair of pairs) {\n        let cmp = compare(pair.first, pair.second);\n        if (cmp !== 0) return cmp;\n    }\n    return 0;\n}\n\nfunction isEqual (x, y) {\n    const xType = type(x);\n    const yType = type(y);\n    if (xType === 'NOTHING') return yType === 'NOTHING';\n    switch (`${xType}-${yType}`) {\n        case 'BOOLEAN-BOOLEAN':     return x === y;\n        case 'NUMBER-NUMBER':       return x === y;\n        case 'STRING-STRING':       return x === y;\n        case 'FUNCTION-FUNCTION':   return x === y;\n        case 'LIST-LIST':           return isLexEqual(Tuple.from(...x), Tuple.from(...y));\n        case 'NAMESPACE-NAMESPACE': {\n            let xNames = Object.getOwnPropertyNames(x).filter(isValidName);\n            let yNames = Object.getOwnPropertyNames(y).filter(isValidName);\n            if (xNames.length !== yNames.length) return false;\n            for (let xName of xNames) {\n                let xValue = x[xName];\n                let yValue = y.hasOwnProperty(xName) ? y[xName] : null;\n                if (!isEqual(xValue, yValue)) return false;\n            }\n            return true;\n        }\n        default: return false;\n    }    \n}\n\nfunction isLexEqual (tuple1, tuple2) {\n    const pairs = Tuple.from(...pair(tuple1, tuple2));\n    for (let pair of pairs) {\n        if (!isEqual(pair.first, pair.second)) return false;\n    }\n    return true;    \n}\n\n\nconst context = {\n    \n    $nothing () {\n        return NOTHING;\n    },\n    \n    async $str0 (text) {        \n        const parsedExpressions = [];\n        text = text.replace(/\\$\\{([\\s\\S]+?)\\}/g, (match, expressionSource) => {  \n            let i = parsedExpressions.length;\n            parsedExpressions.push( parse(expressionSource) );\n            return \"${\"+i+\"}\";\n        }); \n        \n        const templateContext = Object.create(this);\n        for (let i=0; i<parsedExpressions.length; i++) {\n            let evaluateExpression = parsedExpressions[i];\n            let value = await evaluateExpression(templateContext);                \n            text = text.replace(\"${\"+i+\"}\", await this.str(...Tuple.from(value)));\n        }\n\n        return text;\n    },\n    \n    $str1 (value) {\n        return value;\n    },\n    \n    $str2 (value) {\n        return value;\n    },\n    \n    $numb (value) {\n        return value;\n    },\n    \n    async $pair (X, Y) {\n        return Tuple.from(await X(this), await Y(this));\n    },\n    \n    async $list (X) {\n        return Array.from(Tuple.from(await X(this)));\n    },\n    \n    async $name (name) {\n        if (isValidName(name)) {\n            let value = this[name];\n            if (value !== undefined && value !== Object.prototype[name]) return value;\n        }\n        return NOTHING;\n    },\n    \n    async $label (X, Y) {\n        const x = await X({\n            $nothing: this.$nothing,\n            $name: name => name,\n            $pair: this.$pair\n        });\n        const names = Array.from(Tuple.from(x));\n        const y = await Y(this);\n        const values = Array.from(Tuple.from(y));\n        if (values.length > names.length) {\n            values[names.length-1] = Tuple.from(...values.slice(names.length-1))\n        }\n        for (var i=0; i<names.length; i++) {\n            this[names[i]] = i < values.length ? values[i] : null;\n        }            \n        return y;\n    },\n    \n    async $set (X, Y) {\n        await this.$label(X, Y);\n        return NOTHING;\n    },\n\n    async $namespace (X) {\n        const context = Object.create(this);\n        await X(context);\n        return Object.assign({}, context);\n    },\n    \n    $def (params, expression) {\n        return async (...args) => {\n            const functionContext = Object.create(this);\n            await functionContext.$set(params, () => Tuple.from(...args));\n            return await expression(functionContext);\n        }\n    },\n    \n    async $apply (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return await apply.call(this, x, y);\n    },\n    \n    async $dot (X, Y) {\n        const namespaces = Tuple.from(await X(this));\n        return namespaces.map(async namespace => {\n            if (type(namespace) !== 'NAMESPACE') raise(\"Namespace expected on the left size of the '.' operator\");\n            const childNamespace = Object.assign(Object.create(this), namespace);\n            return await Y(childNamespace);\n        });\n    },\n    \n    async $or (X, Y) {\n        const x = await X(this);\n        if (await this.bool(x)) return x;\n        return await Y(this);\n    },\n    \n    async $and (X, Y) {\n        const x = await X(this);\n        if (await this.not(x)) return x;\n        return await Y(this);\n    },\n    \n    async $if (X, Y) {\n        const x = await X(this);\n        return (await this.bool(x)) ? await Y(this) : NOTHING;\n    },\n\n    async $else (X, Y) {\n        const x = await X(this);\n        return isNothing(x) ? await Y(this) : x;\n    },\n    \n    async $add (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        const pairs = Tuple.from(...pair(x,y));\n        return pairs.map(pair => add(pair.first, pair.second));\n    },\n\n    async $sub (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        const pairs = Tuple.from(...pair(x,y));\n        return pairs.map(pair => sub(pair.first, pair.second));\n    },\n\n    async $mul (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        const pairs = Tuple.from(...pair(x,y));\n        return pairs.map(pair => mul(pair.first, pair.second));\n    },\n\n    async $div (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        const pairs = Tuple.from(...pair(x,y));\n        return pairs.map(pair => div(pair.first, pair.second));\n    },\n\n    async $mod (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        const pairs = Tuple.from(...pair(x,y));\n        return pairs.map(pair => mod(pair.first, pair.second));\n    },\n\n    async $pow (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        const pairs = Tuple.from(...pair(x,y));\n        return pairs.map(pair => pow(pair.first, pair.second));\n    },\n\n    async $eq (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return isLexEqual(x, y);\n    },\n     \n    async $ne (X, Y) {\n        return !(await this.$eq(X, Y));\n    },\n\n    async $lt (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return lexCompare(x, y) == -1;\n    },\n\n    async $ge (X, Y) {\n        return !(await this.$lt(X, Y));\n    },\n\n    async $gt (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return lexCompare(x, y) == +1;\n    },\n\n    async $le (X, Y) {\n        return !(await this.$gt(X, Y));\n    },   \n    \n    bool (...items) {\n        return convertToBoolean(Tuple.from(...items));\n    },\n    \n    not (...items) {\n        return !convertToBoolean(Tuple.from(...items));\n    },\n    \n    str (...items) {\n        return items.map(item => stringify(item)).join(\"\")\n    },\n    \n    map (fn) {\n        return (...items) => Tuple.from(...items).map(fn);\n    },\n    \n    enum (...items) {\n        const value = Tuple.from(...items).normalize();\n        switch (type(value)) {\n            case 'STRING':      return Tuple.from(...Array.from(value))\n            case 'LIST':        return Tuple.from(...value);\n            case 'NAMESPACE':   return Tuple.from(...Object.getOwnPropertyNames(value));\n            default:            return value;\n        }\n    },\n    \n    TRUE: true,\n    FALSE: false,\n    \n    $assign (namespace) {\n        for (let name in namespace) {\n            this[name] = namespace[name];\n        }\n        return this;\n    },\n    \n    $extend (namespace) {\n        return Object.create(this).$assign(namespace);\n    }\n};\n\n\n/**\n *  ### expression.parse(expressionSource)\n *  The parse function takes an expression string as input and returns \n *  an `evaluate` function as output.\n *\n *  The `evaluate` function takes an expression context as input and\n *  returns the expression value.\n */\nexports.parse = (expression) => {\n    const evaluate = parse(expression);\n    return async (expressionContext) => {\n        if (!context.isPrototypeOf(expressionContext)) {\n            throw new Error(\"Invalid context.\")\n        };\n        const value = await evaluate(expressionContext);\n        return normalize(value);\n    }\n}\n\n\n/**\n *  ### expression.createContext(namespace)\n *  Create and expression context containing all the names defined in the\n *  passed namespace.\n *  \n *  The returned namespace can then easily extended with context.$assign (deep version\n *  of Object.assign) and context.$extends (Object.create followed by context.$assign).\n */\nexports.createContext = (namespace) => {\n    return context.$extend(namespace);\n}\n\n\n/**\n *  ### expression.evaluate(expressionSource, context)\n *  Shortcut for `expression.parse(expressionSource)(context)`\n */\nexports.evaluate = (expression, context) => {\n    return this.parse(expression)(context);\n}\n\n\n/**\n *  ### expression.stringify(x)\n *  Stringifies swan objects returned by an expression evaluator.\n *  This is basically the `context.str` function adapted for javascript use.\n */\nexports.stringify = x => context.str(...Tuple.from(x));\n\n\n/**\n *  ### expression.apply(f, ...args)\n *  Applies the `args` arguments to the callable `f`\n */\nexports.apply = (f, ...args) => apply(f, Tuple.from(...args));\n\nexports.Exception = Exception;\n\nexports.Tuple = Tuple;\n\nexports.isValidName = isValidName;\n\n\n//# sourceURL=webpack:///./lib/expression.js?");

/***/ }),

/***/ "./lib/expression/lexer.js":
/*!*********************************!*\
  !*** ./lib/expression/lexer.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nclass SyntaxError extends Error {\n    \n    constructor (source, pos, message) {\n        super(`${message} at pos ${pos}`);\n    }\n}\n\n\n\n\n\n\nconst matchSpace = char => char && char.match(/^\\s$/);\nconst matchQuote = char => char && char.match(/^[\"'`]$/);\nconst matchIdentifierStart = char => char && char.match(/^[a-z_A-Z]$/);\nconst matchIdentifierPart = char => char && char.match(/^[a-z_A-Z0-9]$/);\nconst matchDecimalDigit = char => char && char.match(/^[0-9]$/);\nconst matchSign = char => char === \"+\" || char === \"-\";\n\nconst SYMBOLS = new Set( ['{', '[', '(', ')', ']', '}', \"=\", \":\", '->', \".\", \",\"] );\nconst matchSymbol = sym => SYMBOLS.has(sym);\n\nconst matchCommentStart = sym => sym === \"#\";\n\nconst binaryOperators = new Set();\n\n\nfunction createLexer (options) {\n    const matchSpace = char => char && char.match(/^\\s$/);\n    const matchQuote = char => char && char.match(/^[\"'`]$/);\n    const matchIdentifierStart = char => char && char.match(/^[a-z_A-Z]$/);\n    const matchIdentifierPart = char => char && char.match(/^[a-z_A-Z0-9]$/);\n    const matchDecimalDigit = char => char && char.match(/^[0-9]$/);\n    const matchSign = char => char === \"+\" || char === \"-\";\n\n    const binaryOperators = new Set(options.binaryOperators);\n    \n    const SYMBOLS = new Set( ['{', '[', '(', ')', ']', '}'].concat(options.binaryOperators.filter(operator => !matchIdentifierStart(operator))) );\n    const matchSymbol = sym => SYMBOLS.has(sym);\n    \n    class Token {\n        \n        constructor (type, value) {\n            this.type = type;\n            this.value = value;\n        }    \n        \n        matchSymbol (sym) {\n            return this.type === Token.SYMBOL && this.value === sym;\n        }\n        \n        matchSign () {\n            return this.matchSymbol(\"+\") || this.matchSymbol(\"-\");\n        }\n        \n        matchIdentifier () {\n            return this.type === Token.IDENTIFIER && !binaryOperators.has(this.value);\n        }\n        \n        matchBinaryOperator () {\n            return (this.type === Token.SYMBOL || this.type === Token.IDENTIFIER) && \n                    binaryOperators.has(this.value);\n        }\n        \n        matchOpenBracket () {\n            return this.matchSymbol('(') || this.matchSymbol('[');\n        }\n        \n        matchNumberLiteral () {\n            return this.type === Token.NUMBER;\n        }\n        \n        matchStringLiteral () {\n            return this.type === Token.STRING;\n        }\n\n        matchLiteral () {\n            return this.type === Token.NUMBER || this.type === Token.STRING;\n        }\n    }\n\n    // Token types\n    Token.SYMBOL = 0;\n    Token.NUMBER = 1;\n    Token.STRING0 = 2;\n    Token.STRING1 = 3;\n    Token.STRING2 = 4;\n    Token.IDENTIFIER = 5;\n    \n    \n    const tokenize = (source) => {\n        const tokens = [];\n        \n        var i = 0, len = source.length;\n        while (true) {\n            while (matchSpace(source[i])) i++;\n            if (i >= len) break;\n\n            // if string literal\n            if (matchQuote(source[i])) {\n                let value = \"\";            \n                let quoteSymbol = source[i]; i++;\n                while (source[i] !== quoteSymbol) {\n                    if (i >= len) throw new SyntaxError(source, i, \"Closing quote expected\");\n                    value += source[i]; i++;\n                }\n                let token = new Token(Token.STRING, value);\n                token.quoteSymbol = quoteSymbol;\n                tokens.push(token); i++;\n            }\n            \n            // if identifier\n            else if (matchIdentifierStart(source[i])) {\n                let value = source[i]; i++;\n                while (matchIdentifierPart(source[i])) {\n                    value += source[i]; i++;\n                }\n                tokens.push( new Token(Token.IDENTIFIER, value) );\n            }\n\n            // if number literal\n            else if (matchDecimalDigit(source[i])) {\n                let numStr = source[i]; i++;\n                \n                while (matchDecimalDigit(source[i])) {\n                    numStr += source[i]; i++;\n                }\n\n                if (source[i] === \".\") {\n                    numStr += source[i]; i++;\n                    while (matchDecimalDigit(source[i])) {\n                        numStr += source[i]; i++;\n                    }        \n                }\n                \n                if (source[i] === 'e' || source[i] === 'E') {\n                    numStr += 'E'; i++;\n                    if (source[i] === '+' || source[i] === '-') { // exponent sign\n                        numStr += source[i]; i++;\n                    }\n                    if (!matchDecimalDigit(source[i])) {\n                        throw new SyntaxError(source, i, `Expected exponent symbol`);                    \n                    }\n                    numStr += source[i]; i++;\n                    while (matchDecimalDigit(source[i])) {\n                        numStr += source[i]; i++;\n                    }        \n                }\n                \n                if (matchIdentifierStart(source[i])) {\n                    throw new SyntaxError(source, i, `Name names cannot start with a number`);\n                } else if (source[i] === \".\") {\n                    throw new SyntaxError(source, i, 'Unexpected period');\n                }\n\n                tokens.push( new Token(Token.NUMBER, Number(numStr)) );\n            }\n            \n            else if (matchCommentStart(source[i])) {\n                i++; while (source[i] !== \"\\n\" && i < len) i++;\n            }\n            \n            else if (matchSymbol( source[i]+source[i+1] )) {\n                tokens.push( new Token(Token.SYMBOL, source[i]+source[i+1])); i+=2;\n            } \n            \n            else if (matchSymbol( source[i] )) {\n                tokens.push( new Token(Token.SYMBOL, source[i])); i++;\n            } \n\n            else {\n                throw new Error(`Unexpected character '${source[i]}' at pos ${i}`);\n            }\n        }\n        \n        return tokens;\n    }\n    \n    return tokenize;\n}\n\n\n\n\n\n\nmodule.exports = createLexer;\n\n\n//# sourceURL=webpack:///./lib/expression/lexer.js?");

/***/ }),

/***/ "./lib/expression/parser.js":
/*!**********************************!*\
  !*** ./lib/expression/parser.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Lexer = __webpack_require__(/*! ./lexer */ \"./lib/expression/lexer.js\");\n\nconst GLOBALS = Symbol(\"Globals\");\n\n\nfunction createParser (options) {\n    const binaryOperations = options.binaryOperations || {};\n    const separator = \",\";\n    const tokenize = Lexer({binaryOperators: Object.keys(binaryOperations)});\n    \n    const parse = (source) => {\n        \n        const parseExpression = (done) => {\n            if (done()) {\n                i++; return createOperation(options.voidHandler, []);\n            }\n            \n            var expression = [ parseOperand() ];\n            \n            while (true) {\n                if (done()) {\n                    i++; break;\n                }\n                if (tokens[i].matchBinaryOperator()) {\n                    let operator = binaryOperations[ tokens[i].value ]; i++;\n                    expression.push(operator);\n                    let operand = parseOperand();\n                    expression.push(operand);\n                }\n                else {\n                    let operator = binaryOperations[\"\"];\n                    expression.push(operator);\n                    let operand = parseOperand();\n                    expression.push(operand);\n                }\n            }\n            \n            while (expression.length > 1) {\n                \n                // find higher precedence operand\n                let precedence = 0;\n                let operatorIndex = 0;\n                for (let j=1; j<expression.length; j+=2) {\n                    let operator = expression[j];\n                    if (operator.precedence > precedence) {\n                        if (operator.right) {\n                            let handler = operator.handler;\n                            while (expression[j+2] && expression[j+2].handler === handler) j += 2;\n                        }\n                        precedence = operator.precedence;\n                        operatorIndex = j;\n                    }\n                }\n                \n                // evaluate the higher precedence operation\n                let leftHandOperand = expression[operatorIndex - 1];\n                let operator = expression[operatorIndex];\n                let rightHandOperand = expression[operatorIndex + 1];\n                let operation = createOperation(operator.handler, [leftHandOperand, rightHandOperand]);\n                \n                // replace the [...,left,operator,right,...] items with the operation node\n                expression.splice(operatorIndex-1, 3, operation);\n            }\n            \n            return expression[0];        \n        }\n        \n        const parseOperand = () => {\n            var operand;\n            \n            if (tokens[i].matchSign() && tokens[i+1].matchNumberLiteral()) {\n                let factor = tokens[i].value === \"-\" ? -1 : 1;\n                operand = createOperation(options.numberHandler, [tokens[i+1].value * factor]); i+=2;\n            }\n            \n            else if (tokens[i].matchNumberLiteral()) {\n                operand = createOperation(options.numberHandler, [tokens[i].value]); i++;\n            }\n            \n            else if (tokens[i].matchStringLiteral()) {\n                if (tokens[i].quoteSymbol === \"`\") operand = createOperation(options.stringHandler0, [tokens[i].value]);\n                else if (tokens[i].quoteSymbol === `'`) operand = createOperation(options.stringHandler1, [tokens[i].value]);\n                else if (tokens[i].quoteSymbol === `\"`) operand = createOperation(options.stringHandler2, [tokens[i].value]);\n                i++;\n            }\n            \n            else if (tokens[i].matchIdentifier()) {\n                operand = createOperation(options.nameHandler, [tokens[i].value]); i++;            \n            }\n            \n            else if (tokens[i].matchSymbol('(')) {\n                i++; operand = parseExpression( () => tokens[i].matchSymbol(\")\") );\n            }\n            \n            else if (tokens[i].matchSymbol('[')) {\n                i++;\n                let expression = parseExpression( () => tokens[i].matchSymbol(\"]\") );\n                operand = createOperation(options.squareGroupHandler, [expression]);\n            }\n            \n            else if (tokens[i].matchSymbol('{')) {\n                i++;\n                let expression = parseExpression( () => tokens[i].matchSymbol(\"}\") );\n                operand = createOperation(options.curlyGroupHandler, [expression]);\n            }\n            \n            else {\n                throw new Error('Operand expected.');\n            }\n            \n            return operand;\n        }\n        \n        const tokens = tokenize(source);\n        var i = 0;\n        \n        const evaluate = parseExpression( () => i >= tokens.length );\n\n        return evaluate;\n    }\n    \n    return parse;\n}\n\n\nfunction createOperation (handlerName, operands) {\n    return scope => {\n        if (typeof scope[handlerName] !== \"function\") {\n            console.log(\"HANDLER NAME:\", handlerName);\n            console.log(\"SCOPE:\", scope);\n            throw new Error(`'${handlerName}' handler not defined in this context`);\n        }\n        return scope[handlerName](...operands);\n    }\n}\n\nmodule.exports = createParser;\n\n\n//# sourceURL=webpack:///./lib/expression/parser.js?");

/***/ }),

/***/ "./lib/stores/base-store.js":
/*!**********************************!*\
  !*** ./lib/stores/base-store.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nclass Store {   \n    \n    static createContainerDocument (path, items) {\n        return `<% items = ${JSON.stringify(items)} %>`;\n    }\n    \n    static createEmptyDocument (path) {\n        return \"\";\n    }\n    \n    static createReader (...args) {\n        const store = new this(...args);\n        return store.read.bind(store);\n    }\n}\n\nmodule.exports = Store;\n\n\n//# sourceURL=webpack:///./lib/stores/base-store.js?");

/***/ }),

/***/ "./lib/stores/http-store.js":
/*!**********************************!*\
  !*** ./lib/stores/http-store.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  # HTTPStore class\n *  This class provides an interface to an HTTP file server.\n *  The methods of an HTTPStore instance work out-of the box with a \n *  [BackendEnvironment](./backend-environment.md) server.\n */\n\n__webpack_require__(/*! isomorphic-fetch */ \"./node_modules/isomorphic-fetch/fetch-npm-browserify.js\");\nconst Store = __webpack_require__(/*! ./base-store */ \"./lib/stores/base-store.js\");\n\n\nclass HTTPStore extends Store {\n\n    /**\n     *  ### new HTTPStore(host)\n     *  The parameter is the base URL that will be prepended to all \n     *  HTTP requests.\n     */\n    constructor (host, options={}) {\n        super();\n        while (host.slice(-1) === \"/\") host = host.slice(0,-1);\n        this.host = host;\n        this.options = {\n            headers: isObject(options.headers) ? options.headers : {}\n        };\n    }\n    \n    /**\n     *  ### HTTPStore.prototype.read(path)\n     *  Sends a HTTP `GET path` request to `this.host` and returns the response.\n     *  Incase of 403 response code, throws `HTTPStore.ReadAccessDeniedError`.\n     */\n    async read (path) {\n        const url = normalizePath(this.host, path);\n        const response = await fetch(url, {\n            method: 'get',\n            headers: Object.assign({\n                'Accept': 'text/olo'\n            }, this.options.headers),\n        });\n        \n        switch (response.status) {\n            case 200:\n                return await response.text();\n            case 403:\n                throw new this.constructor.ReadAccessDeniedError(path);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }\n    }\n\n    /**\n     *  ### HTTPStore.prototype.write(path, source)\n     *  Sends a HTTP `PUT path` request with `source` as body to `this.host` \n     *  and resolves on 200 or 201 response code or rejects or error response code.\n     *  Incase of 403 response code, throws `HTTPStore.WriteAccessDeniedError`.\n     */\n    async write (path, source) {\n        const url = normalizePath(this.host, path);\n        const response = await fetch(url, {\n            method: 'put',\n            headers: Object.assign({\n                'Accept': \"text/olo\",\n                'Content-Type': 'text/olo'\n            }, this.options.headers),\n            body: String(source)\n        });\n        \n        switch (response.status) {\n            case 200:\n            case 201:\n                break;\n            case 403:\n                throw new this.constructor.WriteAccessDeniedError(path);\n            case 405:\n                throw new Error(`Write operation not defined on path ${path}`);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }                    \n    }\n    \n    /**\n     *  ### HTTPStore.prototype.delete(path)\n     *  Sends a HTTP `DELETE path` request to `this.host` and resolves \n     *  on 200 or 201 response code or rejects or error response code.\n     *  Incase of 403 response code, throws `HTTPStore.WriteAccessDeniedError`.\n     */\n    async delete (path) {\n        const url = normalizePath(this.host, path);\n        const response = await fetch(url, {\n            method: 'delete',\n            headers: Object.assign({\n                'Accept': \"text/olo\"                \n            }, this.options.headers),\n        });\n        switch (response.status) {\n            case 200:\n                break;\n            case 403:\n                throw new this.constructor.WriteAccessDeniedError(path);            \n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }                            \n    }\n\n    // Error throw on 403 GET response code\n    static get ReadAccessDeniedError () {\n        return ReadAccessDeniedError\n    }\n\n    // Error throw on 403 PUT/DELETE response code\n    static get WriteAccessDeniedError () {\n        return WriteAccessDeniedError\n    }\n\n    /**\n     *  ### FSStore.createReader(host)\n     *  Returns the `HTTPStore.prototype.read` function bound to the given `host`.\n     */\n    // static createReader(rootPath) inherited from BaseStore\n}\n\n\nfunction normalizePath (hostURL, path) {\n    if (path[0] !== \"/\") path = \"/\" + path;\n    return hostURL + path;    \n}\n\n\nclass AccessDeniedError extends Error {\n    constructor (operation, path) {\n        super(`${operation} access denied on path ${path}`);\n    }\n}\n\nclass ReadAccessDeniedError extends AccessDeniedError {\n    constructor (path) {\n        super(\"Read\", path);\n    }\n}\n\nclass WriteAccessDeniedError extends AccessDeniedError {\n    constructor (path) {\n        super(\"Write\", path);\n    }\n}\n\n\n\n\nmodule.exports = HTTPStore;\n\n\n//------\n//  SERVICE FUNCTIONS\n//------\n\nconst isObject = x => typeof x === \"object\" && x !== null & !Array.isArray(x);\n\n\n//# sourceURL=webpack:///./lib/stores/http-store.js?");

/***/ }),

/***/ "./lib/stores/router.js":
/*!******************************!*\
  !*** ./lib/stores/router.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst Path = __webpack_require__(/*! ../tools/path */ \"./lib/tools/path.js\");\n\n\nclass Router {\n    \n    constructor (routes={}) {\n        this._pathHandlers = [];\n        for (let path in routes) {\n            let pathHandler = this._createPathHandler(path, routes[path]);\n            this._pathHandlers.push(pathHandler);\n        }\n        this._pathHandlers.sort(comparePathHandlers).reverse();\n    }\n    \n    _createPathHandler (path, handler) {\n        const pathHandler = {};\n        \n        pathHandler.path = Path.from(path+\"/\");\n        \n        if (isFunction(handler)) {\n            pathHandler.read = handler;\n        } else if (isObject(handler) && isFunction(handler.read)) {\n            pathHandler.read = handler.read.bind(handler);\n        } else {\n            pathHandler.read = () => {throw new Error(`Read operation not defined for paths ${pathHandler.path}*`)}            \n        }\n        \n        if (isObject(handler) && isFunction(handler.write)) {\n            pathHandler.write = handler.write.bind(handler);            \n        }\n\n        if (isObject(handler) && isFunction(handler.delete)) {\n            pathHandler.delete = handler.delete.bind(handler);            \n        }\n        \n        return pathHandler;\n    }  \n    \n    _findPathHandler (docPath) {\n        docPath = Path.from(docPath);\n        for (let pathHandler of this._pathHandlers) {\n            let subPath = pathHandler.path.getSubPath(docPath);\n            if (subPath !== \"\") return [pathHandler, subPath];\n        }\n        throw new Error(`Handler not defined for path ${docPath}`);\n    }\n    \n    read (path) {\n        const docPath = Path.from(path);\n        let [pathHandler, docSubPath] = this._findPathHandler(docPath);\n        return pathHandler.read(String(docSubPath));\n    }    \n    \n    write (path, source=\"\") {\n        const docPath = Path.from(path);\n        let [pathHandler, docSubPath] = this._findPathHandler(docPath);\n        if (isFunction(pathHandler.write)) {\n            return pathHandler.write(String(docSubPath), source);        \n        } else {\n            throw new Error(`Write operation not defined for path ${docPath}`);\n        }\n    }      \n\n    delete (path) {\n        const docPath = Path.from(path);\n        let [pathHandler, docSubPath] = this._findPathHandler(docPath);\n        if (isFunction(pathHandler.delete)) {\n            return pathHandler.delete(String(docSubPath));        \n        } else {\n            throw new Error(`Delete operation not defined for path ${docPath}`);\n        }\n    }      \n}\n\n\nmodule.exports = Router;\n\n\n\n// HELPER FUNCTIONS\n\nconst isObject = x => typeof x === \"object\" && x !== null & !Array.isArray(x);\n\nconst isString = x => typeof x === \"string\";\n\nconst isFunction = x => typeof x === \"function\";\n\nfunction comparePathHandlers (pathHandler1, pathHandler2) {\n    const path1 = String(pathHandler1.path);\n    const path2 = String(pathHandler2.path);\n    return path1.localeCompare(path2);\n}\n\n\n//# sourceURL=webpack:///./lib/stores/router.js?");

/***/ }),

/***/ "./lib/tools/parameters-parser.js":
/*!****************************************!*\
  !*** ./lib/tools/parameters-parser.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst expression = __webpack_require__(/*! ../expression */ \"./lib/expression.js\");\n\n\nmodule.exports = function (...keyValuePairs) {\n    const argns = {};\n    for (let keyValuePair of keyValuePairs) {\n        const separatorIndex = keyValuePair.indexOf(\"=\");\n        if (separatorIndex === -1) {\n            let name = keyValuePair.trim();\n            if (expression.isValidName(name)) argns[name] = null;\n        } else {\n            name = keyValuePair.slice(0, separatorIndex).trim();\n            if (expression.isValidName(name)) {\n                let string = keyValuePair.slice(separatorIndex+1).trim();\n                let number = Number(string);\n                argns[name] = isNaN(number) ? string : number;\n            }\n        }\n    }\n    return argns;\n}\n\n\n//# sourceURL=webpack:///./lib/tools/parameters-parser.js?");

/***/ }),

/***/ "./lib/tools/path.js":
/*!***************************!*\
  !*** ./lib/tools/path.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const pathlib = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n\n\nclass Path {\n    \n    constructor (path) {\n        const urlMatch = matchURL(path);\n        if (urlMatch) {\n            this._rootURL = urlMatch[1].slice(-1) === \"/\" ? urlMatch[1].slice(0,-1) : urlMatch[1];\n            this._path = urlMatch[2] ? pathlib.join(\"/\", urlMatch[2]) : \"/\";\n        } else {\n            this._rootURL = \"\";\n            this._path = pathlib.join(\"/\", String(path));\n        }\n    }\n    \n    resolve (subPath) {\n        if (typeof subPath !== \"string\") {\n            throw new Error(\"Path.resolve exprexts a string as argument\");\n        }\n        \n        if (subPath[0] === \"/\") {\n            return new Path(this._rootURL + subPath);\n        }\n\n        if (matchURL(subPath)) {\n            return new Path(subPath);\n        }\n\n        if (this._path.slice(-1) === \"/\") {\n            var fullPath = pathlib.resolve(this._path, subPath);\n        } else {\n            var fullPath = pathlib.resolve(this._path, \"..\", subPath);            \n        }\n        return new Path(this._rootURL + fullPath);\n    }\n    \n    getSubPath (path) {\n        let parentPath = String(this);\n        let childPath = String(Path.from(path));\n        if (childPath === parentPath) return \"/\";\n        if (parentPath.slice(-1) !== \"/\") parentPath += \"/\";\n        return childPath.indexOf(parentPath) === 0 ? childPath.slice(parentPath.length-1) : \"\";\n    }\n    \n    toString () {\n        return this._rootURL + this._path;\n    }\n    \n    static from (path) {\n        return (path instanceof Path) ? path : new Path(path);\n    }\n}\n\nmodule.exports = Path;\n\n\n\n// HELPER FUNCTIONS\n\nfunction matchURL (path) {\n    return String(path).match(/^(\\w+\\:\\/\\/[\\w\\.\\:]*)(\\/.*)?$/);\n}\n\n\n//# sourceURL=webpack:///./lib/tools/path.js?");

/***/ }),

/***/ "./node_modules/dompurify/dist/purify.js":
/*!***********************************************!*\
  !*** ./node_modules/dompurify/dist/purify.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\nfunction _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar hasOwnProperty = Object.hasOwnProperty;\nvar setPrototypeOf = Object.setPrototypeOf;\nvar isFrozen = Object.isFrozen;\nvar objectKeys = Object.keys;\nvar freeze = Object.freeze;\nvar seal = Object.seal; // eslint-disable-line import/no-mutable-exports\n\nvar _ref = typeof Reflect !== 'undefined' && Reflect;\nvar apply = _ref.apply;\nvar construct = _ref.construct;\n\nif (!apply) {\n  apply = function apply(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\nif (!freeze) {\n  freeze = function freeze(x) {\n    return x;\n  };\n}\n\nif (!seal) {\n  seal = function seal(x) {\n    return x;\n  };\n}\n\nif (!construct) {\n  construct = function construct(Func, args) {\n    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray$1(args))))();\n  };\n}\n\nvar arrayForEach = unapply(Array.prototype.forEach);\nvar arrayIndexOf = unapply(Array.prototype.indexOf);\nvar arrayJoin = unapply(Array.prototype.join);\nvar arrayPop = unapply(Array.prototype.pop);\nvar arrayPush = unapply(Array.prototype.push);\nvar arraySlice = unapply(Array.prototype.slice);\n\nvar stringToLowerCase = unapply(String.prototype.toLowerCase);\nvar stringMatch = unapply(String.prototype.match);\nvar stringReplace = unapply(String.prototype.replace);\nvar stringIndexOf = unapply(String.prototype.indexOf);\nvar stringTrim = unapply(String.prototype.trim);\n\nvar regExpTest = unapply(RegExp.prototype.test);\nvar regExpCreate = unconstruct(RegExp);\n\nvar typeErrorCreate = unconstruct(TypeError);\n\nfunction unapply(func) {\n  return function (thisArg) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return apply(func, thisArg, args);\n  };\n}\n\nfunction unconstruct(func) {\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return construct(func, args);\n  };\n}\n\n/* Add properties to a lookup table */\nfunction addToSet(set, array) {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  var l = array.length;\n  while (l--) {\n    var element = array[l];\n    if (typeof element === 'string') {\n      var lcElement = stringToLowerCase(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          array[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/* Shallow clone an object */\nfunction clone(object) {\n  var newObject = {};\n\n  var property = void 0;\n  for (property in object) {\n    if (apply(hasOwnProperty, object, [property])) {\n      newObject[property] = object[property];\n    }\n  }\n\n  return newObject;\n}\n\nvar html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n// SVG\nvar svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern']);\n\nvar svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\nvar mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\nvar text = freeze(['#text']);\n\nvar html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'coords', 'crossorigin', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'integrity', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);\n\nvar svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\nvar mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\nvar xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\nvar MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nvar ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\nvar DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\nvar ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nvar IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nvar IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nvar ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g // eslint-disable-line no-control-regex\n);\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar getGlobal = function getGlobal() {\n  return typeof window === 'undefined' ? null : window;\n};\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {Document} document The document object (to determine policy name suffix)\n * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported).\n */\nvar _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  var suffix = null;\n  var ATTR_NAME = 'data-tt-policy-suffix';\n  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n    suffix = document.currentScript.getAttribute(ATTR_NAME);\n  }\n\n  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML: function createHTML(html$$1) {\n        return html$$1;\n      }\n    });\n  } catch (error) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n    return null;\n  }\n};\n\nfunction createDOMPurify() {\n  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n  var DOMPurify = function DOMPurify(root) {\n    return createDOMPurify(root);\n  };\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  DOMPurify.version = '2.0.8';\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  DOMPurify.removed = [];\n\n  if (!window || !window.document || window.document.nodeType !== 9) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  var originalDocument = window.document;\n  var useDOMParser = false;\n  var removeTitle = false;\n\n  var document = window.document;\n  var DocumentFragment = window.DocumentFragment,\n      HTMLTemplateElement = window.HTMLTemplateElement,\n      Node = window.Node,\n      NodeFilter = window.NodeFilter,\n      _window$NamedNodeMap = window.NamedNodeMap,\n      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n      Text = window.Text,\n      Comment = window.Comment,\n      DOMParser = window.DOMParser,\n      trustedTypes = window.trustedTypes;\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n\n  if (typeof HTMLTemplateElement === 'function') {\n    var template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';\n\n  var _document = document,\n      implementation = _document.implementation,\n      createNodeIterator = _document.createNodeIterator,\n      getElementsByTagName = _document.getElementsByTagName,\n      createDocumentFragment = _document.createDocumentFragment;\n  var importNode = originalDocument.importNode;\n\n\n  var hooks = {};\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && document.documentMode !== 9;\n\n  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n      ERB_EXPR$$1 = ERB_EXPR,\n      DATA_ATTR$$1 = DATA_ATTR,\n      ARIA_ATTR$$1 = ARIA_ATTR,\n      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n\n  var ALLOWED_TAGS = null;\n  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(svgFilters), _toConsumableArray(mathMl), _toConsumableArray(text)));\n\n  /* Allowed attribute names */\n  var ALLOWED_ATTR = null;\n  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(mathMl$1), _toConsumableArray(xml)));\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  var FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  var FORBID_ATTR = null;\n\n  /* Decide if ARIA attributes are okay */\n  var ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  var ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Output should be safe for jQuery's $() factory? */\n  var SAFE_FOR_JQUERY = false;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  var SAFE_FOR_TEMPLATES = false;\n\n  /* Decide if document with <html>... should be returned */\n  var WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  var SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  var FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  var RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  var RETURN_DOM_FRAGMENT = false;\n\n  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n   * `Node` is imported into the current `Document`. If this flag is not enabled the\n   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n   * DOMPurify. */\n  var RETURN_DOM_IMPORT = false;\n\n  /* Try to return a Trusted Type object instead of a string, retrun a string in\n   * case Trusted Types are not supported  */\n  var RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks? */\n  var SANITIZE_DOM = true;\n\n  /* Keep element content when removing element? */\n  var KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  var IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  var USE_PROFILES = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n  /* Tags that are safe for data: URIs */\n  var DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image']);\n\n  /* Attributes safe for values like \"javascript:\" */\n  var URI_SAFE_ATTRIBUTES = null;\n  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n  /* Keep a reference to config to pass to hooks */\n  var CONFIG = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  var formElement = document.createElement('form');\n\n  /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  var _parseConfig = function _parseConfig(cfg) {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n      cfg = {};\n    }\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(text)));\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, html);\n        addToSet(ALLOWED_ATTR, html$1);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, svg);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, svgFilters);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, mathMl);\n        addToSet(ALLOWED_ATTR, mathMl$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */\n  var _forceRemove = function _forceRemove(node) {\n    arrayPush(DOMPurify.removed, { element: node });\n    try {\n      node.parentNode.removeChild(node);\n    } catch (error) {\n      node.outerHTML = emptyHTML;\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */\n  var _removeAttribute = function _removeAttribute(name, node) {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: node.getAttributeNode(name),\n        from: node\n      });\n    } catch (error) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: node\n      });\n    }\n\n    node.removeAttribute(name);\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */\n  var _initDocument = function _initDocument(dirty) {\n    /* Create a HTML document */\n    var doc = void 0;\n    var leadingWhitespace = void 0;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      var matches = stringMatch(dirty, /^[\\s]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n\n    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n    /* Use DOMParser to workaround Firefox bug (see comment below) */\n    if (useDOMParser) {\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');\n      } catch (error) {}\n    }\n\n    /* Remove title to fix a mXSS bug in older MS Edge */\n    if (removeTitle) {\n      addToSet(FORBID_TAGS, ['title']);\n    }\n\n    /* Otherwise use createHTMLDocument, because DOMParser is unsafe in\n    Safari (see comment below) */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createHTMLDocument('');\n      var _doc = doc,\n          body = _doc.body;\n\n      body.parentNode.removeChild(body.parentNode.firstElementChild);\n      body.outerHTML = dirtyPayload;\n    }\n\n    if (dirty && leadingWhitespace) {\n      doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);\n    }\n\n    /* Work on whole document or just its body */\n    return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n  };\n\n  // Firefox uses a different parser for innerHTML rather than\n  // DOMParser (see https://bugzilla.mozilla.org/show_bug.cgi?id=1205631)\n  // which means that you *must* use DOMParser, otherwise the output may\n  // not be safe if used in a document.write context later.\n  //\n  // So we feature detect the Firefox bug and use the DOMParser if necessary.\n  //\n  // Chrome 77 and other versions ship an mXSS bug that caused a bypass to\n  // happen. We now check for the mXSS trigger and react accordingly.\n  if (DOMPurify.isSupported) {\n    (function () {\n      try {\n        var doc = _initDocument('<svg><p><textarea><img src=\"</textarea><img src=x abc=1//\">');\n        if (doc.querySelector('svg img')) {\n          useDOMParser = true;\n        }\n      } catch (error) {}\n    })();\n\n    (function () {\n      try {\n        var doc = _initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');\n        if (regExpTest(/<\\/title/, doc.querySelector('title').innerHTML)) {\n          removeTitle = true;\n        }\n      } catch (error) {}\n    })();\n  }\n\n  /**\n   * _createIterator\n   *\n   * @param  {Document} root document/fragment to create iterator for\n   * @return {Iterator} iterator instance\n   */\n  var _createIterator = function _createIterator(root) {\n    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {\n      return NodeFilter.FILTER_ACCEPT;\n    }, false);\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */\n  var _isClobbered = function _isClobbered(elm) {\n    if (elm instanceof Text || elm instanceof Comment) {\n      return false;\n    }\n\n    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string') {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * _isNode\n   *\n   * @param  {Node} obj object to check whether it's a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */\n  var _isNode = function _isNode(obj) {\n    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? obj instanceof Node : obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';\n  };\n\n  /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook's entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */\n  var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n\n    arrayForEach(hooks[entryPoint], function (hook) {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  };\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */\n  // eslint-disable-next-line complexity\n  var _sanitizeElements = function _sanitizeElements(currentNode) {\n    var content = void 0;\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeElements', currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    var tagName = stringToLowerCase(currentNode.nodeName);\n\n    /* Execute a hook if present */\n    _executeHook('uponSanitizeElement', currentNode, {\n      tagName: tagName,\n      allowedTags: ALLOWED_TAGS\n    });\n\n    /* Take care of an mXSS pattern using p, br inside svg, math */\n    if ((tagName === 'svg' || tagName === 'math') && currentNode.querySelectorAll('p, br').length !== 0) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove element if anything forbids its presence */\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Keep content except for black-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {\n        try {\n          var htmlToInsert = currentNode.innerHTML;\n          currentNode.insertAdjacentHTML('AfterEnd', trustedTypesPolicy ? trustedTypesPolicy.createHTML(htmlToInsert) : htmlToInsert);\n        } catch (error) {}\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove in case a noscript/noembed XSS is suspected */\n    if (tagName === 'noscript' && regExpTest(/<\\/noscript/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    if (tagName === 'noembed' && regExpTest(/<\\/noembed/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Convert markup to cover jQuery behavior */\n    if (SAFE_FOR_JQUERY && !currentNode.firstElementChild && (!currentNode.content || !currentNode.content.firstElementChild) && regExpTest(/</g, currentNode.textContent)) {\n      arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n      if (currentNode.innerHTML) {\n        currentNode.innerHTML = stringReplace(currentNode.innerHTML, /</g, '&lt;');\n      } else {\n        currentNode.innerHTML = stringReplace(currentNode.textContent, /</g, '&lt;');\n      }\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n      content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n      content = stringReplace(content, ERB_EXPR$$1, ' ');\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeElements', currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName)) {\n      // This attribute is safe\n    } else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) {\n      // This attribute is safe\n      /* Otherwise, check the name is permitted */\n    } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      return false;\n\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) {\n      // This attribute is safe\n      /* Check no script, data or unknown possibly unsafe URI\n        unless we know URI values are safe for that attribute */\n    } else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) {\n      // This attribute is safe\n      /* Keep image data URIs alive if src/xlink:href is allowed */\n      /* Further prevent gadget XSS for dynamically built script tags */\n    } else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) {\n      // This attribute is safe\n      /* Allow unknown protocols: This provides support for links that\n        are handled by protocol handlers which may be unknown ahead of\n        time, e.g. fb:, spotify: */\n    } else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) {\n      // This attribute is safe\n      /* Check for binary attributes */\n      // eslint-disable-next-line no-negated-condition\n    } else if (!value) {\n      // Binary attributes are safe at this point\n      /* Anything else, presume unsafe, do not add it back */\n    } else {\n      return false;\n    }\n\n    return true;\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */\n  // eslint-disable-next-line complexity\n  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n    var attr = void 0;\n    var value = void 0;\n    var lcName = void 0;\n    var idAttr = void 0;\n    var l = void 0;\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n    var attributes = currentNode.attributes;\n\n    /* Check if we have attributes; if not we might have a text node */\n\n    if (!attributes) {\n      return;\n    }\n\n    var hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR\n    };\n    l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      attr = attributes[l];\n      var _attr = attr,\n          name = _attr.name,\n          namespaceURI = _attr.namespaceURI;\n\n      value = stringTrim(attr.value);\n      lcName = stringToLowerCase(name);\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n      value = hookEvent.attrValue;\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n\n      /* Remove attribute */\n      // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to\n      // remove a \"name\" attribute from an <img> tag that has an \"id\"\n      // attribute at the time.\n      if (lcName === 'name' && currentNode.nodeName === 'IMG' && attributes.id) {\n        idAttr = attributes.id;\n        attributes = arraySlice(attributes, []);\n        _removeAttribute('id', currentNode);\n        _removeAttribute(name, currentNode);\n        if (arrayIndexOf(attributes, idAttr) > l) {\n          currentNode.setAttribute('id', idAttr.value);\n        }\n      } else if (\n      // This works around a bug in Safari, where input[type=file]\n      // cannot be dynamically set after type has been removed\n      currentNode.nodeName === 'INPUT' && lcName === 'type' && value === 'file' && hookEvent.keepAttr && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])) {\n        continue;\n      } else {\n        // This avoids a crash in Safari v9.0 with double-ids.\n        // The trick is to first set the id to be empty and then to\n        // remove the attribute\n        if (name === 'id') {\n          currentNode.setAttribute(name, '');\n        }\n\n        _removeAttribute(name, currentNode);\n      }\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n\n      /* Work around a security issue in jQuery 3.0 */\n      if (SAFE_FOR_JQUERY && regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Take care of an mXSS pattern using namespace switches */\n      if (regExpTest(/svg|math/i, currentNode.namespaceURI) && regExpTest(regExpCreate('</(' + arrayJoin(objectKeys(FORBID_CONTENTS), '|') + ')', 'i'), value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n        value = stringReplace(value, ERB_EXPR$$1, ' ');\n      }\n\n      /* Is `value` valid for this attribute? */\n      var lcTag = currentNode.nodeName.toLowerCase();\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n          currentNode.setAttribute(name, value);\n        }\n\n        arrayPop(DOMPurify.removed);\n      } catch (error) {}\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeAttributes', currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */\n  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n    var shadowNode = void 0;\n    var shadowIterator = _createIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n    while (shadowNode = shadowIterator.nextNode()) {\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(shadowNode);\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeShadowDOM', fragment, null);\n  };\n\n  /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} configuration object\n   */\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty, cfg) {\n    var body = void 0;\n    var importedNode = void 0;\n    var currentNode = void 0;\n    var oldNode = void 0;\n    var returnNode = void 0;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    if (!dirty) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      // eslint-disable-next-line no-negated-condition\n      if (typeof dirty.toString !== 'function') {\n        throw typeErrorCreate('toString is not a function');\n      } else {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw typeErrorCreate('dirty is not a string, aborting');\n        }\n      }\n    }\n\n    /* Check we can run. Otherwise fall back or ignore */\n    if (!DOMPurify.isSupported) {\n      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n        if (typeof dirty === 'string') {\n          return window.toStaticHTML(dirty);\n        }\n\n        if (_isNode(dirty)) {\n          return window.toStaticHTML(dirty.outerHTML);\n        }\n      }\n\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === 'string') {\n      IN_PLACE = false;\n    }\n\n    if (IN_PLACE) {\n      /* No special handling necessary for in-place sanitization */\n    } else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!-->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && RETURN_TRUSTED_TYPE && dirty.indexOf('<') === -1) {\n        return trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : emptyHTML;\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while (currentNode = nodeIterator.nextNode()) {\n      /* Fix IE's strange behavior with manipulated textNodes #89 */\n      if (currentNode.nodeType === 3 && currentNode === oldNode) {\n        continue;\n      }\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(currentNode);\n\n      oldNode = currentNode;\n    }\n\n    oldNode = null;\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (RETURN_DOM_IMPORT) {\n        /* AdoptNode() is not used because internal state is not reset\n               (e.g. the past names map of a HTMLFormElement), this is safe\n               in theory but we would rather not risk another attack vector.\n               The state that is cloned by importNode() is explicitly defined\n               by the specs. */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n  };\n\n  /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */\n  DOMPurify.setConfig = function (cfg) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {string} tag Tag name of containing element.\n   * @param  {string} attr Attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    var lcTag = stringToLowerCase(tag);\n    var lcName = stringToLowerCase(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n\n  /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   */\n  DOMPurify.removeHook = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      arrayPop(hooks[entryPoint]);\n    }\n  };\n\n  /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */\n  DOMPurify.removeHooks = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n\n  /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   *\n   */\n  DOMPurify.removeAllHooks = function () {\n    hooks = {};\n  };\n\n  return DOMPurify;\n}\n\nvar purify = createDOMPurify();\n\nreturn purify;\n\n})));\n//# sourceMappingURL=purify.js.map\n\n\n//# sourceURL=webpack:///./node_modules/dompurify/dist/purify.js?");

/***/ }),

/***/ "./node_modules/isomorphic-fetch/fetch-npm-browserify.js":
/*!***************************************************************!*\
  !*** ./node_modules/isomorphic-fetch/fetch-npm-browserify.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\n__webpack_require__(/*! whatwg-fetch */ \"./node_modules/whatwg-fetch/fetch.js\");\nmodule.exports = self.fetch.bind(self);\n\n\n//# sourceURL=webpack:///./node_modules/isomorphic-fetch/fetch-npm-browserify.js?");

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/*! exports provided: Headers, Request, Response, DOMException, fetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Headers\", function() { return Headers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Request\", function() { return Request; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Response\", function() { return Response; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DOMException\", function() { return DOMException; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetch\", function() { return fetch; });\nvar support = {\n  searchParams: 'URLSearchParams' in self,\n  iterable: 'Symbol' in self && 'iterator' in Symbol,\n  blob:\n    'FileReader' in self &&\n    'Blob' in self &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in self,\n  arrayBuffer: 'ArrayBuffer' in self\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n    throw new TypeError('Invalid character in header field name')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nfunction Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsText(blob)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    this._bodyInit = body\n    if (!body) {\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nfunction Request(input, options) {\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n    var parts = line.split(':')\n    var key = parts.shift().trim()\n    if (key) {\n      var value = parts.join(':').trim()\n      headers.append(key, value)\n    }\n  })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nfunction Response(bodyInit, options) {\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = 'statusText' in options ? options.statusText : 'OK'\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 0, statusText: ''})\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nvar DOMException = self.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nfunction fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      resolve(new Response(body, options))\n    }\n\n    xhr.onerror = function() {\n      reject(new TypeError('Network request failed'))\n    }\n\n    xhr.ontimeout = function() {\n      reject(new TypeError('Network request failed'))\n    }\n\n    xhr.onabort = function() {\n      reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    xhr.open(request.method, request.url, true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr && support.blob) {\n      xhr.responseType = 'blob'\n    }\n\n    request.headers.forEach(function(value, name) {\n      xhr.setRequestHeader(name, value)\n    })\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch.polyfill = true\n\nif (!self.fetch) {\n  self.fetch = fetch\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n}\n\n\n//# sourceURL=webpack:///./node_modules/whatwg-fetch/fetch.js?");

/***/ }),

/***/ "./src/browser-environment.js":
/*!************************************!*\
  !*** ./src/browser-environment.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  # BrowserEnvironment class\n *\n *  This class extends the [Environment](./environment.md) class in order to\n *  create and olojs environment suitable for browsers.\n */\n\nconst Environment = __webpack_require__(/*! ../lib/environment */ \"./lib/environment.js\");\nconst document = __webpack_require__(/*! ../lib/document */ \"./lib/document.js\");\nconst HTTPStore = __webpack_require__(/*! ../lib/stores/http-store */ \"./lib/stores/http-store.js\");\nconst parseParams = __webpack_require__(/*! ../lib/tools/parameters-parser */ \"./lib/tools/parameters-parser.js\");\nconst DOMPurify = __webpack_require__(/*! dompurify */ \"./node_modules/dompurify/dist/purify.js\");    \nconst Router = __webpack_require__(/*! ../lib/stores/router */ \"./lib/stores/router.js\");\n\n\nclass BrowserEnvironment extends Environment {\n\n\n    /**\n     *  ### new BrowserEnvironment(origin, headers)\n     *  This environment creates three stores:\n     *  - `/`: backed by the http store under `origin`\n     *  - `http://`: generic http reader\n     *  - `https://`: generic https reader\n     *  The root http reader `/` adds the passed headers to every request\n     *  \n     *  The environment globals contain a `require` function that loads the\n     *  [olojs standard library](./stdlib.md) modules.\n     */\n    constructor (origin, headers={}) {\n        super({\n            globals: {\n                $renderError (error) {\n                    console.error(error);\n                    return `<span style=\"color:red; font-weight:bold\">${error.message}</span>`;\n                },\n                require: modulePath => modules[modulePath]()\n            },\n            store: new Router({\n                \"/\":        new HTTPStore(origin, {headers}),\n                \"http://\":  HTTPStore.createReader(\"http://\"),\n                \"https://\": HTTPStore.createReader(\"https://\"),\n            })\n        })\n    }\n\n    \n    /**\n     *  ### BrowserEnvironment.stringifyDocumentExpression(value)\n     *  This method stringifies and sanitizes an expression value.\n     */\n    async stringifyDocumentExpression (value) {\n        const html = await super.stringifyDocumentExpression(value);\n        return DOMPurify.sanitize(html);\n    }\n    \n    /**\n     *  ### BrowserEnvironment.parseURI(uri)\n     *  Given an uri in the form `path?var1=val1&var2=val2&...`, returns\n     *  a the path and the parameters namespace as a pair [docPath, argns]\n     */\n    parseURI (uri) {\n        let [docPath, args] = uri.split(\"?\");\n        let argns = args ? parseParams(...args.split(\"&\")) : {};\n        return [docPath, argns];\n    }\n}\n\n\nmodule.exports = BrowserEnvironment;\n\n\n\nconst modules = {\n    \"math\"     : () => __webpack_require__.e(/*! import() | /bin/math */ \"/bin/math\").then(__webpack_require__.t.bind(null, /*! ../lib/environment/stdlib/math */ \"./lib/environment/stdlib/math.js\", 7)),\n    \"markdown\" : () => Promise.all(/*! import() | /bin/markdown */[__webpack_require__.e(\"vendors~/bin/markdown\"), __webpack_require__.e(\"/bin/markdown\")]).then(__webpack_require__.t.bind(null, /*! ../lib/environment/stdlib/markdown */ \"./lib/environment/stdlib/markdown.js\", 7)),\n    \"html\"     : () => __webpack_require__.e(/*! import() | /bin/html */ \"/bin/html\").then(__webpack_require__.t.bind(null, /*! ../lib/environment/stdlib/html */ \"./lib/environment/stdlib/html.js\", 7)),\n    \"path\"     : () => __webpack_require__.e(/*! import() | /bin/path */ \"/bin/path\").then(__webpack_require__.t.bind(null, /*! ../lib/environment/stdlib/path */ \"./lib/environment/stdlib/path.js\", 7)),\n}\n\n\n//# sourceURL=webpack:///./src/browser-environment.js?");

/***/ }),

/***/ "./src/environment-http-client.js":
/*!****************************************!*\
  !*** ./src/environment-http-client.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const BrowserEnvironment = __webpack_require__(/*! ./browser-environment */ \"./src/browser-environment.js\");\nmodule.exports = window.olonv = new BrowserEnvironment(location.origin);\n\n\n//# sourceURL=webpack:///./src/environment-http-client.js?");

/***/ })

/******/ });