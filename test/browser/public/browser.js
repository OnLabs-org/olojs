/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "../browser.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../browser.js":
/*!***************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/browser.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nmodule.exports = {\n    \n    expression: __webpack_require__(/*! ./lib/expression */ \"../../lib/expression.js\"),\n    document: __webpack_require__(/*! ./lib/document */ \"../../lib/document.js\"),\n    \n    Environment: __webpack_require__(/*! ./lib/environment */ \"../../lib/environment.js\"),\n    \n    stores: {\n        \"Empty\":  __webpack_require__(/*! ./lib/stores/empty */ \"../../lib/stores/empty.js\"),\n        \"Memory\": __webpack_require__(/*! ./lib/stores/memory */ \"../../lib/stores/memory.js\"),\n        \"HTTP\":   __webpack_require__(/*! ./lib/stores/http */ \"../../lib/stores/http.js\"),\n        \"Router\": __webpack_require__(/*! ./lib/stores/router */ \"../../lib/stores/router.js\"),\n    },\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/browser.js?");

/***/ }),

/***/ "../../lib/document.js":
/*!********************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/document.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  olojs.document\n *  ============================================================================\n *  This module contains functions to parse, evaluate and render any string of\n *  text formatted as olo-document.\n *    \n *  ```js\n *  const source = \"Twice x is <% 2*x %>!\";\n *  const context = olojs.document.createContext({x:10});\n *  const evaluate = olojs.document.parse(source);\n *  const namespace = await evaluate(context);\n *  const rendering = await olojs.document.render(namespace);\n *  // rendering is \"Twice x is 20!\"\n *  ```\n */\n\n\n\n//  olojs.document.expression\n//  ----------------------------------------------------------------------------\n//  This object is used to parse and evaluate the expression fields of the\n//  olo-document. It points by default to the swan expression module, but it \n//  could be replaced by any expression module implementing the followin \n//  methods:\n//  - expression.parse\n//  - expression.createContext\n//  - expression.stringify\n//  - expression.apply\nexports.expression = __webpack_require__(/*! ./expression */ \"../../lib/expression.js\");\n\n\n\n/**\n *  olojs.document.parse - function\n *  ----------------------------------------------------------------------------\n *  Compiles a document source into an `evaluate` function that takes as input\n *  a document context object and returns the document namespace object.\n *    \n *  ```js\n *  const evaluate = olojs.document.parse(source);\n *  const namespace = await evaluate(context);\n *  ```\n *\n *  - `source`: a string containing olo-document markup\n *  - `evaluate`: an asynchronous function that evaluates the document and \n *    returns its namespace\n *  - `namespace`: an object containing all the names defined by the inline \n *    expression of the document\n */ \nexports.parse = function (source) {\n    var parsedSource = String(source);\n    \n    // Find all the swan expressions in the source, store them in an array and\n    // replace them with a placeholder.\n    const parsedExpressions = [];\n    parsedSource = parsedSource.replace(/<%([\\s\\S]+?)%>/g, (match, expressionSource) => {  \n        let i = parsedExpressions.length;\n        let parsedExpression;\n        try {\n            parsedExpression = this.expression.parse(expressionSource);\n        } catch (error) {\n            parsedExpression = context => {throw error};\n        }\n        parsedExpression.source = expressionSource;            \n        parsedExpressions.push( parsedExpression );\n        return `<%${i}%>`;\n    }); \n    \n    // The returned `evaluate` function\n    return async (context) => {\n        const doc = {};\n        \n        // Evaluate each expression in the given context and replace the\n        // placeholder with the stringified expression value\n        var text = parsedSource;\n        for (let i=0; i<parsedExpressions.length; i++) {\n            let evaluateExpression = parsedExpressions[i];\n            try {\n                var value = await evaluateExpression(context);                                    \n            } catch (error) {\n                // Delegate error rendering to the custom `context.$renderError` function\n                var value = context.$renderError({\n                    message: error.message,\n                    source: evaluateExpression.source\n                });\n            }\n            text = text.replace(`<%${i}%>`, await this.render(value));\n        }\n        \n        // Extract the document namespace, discarding the global context\n        // variables.  \n        const namespace = Object.assign({}, context);\n        \n        // Define the `__str__` name as the rendered text in order to make the \n        // namespace stringify to the rendered text.\n        namespace.__str__ = text;\n\n        // Return the document namespace\n        return namespace;\n    };               \n}\n\n\n\n\n/**\n *  olojs.document.createContext - function\n *  ----------------------------------------------------------------------------\n *  Creates a custom document evaluation context, by adding to the basic \n *  context all the names defined in the passed namespace.\n *    \n *  ```js\n *  const context = olojs.document.createContext(...namespaces)\n *  ```\n *  - `namespaces`: list of objects; each of them, from left to right, will be \n *    mixed-in to the basic document context\n *  - `context`: an object containing all the named values and function that\n *    will be visible to the document inline expressions.\n */\nexports.createContext = function (...namespaces) {\n    return this.expression.createContext(documentGlobals, ...namespaces);\n}\n\nconst documentGlobals = {\n\n    $renderError (error) {\n        return `[!${error.message}]`;\n    },        \n};\n\n\n\n/**\n *  olojs.document.render - async function\n *  ----------------------------------------------------------------------------\n *  This function exposes to javascript the serialization algorithm used in\n *  to convert the inline expression result values to text.\n *    \n *  ```js\n *  const text = await olojs.render(value)\n *  ```\n *  \n *  - `value`: any javascript value\n *  - `text`: textual representation of the passed value, obtained according to\n *    the same rules applied to the inline expressions\n *  \n *  If it exists, this function applies the `context.__render__` decorator to \n *  the stringified value.\n */\n exports.render = async function (value) {\n    var text = this.expression.stringify(value);\n    if (value && value.__render__) {\n        text = await this.expression.apply(value.__render__, text);\n        text = await this.expression.stringify(text);            \n    }\n    return text;\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/document.js?");

/***/ }),

/***/ "../../lib/environment.js":
/*!***********************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/environment.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst pathlib = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\nconst document = __webpack_require__(/*! ./document */ \"../../lib/document.js\");\n\nconst EmptyStore = __webpack_require__(/*! ./stores/empty */ \"../../lib/stores/empty.js\");\nconst MemoryStore = __webpack_require__(/*! ./stores/memory */ \"../../lib/stores/memory.js\");\n\n\n\n/**\n *  olojs.Environment\n *  ============================================================================\n *  Creates a new olojs environment, which represents a colection of\n *  interdependent documents.\n *  \n *  \n *  ```js\n *  const environment = olojs.Environment({globals, store})\n *  ```\n *  \n *  - `globals` is on object containing a set of names that will be included in\n *    every document contexts; it defaults to {}\n *  - `store` is an olojs store object that will provide read/write access to\n *    the documents repository; it defaults to olojs.stores.Memory.\n */\n \nclass Environment {\n    \n    constructor (options) {\n        \n        this.store = getProp(options, 'store') instanceof EmptyStore ? \n                options.store : new MemoryStore();\n                \n        this.globals = isObject(getProp(options, 'globals')) ? \n                Object.create(options.globals) : {};\n\n                \n        // Create the import function to be used by document expressions to load\n        // and evaluate other documents of this environment\n        const environment = this;\n        this.globals.import = async function (subPath) {\n            const context = this;   // called by swan with the document context as first parameter of call\n            const targetPath = pathlib.resolve(context.__path__, isDir(context.__path__) ? '.' : '..', subPath);\n            if (context.$cache.imports.has(targetPath)) {\n                var targetDoc = context.$cache.imports.get(targetPath);\n            } else {\n                var targetDoc = await environment.readDocument(targetPath);\n                context.$cache.imports.set(targetPath, targetDoc);\n            }\n            const targetDocContext = targetDoc.createContext();\n            return await targetDoc.evaluate(targetDocContext);  \n        }\n    }\n    \n    /**\n     *  environment.createDocument - function\n     *  --------------------------------------------------------------------\n     *  Creates a document object containing the document source and\n     *  methods to evaluate that source to a namespace.\n     *  \n     *  ```js\n     *  const doc = environment.createDocument(id, source)\n     *  ```\n     *  \n     *  - `id` is a path uri identifying the document in this environment; it\n     *    can contain a path, an optional query and an optional frarment.\n     *  - `source` is the un-parsed content of the document\n     *  - `presets` is an object containing predefined name to be added to\n     *    the documen context\n     *  - `doc.id` contains the document id with the path segment in normalized form\n     *  - `doc.source` contain the un-parsed content of the document\n     *  - `doc.createContext` is a function that takes a list of namespaces\n     *    as input and returns a context that contains a) the environment\n     *    global namespace, b) the passed namespaces and c) the presets\n     *  - `evaluate` is an asynchronous function that takes a context as\n     *    input and returns the document namespace computed in that context\n     */\n    createDocument (id, source, presets) {\n        const environment = this;\n        const path = pathlib.join('/', sliceBefore(id, '?'));\n        const query = sliceAfter(id, '?');\n        const argns = query ? parseParameters(...query.split('&')) : {};\n        \n        const cache = {\n            evaluate: null,\n            imports: new Map()\n        };\n        \n        return {\n            \n            get id () {\n                return path + (query ? `?${query}` : \"\");\n            },\n            \n            get source () {\n                return String(source);\n            },\n            \n            createContext (...namespaces) {\n                const context = document.createContext(environment.globals, ...namespaces);\n                if (isObject(presets)) Object.assign(context, presets);\n                context.$cache = cache;\n                context.__path__ = path;\n                context.argns = argns;\n                return context;\n            },\n            \n            get evaluate () {\n                return cache.evaluate || (cache.evaluate = document.parse(this.source));\n            }        \n        }            \n    }\n    \n    /**\n     *  environment.readDocument - async function\n     *  --------------------------------------------------------------------\n     *  Returns the document mapped to a given id in this environment.\n     *  \n     *  ```js\n     *  const doc = await environment.readDocument(id)\n     *  ```\n     *  \n     *  - `id` is an URI that identifies the required document inside this\n     *    environment; it can contain a path, an optional query and an optional \n     *    frarment.\n     *  - `doc` is the document object returned by the `createDocument`\n     *    method.\n     */\n    async readDocument (id) {\n        const path = sliceBefore(id, '?');\n        const source = await this.store.get(path);\n        return this.createDocument(id, source);\n    }    \n\n\n    /**\n     *  environment.writeDocument - async function\n     *  --------------------------------------------------------------------\n     *  Changes the content of the document mapped to the given id in this\n     *  environment.\n     *\n     *  ```js\n     *  await environment.writeDocument(id, source)\n     *  ```\n     *  \n     *  - `id` is an URI that identifies the required document inside this\n     *    environment; it can contain a path, an optional query and an optional \n     *    frarment.\n     *  - `source` is the new value to be assigned to the document source\n     */\n    async writeDocument (id, source) {\n        const path = sliceBefore(id, '?');\n        return await this.store.set(path, source);\n    }\n    \n    \n    /**\n     *  environment.deleteDocument - async function\n     *  --------------------------------------------------------------------\n     *  Erases the document mapped to the given uri in this environment.\n     *\n     *  ```js\n     *  await environment.deleteDocument(id)\n     *  ```\n     *  \n     *  - `id` is an URI that identifies the required document inside this\n     *    environment; it can contain a path, an optional query and an optional \n     *    frarment.\n     */\n    async deleteDocument (id) {\n        const path = sliceBefore(id, '?');\n        return await this.store.delete(path);\n    }    \n    \n    \n    /**\n     *  environment.render - async function\n     *  --------------------------------------------------------------------\n     *  This is just a stortcut to the `document.render` function.\n     */\n    render (value) {\n        return document.render(value);\n    }    \n}\n\n\nmodule.exports = Environment;\n\n\n// -----------------------------------------------------------------------------\n//  SUPPORT FUNCTIONS\n// -----------------------------------------------------------------------------\n\nconst isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);\nconst extend = (parent, child) => Object.assign(Object.create(parent), child);\nconst getProp = (obj, key) => isObject(obj) ? obj[key] || null : null;\nconst getItem = (array, i) => i < 0 ? array[array.length+i] : array[i];\nconst sliceBefore = (str, separator) => str.split(separator)[0];\nconst sliceAfter = (str, separator) => str.split(separator)[1] || \"\";\nconst isDir = path => path.slice(-1) === '/';\n\n// Given a list of argument ['par1=val1', 'par2=val2', 'par3=val3', ...], \n// converts it to an object ontaining the ke-value pair contained in the list\nfunction parseParameters (...keyValuePairs) {\n    const argns = {};\n    for (let keyValuePair of keyValuePairs) {\n        const separatorIndex = keyValuePair.indexOf(\"=\");\n        if (separatorIndex === -1) {\n            let name = keyValuePair.trim();\n            if (document.expression.isValidName(name)) argns[name] = null;\n        } else {\n            let name = keyValuePair.slice(0, separatorIndex).trim();\n            if (document.expression.isValidName(name)) {\n                let string = keyValuePair.slice(separatorIndex+1).trim();\n                let number = Number(string);\n                argns[name] = isNaN(number) ? string : number;\n            }\n        }\n    }\n    return argns;\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/environment.js?");

/***/ }),

/***/ "../../lib/expression.js":
/*!**********************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/expression.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  olojs.expression\n *  ============================================================================\n *  This module contains function for parsing and evaluation swan expressions.\n *  \n *  Example:\n *  ```js\n *  evaluate = olojs.expression.parse( \"3 * x\" );\n *  context = olojs.expression.createContext({x:10});\n *  value = await evaluate(context);                        // 30\n *  ```\n */\n\nconst extend = (parent, child) => Object.assign(Object.create(parent), child);\n\n\n// -----------------------------------------------------------------------------\n//  TYPES\n// -----------------------------------------------------------------------------\n\nconst $type = Symbol(\"Type tag\");\n\nconst types = {};\n\ntypes.Anything = {name:\"Anything\"};\n\ntypes.Tuple = extend(types.Anything, {name:\"Tuple\"});\n\ntypes.Nothing = extend(types.Anything, {name:\"Nothing\"});\n\ntypes.Boolean = extend(types.Anything, {name:\"Boolean\"});\n\ntypes.Number = extend(types.Anything, {name:\"Number\"});\n\ntypes.Sequence = extend(types.Anything, {name:\"Sequence\"});\n\ntypes.String = extend(types.Sequence, {name:\"String\"});\n\ntypes.List = extend(types.Sequence, {name:\"List\"});\n\ntypes.Namespace = extend(types.Anything, {name:\"Namespace\"});\n\ntypes.Function = extend(types.Anything, {name:\"Function\"});\n\n// Define a binary operation on several types\nfunction defineBinaryOperation (opName, handlers) {\n    for (let [xTypeName, yTypeName, handler] of handlers) {\n        let xType = types[xTypeName];\n        let yType = types[yTypeName];\n        xType[`op_${opName}_${yTypeName}`] = handler;\n    }\n    \n    return function (x, y) {\n        const xType = detectType(x); \n        const yType = detectType(y);\n        const handler = xType[`op_${opName}_${yType.name}`] || xType[`op_${opName}_Anything`];\n        if (handler) return handler.call(this, x, y);\n        return raise(`${opName} operation not defined between ${xType.name} and ${yType.name}`);\n    }\n}\n\n// Define a function on several types\nfunction defineFunction (fname, handlers) {\n    const hkey = `fn_${fname}`;\n    for (let [typeName, handler] of handlers) {\n        let type = types[typeName];\n        type[hkey] = handler;\n    }\n    \n    return function (x) {\n        const xType = detectType(x); \n        const handler = xType[hkey];\n        if (handler) return handler.call(this, x);\n        return raise(`${fname} not defined for ${xType.name} type`);\n    }\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  TYPE DETECTION\n// -----------------------------------------------------------------------------\n\nfunction detectType (value) {\n    \n    // if Nothing\n    if (isNothing(value)) return types.Nothing;\n\n    // if primitive\n    switch (typeof value) {\n        case \"boolean\"  : return types.Boolean;\n        case \"number\"   : return types.Number;\n        case \"string\"   : return types.String;\n    }    \n    \n    // It must be an object!\n    \n    // If it has a type tag\n    if (value[$type]) return value[$type];\n    \n    // if Function\n    if (typeof value === \"function\") return value[$type] = types.Function;\n    \n    // if List\n    if (Array.isArray(value)) return value[$type] = types.List;\n    \n    // if a primitive object\n    switch (Object.prototype.toString.call(value)) {\n        case '[object Boolean]': return value[$type] = types.Boolean;\n        case '[object Number]' : return value[$type] = types.Number;\n        case '[object String]' : return value[$type] = types.String;\n    }\n    \n    // It is a Namespace without name tag!\n    return value[$type] = types.Namespace;\n}\n\nfunction isNothing (value) {\n    return value === null || value === undefined || Number.isNaN(value);\n}\n\nfunction isTuple (value) {\n    try {\n        return value[$type] === types.Tuple;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction isNamespace (value) {\n    return detectType(value) === types.Namespace;\n}\n\nfunction isValidName (name) {    \n    return /^[a-z_A-Z]+[a-z_A-Z0-9]*$/.test(name);\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  TYPE CONVERSION\n// -----------------------------------------------------------------------------\n\nconst convertToBoolean = defineFunction(\"convertToBoolean\", [\n    [\"Nothing\"  , x => false],\n    [\"Boolean\"  , x => x],\n    [\"Number\"   , x => x != 0],\n    [\"Function\" , x => true],\n    [\"String\"   , x => x.length !== 0],\n    [\"List\"     , x => x.length !== 0],\n    [\"Namespace\", x => countNames(x) !== 0],\n    [\"Tuple\"    , x => any(convertToBoolean, x)]\n]);\n\nconst convertToString = defineFunction(\"convertToString\", [\n    [\"Nothing\"  , x => \"\"],\n    [\"Boolean\"  , x => x ? \"TRUE\" : \"FALSE\"],\n    [\"Number\"   , x => String(x)],\n    [\"Function\" , x => \"[[Function]]\"],\n    [\"String\"   , x => x],\n    [\"List\"     , x => `[[List of ${x.length} items]]`],\n    [\"Namespace\", x => detectType(x.__str__) === types.String ? x.__str__ : `[[Namespace of ${countNames(x)} items]]`],\n    [\"Tuple\"    , x => Array.from(x).map(convertToString).join(\"\")],\n]);\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  TUPLE OPERATIONS\n// -----------------------------------------------------------------------------\n\nfunction *iter (tuple) {\n    if (isNothing(tuple)) return;\n    if (!isTuple(tuple)) yield tuple;\n    else for (let item of tuple) yield(item);\n}\n\nfunction *iterSequence (seq) {\n    for (let i=0; i<seq.length; i++) yield {index:i, value:seq[i]};\n}\n\nfunction *iterNamespace (ns) {\n    const names = Object.getOwnPropertyNames(ns).sort();\n    for (let name of names) yield {name:name, value:ns[name]};\n}\n\nfunction createTuple (...items) {\n    const tuple = {\n        \n        [$type]: types.Tuple,\n        \n        *[Symbol.iterator] () {\n            for (let item of items) {\n                for (let subItem of iter(item)) yield subItem;\n            }            \n        }        \n    };\n\n    let iterator = tuple[Symbol.iterator]();\n    \n    let first = iterator.next();\n    if (first.done) return null;\n    return iterator.next().done ? first.value : tuple;\n}\n\nconst NOTHING = createTuple();\n\nconst createRange = defineFunction(\"Range\", [\n    [\"Number\", (n) => {\n        n = Math.trunc(n);\n        var range = NOTHING;\n        if (n > 0) for (let i=0; i<n; i++) {\n            range = createTuple(range, i);\n        } else if (n < 0) for (let i=0; i>n; i--) {\n            range = createTuple(range, i);\n        }\n        return range;\n    }]\n]);\n\nconst enumerate = defineFunction(\"Enumeration\", [\n    [\"String\",    x => createTuple(...iterSequence(x))],\n    [\"List\",      x => createTuple(...iterSequence(x))],\n    [\"Namespace\", x => createTuple(...iterNamespace(x))]\n]);\n\nasync function map (fn, tuple) {\n    if (isNothing(tuple)) return NOTHING;\n    if (!isTuple(tuple)) return await fn(tuple);\n    \n    var image = NOTHING;\n    for (let item of tuple) {\n        image = createTuple(image, await fn(item));\n    }\n    return image;\n}\n\nfunction *pair (x, y) {\n    const iX = iter(x)[Symbol.iterator]();\n    const iY = iter(y)[Symbol.iterator]();\n    while (true) {\n        let x = iX.next();\n        let y = iY.next();\n        if (x.done && y.done) break;\n        yield {first:x.value, second:y.value};\n    }    \n}\n\nfunction mapPairs (fn, x, y) {\n    const ptuple = createTuple(...pair(x, y));\n    return map(pair => fn(pair.first, pair.second), ptuple);\n}\n\nasync function any (fn, tuple) {\n    for (let item of iter(tuple)) {\n        if (await fn(item)) return true;\n    }\n    return false;\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  ARITHMETIC OPERATIONS\n// -----------------------------------------------------------------------------\n\nconst add = defineBinaryOperation(\"Sum\", [\n    [\"Anything\" , \"Nothing\"  , (self, other) => self],    \n    [\"Anything\" , \"Tuple\"    , (self, other) => mapPairs(add, self, other)],\n    [\"Nothing\"  , \"Anything\" , (self, other) => other],\n    [\"Boolean\"  , \"Boolean\"  , (self, other) => self || other],\n    [\"Number\"   , \"Number\"   , (self, other) => self + other],\n    [\"String\"   , \"String\"   , (self, other) => self + other],\n    [\"List\"     , \"List\"     , (self, other) => self.concat(other)],\n    [\"Namespace\", \"Namespace\", (self, other) => Object.assign({}, self, other)],\n    [\"Tuple\"    , \"Anything\" , (self, other) => mapPairs(add, self, other)],\n]);\n\nconst sub = defineBinaryOperation(\"Subtraction\", [\n    [\"Anything\", \"Tuple\"   , (self, other) => mapPairs(sub, self, other)],\n    [\"Nothing\" , \"Anything\", (self, other) => NOTHING],\n    [\"Anything\", \"Nothing\" , (self, other) => self],\n    [\"Number\"  , \"Number\"  , (self, other) => self - other],\n    [\"Tuple\"   , \"Anything\", (self, other) => mapPairs(sub, self, other)],\n]);\n\nconst mul = defineBinaryOperation(\"Product\", [\n    [\"Nothing\" , \"Anything\", (self, other) => NOTHING],\n    [\"Anything\", \"Nothing\" , (self, other) => NOTHING],\n    [\"Anything\", \"Tuple\"   , (self, other) => mapPairs(mul, self, other)],\n    [\"Boolean\" , \"Boolean\" , (self, other) => self && other],\n    [\"Number\"  , \"Number\"  , (self, other) => self * other],\n    [\"Number\"  , \"String\"  , (self, other) => self < 0 ? \"\" : other.repeat(self)],\n    [\"Number\"  , \"List\"    , (self, other) => multiplyList(other, self)],\n    [\"String\"  , \"Number\"  , (self, other) => other < 0 ? \"\" : self.repeat(other)],\n    [\"List\"    , \"Number\"  , (self, other) => multiplyList(self, other)],\n    [\"Tuple\"   , \"Anything\", (self, other) => mapPairs(mul, self, other)],\n]);\n\nfunction multiplyList (list, n) {\n    var product = [];\n    for (let i=1; i<=n; i++) product = product.concat(list);\n    return product;    \n}\n\nconst div = defineBinaryOperation(\"Division\", [\n    [\"Anything\", \"Tuple\"   , (self, other) => mapPairs(div, self, other)],\n    [\"Nothing\" , \"Anything\", (self, other) => NOTHING],\n    [\"Number\"  , \"Number\"  , (self, other) => self / other],\n    [\"Tuple\"   , \"Anything\", (self, other) => mapPairs(div, self, other)],\n]);\n\nconst mod = defineBinaryOperation(\"Modulo\", [\n    [\"Anything\", \"Tuple\"   , (self, other) => mapPairs(mod, self, other)],\n    [\"Nothing\" , \"Anything\", (self, other) => other],\n    [\"Number\"  , \"Number\"  , (self, other) => self % other],\n    [\"Tuple\"   , \"Anything\", (self, other) => mapPairs(mod, self, other)],\n]);\n\nconst pow = defineBinaryOperation(\"Exponentiation\", [\n    [\"Anything\", \"Tuple\"   , (self, other) => mapPairs(pow, self, other)],\n    [\"Nothing\" , \"Anything\", (self, other) => NOTHING],\n    [\"Number\"  , \"Number\"  , (self, other) => self ** other],\n    [\"Tuple\"   , \"Anything\", (self, other) => mapPairs(pow, self, other)],\n]);\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  COMPARISON OPERATIONS\n// -----------------------------------------------------------------------------\n\nconst compare = defineBinaryOperation(\"Comparison\", [\n    [\"Nothing\"  , \"Nothing\"  , (self, other) => 0],\n    [\"Nothing\"  , \"Anything\" , (self, other) => -1],\n    [\"Anything\" , \"Nothing\"  , (self, other) => +1],\n    \n    [\"Boolean\"  , \"Boolean\"  , (self, other) => self === other ? 0 : (self ? +1 : -1)],\n    [\"Number\"   , \"Number\"   , (self, other) => self === other ? 0 : (self<other ? -1 : +1)],\n    [\"String\"   , \"String\"   , (self, other) => self.localeCompare(other)],\n    [\"List\"     , \"List\"     , (self, other) => lexCompare(createTuple(...self), createTuple(...other))],\n    \n    [\"Anything\" , \"Tuple\"    , (self, other) => lexCompare(self, other)],\n    [\"Tuple\"    , \"Anything\" , (self, other) => lexCompare(self, other)],\n    [\"Tuple\"    , \"Tuple\"    , (self, other) => lexCompare(self, other)]    \n]);\n\nfunction lexCompare (tuple1, tuple2) {\n    for (let p of pair(tuple1, tuple2)) {\n        let cmp = compare(p.first, p.second);\n        if (cmp !== 0) return cmp;\n    }\n    return 0;\n}\n\nconst isEqual = defineBinaryOperation(\"Equality\", [\n    [\"Anything\" , \"Anything\" , (self, other) => false],    \n    [\"Nothing\"  , \"Nothing\"  , (self, other) => true],\n    [\"Boolean\"  , \"Boolean\"  , (self, other) => self === other],\n    [\"Number\"   , \"Number\"   , (self, other) => self === other],\n    [\"String\"   , \"String\"   , (self, other) => self === other],\n    [\"Function\" , \"Function\" , (self, other) => self === other],\n    [\"List\"     , \"List\"     , (self, other) => isLexEqual(createTuple(...self), createTuple(...other))],\n    [\"Namespace\", \"Namespace\", (self, other) => {\n        let xNames = Object.getOwnPropertyNames(self).filter(isValidName);\n        let yNames = Object.getOwnPropertyNames(other).filter(isValidName);\n        if (xNames.length !== yNames.length) return false;\n        for (let xName of xNames) {\n            let xValue = self[xName];\n            let yValue = other.hasOwnProperty(xName) ? other[xName] : NOTHING;\n            if (!isEqual(xValue, yValue)) return false;\n        }\n        return true;        \n    }],\n    [\"Anything\" , \"Tuple\"    , (self, other) => isLexEqual(self, other)],\n    [\"Tuple\"    , \"Anything\" , (self, other) => isLexEqual(self, other)],\n    [\"Tuple\"    , \"Tuple\"    , (self, other) => isLexEqual(self, other)]\n]);\n\nfunction isLexEqual (tuple1, tuple2) {\n    for (let p of pair(tuple1, tuple2)) {\n        if (!isEqual(p.first, p.second)) return false;\n    }\n    return true;    \n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  MISCELLANEOUS OPERATION\n// -----------------------------------------------------------------------------\n\nconst apply = defineBinaryOperation(\"Apply\", [\n    [\"Nothing\"  , \"Anything\", (self, other) => NOTHING],\n    [\"String\"   , \"Number\"  , (self, index) => getListItem(self, index) || \"\"],\n    [\"String\"   , \"Anything\", (self, other) => \"\"],\n    [\"List\"     , \"Number\"  , (self, index) => getListItem(self, index) || NOTHING],\n    [\"List\"     , \"Anything\", (self, other) => NOTHING],\n    [\"Namespace\", \"String\"  , function (self, name) {\n        if (typeof self.__apply__ === 'function') {\n            return self.__apply__.call(this, name);\n        }\n        return isValidName(name) && self.hasOwnProperty(name) ? self[name] : NOTHING;\n    }],\n    [\"Namespace\", \"Anything\", function (self, other) {\n        if (typeof self.__apply__ === 'function') {\n            return self.__apply__.call(this, other);\n        }\n        return NOTHING;\n    }],\n    [\"Function\" , \"Anything\", function (self, other) {\n        return self.call(this, ...iter(other));        \n    }],\n    [\"Tuple\"    , \"Anything\", function (self, other) {\n        return map(item => apply.call(this, item, other), self);\n    }],\n]);\n\nfunction getListItem (list, index) {\n    index = index < 0 ? list.length + index : index;\n    return (0 <= index && index < list.length) ? list[Math.trunc(index)] : null;\n}\n\nconst size = defineFunction(\"Size\", [\n    [\"String\", x => x.length],\n    [\"List\", x => x.length],\n    [\"Namespace\", x => countNames(x)]\n]);\n\nfunction countNames (namespace) {\n    return Object.getOwnPropertyNames(namespace).length;\n};\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  EXCEPTIONS\n// -----------------------------------------------------------------------------\n\nclass Exception extends Error {};\n\nfunction raise (message) {\n    throw new Exception(message);\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  PARSER\n// -----------------------------------------------------------------------------\n\nconst Parser = __webpack_require__(/*! ./expression/parser */ \"../../lib/expression/parser.js\");\n\nconst parse = Parser({\n     \n     binaryOperations: {\n         \",\"  : {precedence:10, handler:\"$pair\"  },\n         \":\"  : {precedence:11, handler:\"$label\" },\n         \"=\"  : {precedence:11, handler:\"$set\"   },\n         \"->\" : {precedence:12, handler:\"$def\",  right:true},\n\n         \";\"  : {precedence:21, handler:\"$else\"},\n         \"?\"  : {precedence:22, handler:\"$if\"  },\n         \"|\"  : {precedence:23, handler:\"$or\"  },\n         \"&\"  : {precedence:23, handler:\"$and\" },\n         \"==\" : {precedence:24, handler:\"$eq\"  },\n         \"!=\" : {precedence:24, handler:\"$ne\"  },\n         \"<\"  : {precedence:24, handler:\"$lt\"  },\n         \"<=\" : {precedence:24, handler:\"$le\"  },\n         \">\"  : {precedence:24, handler:\"$gt\"  },\n         \">=\" : {precedence:24, handler:\"$ge\"  },\n         \"+\"  : {precedence:25, handler:\"$add\" },\n         \"-\"  : {precedence:25, handler:\"$sub\" },\n         \"*\"  : {precedence:26, handler:\"$mul\" },    \n         \"/\"  : {precedence:26, handler:\"$div\" },\n         \"%\"  : {precedence:26, handler:\"$mod\" },\n         \"^\"  : {precedence:27, handler:\"$pow\" },\n         \n         \".\"  : {precedence:30, handler:\"$dot\" },\n         \"\"   : {precedence:30, handler:\"$apply\" },\n     },\n     \n     voidHandler        : \"$nothing\",\n     nameHandler        : \"$name\",\n     stringHandler0     : \"$str0\",\n     stringHandler1     : \"$str1\",\n     stringHandler2     : \"$str2\",\n     numberHandler      : \"$numb\",\n     squareGroupHandler : \"$list\",\n     curlyGroupHandler  : \"$namespace\",\n});\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  CONTEXT\n// -----------------------------------------------------------------------------\n\nconst context = {\n    \n    $nothing () {\n        return null;\n    },\n    \n    async $str0 (text) {\n        const parsedExpressions = [];\n        text = text.replace(/\\$\\{([\\s\\S]+?)\\}/g, (match, expressionSource) => {  \n            let i = parsedExpressions.length;\n            parsedExpressions.push( parse(expressionSource) );\n            return \"${\"+i+\"}\";\n        }); \n        \n        const templateContext = Object.create(this);\n        for (let i=0; i<parsedExpressions.length; i++) {\n            let evaluateExpression = parsedExpressions[i];\n            let value = await evaluateExpression(templateContext);                \n            text = text.replace(\"${\"+i+\"}\", await this.str(...iter(value)));\n        }\n\n        return text;\n    },\n    \n    $str1 (value) {\n        return value;\n    },\n    \n    $str2 (value) {\n        return value;\n    },\n    \n    $numb (value) {\n        return value;\n    },\n    \n    async $pair (X, Y) {\n        return createTuple(await X(this), await Y(this));\n    },\n        \n    async $list (X) {\n        const x = await X(this);\n        return Array.from(iter(x));\n    },\n    \n    async $name (name) {\n        if (isValidName(name)) {\n            let value = this[name];\n            if (value !== undefined && value !== Object.prototype[name]) return value;\n        }\n        return null;\n    },\n    \n    async $label (X, Y) {\n        const x = await X({\n            $nothing: this.$nothing,\n            $name: name => name,\n            $pair: this.$pair\n        });\n        const names = Array.from(iter(x));\n        const y = await Y(this);\n        const values = Array.from(iter(y));\n        if (values.length > names.length) {\n            values[names.length-1] = createTuple(...values.slice(names.length-1))\n        }\n        for (var i=0; i<names.length; i++) {\n            this[names[i]] = i < values.length ? values[i] : null;\n        }\n        return y;\n    },\n    \n    async $set (X, Y) {\n        await this.$label(X, Y);\n        return null;\n    },\n\n    async $namespace (X) {\n        const context = Object.create(this);\n        await X(context);\n        return Object.assign({}, context);\n    },\n    \n    $def (params, expression) {\n        return async (...args) => {\n            const functionContext = Object.create(this);\n            await functionContext.$set(params, () => createTuple(...args));\n            return await expression(functionContext);\n        }\n    },\n    \n    async $apply (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return await apply.call(this, x, y);\n    },\n    \n    async $dot (X, Y) {\n        const x = await X(this);\n        const subcontext = async namespace => {\n            if (!isNamespace(namespace)) {\n                raise(\"Namespace expected on the left side of the '.' operator\");\n            }\n            const childNamespace = this.$extend(namespace);\n            return await Y(childNamespace);\n        };\n        return await map(subcontext, x);\n    },\n    \n    async $or (X, Y) {\n        const x = await X(this);\n        if (await this.bool(x)) return x;\n        return await Y(this);\n    },\n    \n    async $and (X, Y) {\n        const x = await X(this);\n        if (await this.not(x)) return x;\n        return await Y(this);\n    },\n    \n    async $if (X, Y) {\n        const x = await X(this);\n        return (await this.bool(x)) ? await Y(this) : null;\n    },\n\n    async $else (X, Y) {\n        const x = await X(this);\n        return isNothing(x) ? await Y(this) : x;\n    },\n    \n    async $add (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return await add(x, y);\n    },\n\n    async $sub (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return await sub(x, y);\n    },\n\n    async $mul (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return await mul(x, y);\n    },\n\n    async $div (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return await div(x, y);\n    },\n\n    async $mod (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return await mod(x, y);\n    },\n\n    async $pow (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return await pow(x, y);\n    },\n\n    async $eq (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return isEqual(x, y);\n    },\n     \n    async $ne (X, Y) {\n        return !(await this.$eq(X, Y));\n    },\n\n    async $lt (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return compare(x, y) === -1;\n    },\n\n    async $ge (X, Y) {\n        return !(await this.$lt(X, Y));\n    },\n\n    async $gt (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return compare(x, y) === +1;\n    },\n\n    async $le (X, Y) {\n        return !(await this.$gt(X, Y));\n    },   \n    \n    async bool (...items) {\n        return convertToBoolean(createTuple(...items));\n    },\n    \n    async not (...items) {\n        return !(await this.bool(...items));\n    },\n    \n    str (...items) {\n        const x = createTuple(...items);        \n        return convertToString(x);\n    },\n    \n    map (fn) {\n        return (...items) => map(fn, createTuple(...items));\n    },\n    \n    size (...items) {\n        const x = createTuple(...items);\n        return size(x);\n    },\n    \n    range (...items) {\n        const x = createTuple(...items);\n        return createRange(x);\n    },    \n    \n    enum (...items) {\n        const x = createTuple(...items);\n        return enumerate(x);\n    },\n    \n    type (...items) {\n        const x = createTuple(...items);\n        return detectType(x).name;\n    },\n    \n    TRUE: true,\n    FALSE: false,\n    \n    $assign (namespace) {\n        for (let name in namespace) {\n            this[name] = namespace[name];\n        }\n        return this;\n    },\n    \n    $extend (namespace) {\n        return Object.create(this).$assign(namespace);\n    }\n};\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  EXPORTS\n// -----------------------------------------------------------------------------\n\n\n/**\n *  olojs.expression.parse - function\n *  ----------------------------------------------------------------------------\n *  Parses a swan expression and returns a function that maps a context to an\n *  expression value.\n *\n *  ```js\n *  evaluate = olojs.expression.parse(expression);\n *  value = await evaluate(context);\n *  ```\n *  \n *  - `espression` is a string containing any valid swan expression\n *  - `context` is a valid swan expression context\n *  - `value` is the value that expression result has in the given context\n */\nexports.parse = (expression) => {\n    const evaluate = parse(expression);\n    return async (expressionContext) => {\n        if (!context.isPrototypeOf(expressionContext)) {\n            throw new Error(\"Invalid context.\")\n        };\n        const value = await evaluate(expressionContext);\n        return isNothing(value) ? null : value;\n    }\n}\n\n\n/**\n *  olojs.expression.createContext - function\n *  ----------------------------------------------------------------------------\n *  Creates a valid expression context.\n *  \n *  ```js\n *  context = olojs.expression.createContext(...namespaces)\n *  ```\n *  \n *  - `namespaces` is a list of objects `ns1, ns2, ns3, ...` that will be merged\n *    to the core swan context \n *  - `context` is an object containing all the core context properties, plus \n *    all the properties of the passed namespace, added in order.\n */\nconst expression_globals = {\n    \"require\": __webpack_require__(/*! ./expression/stdlib-loader */ \"../../lib/expression/stdlib-loader.js\")\n};\nexports.createContext = (...namespaces) => {\n    var ctx = context.$extend(expression_globals);\n    for (let namespace of namespaces) {\n        ctx = ctx.$extend(namespace);\n    }\n    return ctx;\n}\n\n\n// Swan internals exposed to javascript\nexports.stringify = x => context.str(...iter(x));\nexports.apply = (f, ...args) => apply(f, createTuple(...args));\nexports.Exception = Exception;\nexports.isValidName = isValidName;\nexports.createTuple = createTuple;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/expression.js?");

/***/ }),

/***/ "../../lib/expression/lexer.js":
/*!****************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/expression/lexer.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nclass SyntaxError extends Error {\n    \n    constructor (source, pos, message) {\n        super(`${message} at pos ${pos}`);\n    }\n}\n\n\n\n\n\n\nconst matchSpace = char => char && char.match(/^\\s$/);\nconst matchQuote = char => char && char.match(/^[\"'`]$/);\nconst matchIdentifierStart = char => char && char.match(/^[a-z_A-Z]$/);\nconst matchIdentifierPart = char => char && char.match(/^[a-z_A-Z0-9]$/);\nconst matchDecimalDigit = char => char && char.match(/^[0-9]$/);\nconst matchSign = char => char === \"+\" || char === \"-\";\n\nconst SYMBOLS = new Set( ['{', '[', '(', ')', ']', '}', \"=\", \":\", '->', \".\", \",\"] );\nconst matchSymbol = sym => SYMBOLS.has(sym);\n\nconst matchCommentStart = sym => sym === \"#\";\n\nconst binaryOperators = new Set();\n\n\nfunction createLexer (options) {\n    const matchSpace = char => char && char.match(/^\\s$/);\n    const matchQuote = char => char && char.match(/^[\"'`]$/);\n    const matchIdentifierStart = char => char && char.match(/^[a-z_A-Z]$/);\n    const matchIdentifierPart = char => char && char.match(/^[a-z_A-Z0-9]$/);\n    const matchDecimalDigit = char => char && char.match(/^[0-9]$/);\n    const matchSign = char => char === \"+\" || char === \"-\";\n\n    const binaryOperators = new Set(options.binaryOperators);\n    \n    const SYMBOLS = new Set( ['{', '[', '(', ')', ']', '}'].concat(options.binaryOperators.filter(operator => !matchIdentifierStart(operator))) );\n    const matchSymbol = sym => SYMBOLS.has(sym);\n    \n    class Token {\n        \n        constructor (type, value) {\n            this.type = type;\n            this.value = value;\n        }    \n        \n        matchSymbol (sym) {\n            return this.type === Token.SYMBOL && this.value === sym;\n        }\n        \n        matchSign () {\n            return this.matchSymbol(\"+\") || this.matchSymbol(\"-\");\n        }\n        \n        matchIdentifier () {\n            return this.type === Token.IDENTIFIER && !binaryOperators.has(this.value);\n        }\n        \n        matchBinaryOperator () {\n            return (this.type === Token.SYMBOL || this.type === Token.IDENTIFIER) && \n                    binaryOperators.has(this.value);\n        }\n        \n        matchOpenBracket () {\n            return this.matchSymbol('(') || this.matchSymbol('[');\n        }\n        \n        matchNumberLiteral () {\n            return this.type === Token.NUMBER;\n        }\n        \n        matchStringLiteral () {\n            return this.type === Token.STRING;\n        }\n\n        matchLiteral () {\n            return this.type === Token.NUMBER || this.type === Token.STRING;\n        }\n    }\n\n    // Token types\n    Token.SYMBOL = 0;\n    Token.NUMBER = 1;\n    Token.STRING0 = 2;\n    Token.STRING1 = 3;\n    Token.STRING2 = 4;\n    Token.IDENTIFIER = 5;\n    \n    \n    const tokenize = (source) => {\n        const tokens = [];\n        \n        var i = 0, len = source.length;\n        while (true) {\n            while (matchSpace(source[i])) i++;\n            if (i >= len) break;\n\n            // if string literal\n            if (matchQuote(source[i])) {\n                let value = \"\";            \n                let quoteSymbol = source[i]; i++;\n                while (source[i] !== quoteSymbol) {\n                    if (i >= len) throw new SyntaxError(source, i, \"Closing quote expected\");\n                    value += source[i]; i++;\n                }\n                let token = new Token(Token.STRING, value);\n                token.quoteSymbol = quoteSymbol;\n                tokens.push(token); i++;\n            }\n            \n            // if identifier\n            else if (matchIdentifierStart(source[i])) {\n                let value = source[i]; i++;\n                while (matchIdentifierPart(source[i])) {\n                    value += source[i]; i++;\n                }\n                tokens.push( new Token(Token.IDENTIFIER, value) );\n            }\n\n            // if number literal\n            else if (matchDecimalDigit(source[i])) {\n                let numStr = source[i]; i++;\n                \n                while (matchDecimalDigit(source[i])) {\n                    numStr += source[i]; i++;\n                }\n\n                if (source[i] === \".\") {\n                    numStr += source[i]; i++;\n                    while (matchDecimalDigit(source[i])) {\n                        numStr += source[i]; i++;\n                    }        \n                }\n                \n                if (source[i] === 'e' || source[i] === 'E') {\n                    numStr += 'E'; i++;\n                    if (source[i] === '+' || source[i] === '-') { // exponent sign\n                        numStr += source[i]; i++;\n                    }\n                    if (!matchDecimalDigit(source[i])) {\n                        throw new SyntaxError(source, i, `Expected exponent symbol`);                    \n                    }\n                    numStr += source[i]; i++;\n                    while (matchDecimalDigit(source[i])) {\n                        numStr += source[i]; i++;\n                    }        \n                }\n                \n                if (matchIdentifierStart(source[i])) {\n                    throw new SyntaxError(source, i, `Name names cannot start with a number`);\n                } else if (source[i] === \".\") {\n                    throw new SyntaxError(source, i, 'Unexpected period');\n                }\n\n                tokens.push( new Token(Token.NUMBER, Number(numStr)) );\n            }\n            \n            else if (matchCommentStart(source[i])) {\n                i++; while (source[i] !== \"\\n\" && i < len) i++;\n            }\n            \n            else if (matchSymbol( source[i]+source[i+1] )) {\n                tokens.push( new Token(Token.SYMBOL, source[i]+source[i+1])); i+=2;\n            } \n            \n            else if (matchSymbol( source[i] )) {\n                tokens.push( new Token(Token.SYMBOL, source[i])); i++;\n            } \n\n            else {\n                throw new Error(`Unexpected character '${source[i]}' at pos ${i}`);\n            }\n        }\n        \n        return tokens;\n    }\n    \n    return tokenize;\n}\n\n\n\n\n\n\nmodule.exports = createLexer;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/expression/lexer.js?");

/***/ }),

/***/ "../../lib/expression/parser.js":
/*!*****************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/expression/parser.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Lexer = __webpack_require__(/*! ./lexer */ \"../../lib/expression/lexer.js\");\n\nconst GLOBALS = Symbol(\"Globals\");\n\n\nfunction createParser (options) {\n    const binaryOperations = options.binaryOperations || {};\n    const separator = \",\";\n    const tokenize = Lexer({binaryOperators: Object.keys(binaryOperations)});\n    \n    const parse = (source) => {\n        \n        const parseExpression = (done) => {\n            if (done()) {\n                i++; return createOperation(options.voidHandler, []);\n            }\n            \n            var expression = [ parseOperand() ];\n            \n            while (true) {\n                if (done()) {\n                    i++; break;\n                }\n                if (tokens[i].matchBinaryOperator()) {\n                    let operator = binaryOperations[ tokens[i].value ]; i++;\n                    expression.push(operator);\n                    if (done()) throw new Error(\"Operand expected\");\n                    let operand = parseOperand();\n                    expression.push(operand);\n                }\n                else {\n                    let operator = binaryOperations[\"\"];\n                    expression.push(operator);\n                    let operand = parseOperand();\n                    expression.push(operand);\n                }\n            }\n            \n            while (expression.length > 1) {\n                \n                // find higher precedence operand\n                let precedence = 0;\n                let operatorIndex = 0;\n                for (let j=1; j<expression.length; j+=2) {\n                    let operator = expression[j];\n                    if (operator.precedence > precedence) {\n                        if (operator.right) {\n                            let handler = operator.handler;\n                            while (expression[j+2] && expression[j+2].handler === handler) j += 2;\n                        }\n                        precedence = operator.precedence;\n                        operatorIndex = j;\n                    }\n                }\n                \n                // evaluate the higher precedence operation\n                let leftHandOperand = expression[operatorIndex - 1];\n                let operator = expression[operatorIndex];\n                let rightHandOperand = expression[operatorIndex + 1];\n                let operation = createOperation(operator.handler, [leftHandOperand, rightHandOperand]);\n                \n                // replace the [...,left,operator,right,...] items with the operation node\n                expression.splice(operatorIndex-1, 3, operation);\n            }\n            \n            return expression[0];        \n        }\n        \n        const parseOperand = () => {\n            var operand;\n            \n            if (tokens[i].matchSign() && tokens[i+1].matchNumberLiteral()) {\n                let factor = tokens[i].value === \"-\" ? -1 : 1;\n                operand = createOperation(options.numberHandler, [tokens[i+1].value * factor]); i+=2;\n            }\n            \n            else if (tokens[i].matchNumberLiteral()) {\n                operand = createOperation(options.numberHandler, [tokens[i].value]); i++;\n            }\n            \n            else if (tokens[i].matchStringLiteral()) {\n                if (tokens[i].quoteSymbol === \"`\") operand = createOperation(options.stringHandler0, [tokens[i].value]);\n                else if (tokens[i].quoteSymbol === `'`) operand = createOperation(options.stringHandler1, [tokens[i].value]);\n                else if (tokens[i].quoteSymbol === `\"`) operand = createOperation(options.stringHandler2, [tokens[i].value]);\n                i++;\n            }\n            \n            else if (tokens[i].matchIdentifier()) {\n                operand = createOperation(options.nameHandler, [tokens[i].value]); i++;            \n            }\n            \n            else if (tokens[i].matchSymbol('(')) {\n                i++; operand = parseExpression( () => tokens[i].matchSymbol(\")\") );\n            }\n            \n            else if (tokens[i].matchSymbol('[')) {\n                i++;\n                let expression = parseExpression( () => tokens[i].matchSymbol(\"]\") );\n                operand = createOperation(options.squareGroupHandler, [expression]);\n            }\n            \n            else if (tokens[i].matchSymbol('{')) {\n                i++;\n                let expression = parseExpression( () => tokens[i].matchSymbol(\"}\") );\n                operand = createOperation(options.curlyGroupHandler, [expression]);\n            }\n            \n            else {\n                throw new Error('Operand expected.');\n            }\n            \n            return operand;\n        }\n        \n        const tokens = tokenize(source);\n        var i = 0;\n        \n        const evaluate = parseExpression( () => i >= tokens.length );\n\n        return evaluate;\n    }\n    \n    return parse;\n}\n\n\nfunction createOperation (handlerName, operands) {\n    return scope => {\n        if (typeof scope[handlerName] !== \"function\") {\n            throw new Error(`'${handlerName}' handler not defined in this context`);\n        }\n        return scope[handlerName](...operands);\n    }\n}\n\nmodule.exports = createParser;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/expression/parser.js?");

/***/ }),

/***/ "../../lib/expression/stdlib-loader.js":
/*!************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/expression/stdlib-loader.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const modules = {\n    \"math\"     : () => Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(null, /*! ./stdlib/math.js */ \"../../lib/expression/stdlib/math.js\", 7)),\n    \"markdown\" : () => Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(null, /*! ./stdlib/markdown.js */ \"../../lib/expression/stdlib/markdown.js\", 7)),\n    \"path\"     : () => Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(null, /*! ./stdlib/path.js */ \"../../lib/expression/stdlib/path.js\", 7)),\n    \"json\"     : () => Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(null, /*! ./stdlib/json.js */ \"../../lib/expression/stdlib/json.js\", 7)),\n    \"text\"     : () => Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(null, /*! ./stdlib/text.js */ \"../../lib/expression/stdlib/text.js\", 7)),\n    \"list\"     : () => Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(null, /*! ./stdlib/list.js */ \"../../lib/expression/stdlib/list.js\", 7)),\n    \"http\"     : () => Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(null, /*! ./stdlib/http.js */ \"../../lib/expression/stdlib/http.js\", 7)),\n}\n\nmodule.exports = async function (modulePath) {\n    const module = await modules[modulePath]();\n    return module.default;\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/expression/stdlib-loader.js?");

/***/ }),

/***/ "../../lib/expression/stdlib/http.js":
/*!**********************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/expression/stdlib/http.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! isomorphic-fetch */ \"../../node_modules/isomorphic-fetch/fetch-npm-browserify.js\");\n\n\nexports.get = async function (url, options={}) {\n    ensureString(url);\n    options = Object(options);\n    options.method = \"get\";\n    \n    const response = await fetch(url, options);\n    if (!response.ok) throw new Error(response.status);\n    return await response.text();\n}\n\n\nfunction ensureString (string) {\n    if (typeof string !== \"string\") throw new Error(\"String type expected\");\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/expression/stdlib/http.js?");

/***/ }),

/***/ "../../lib/expression/stdlib/json.js":
/*!**********************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/expression/stdlib/json.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nexports.parse = text => JSON.parse(text);\n\nexports.stringify = (object, spaces=0) => JSON.stringify(object, null, spaces);\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/expression/stdlib/json.js?");

/***/ }),

/***/ "../../lib/expression/stdlib/list.js":
/*!**********************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/expression/stdlib/list.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nexports.find = function (list, item) {\n    ensureList(list);\n    return list.indexOf(item);\n}\n\nexports.rfind = function (list, item) {\n    ensureList(list);\n    return list.lastIndexOf(item);\n}\n\nexports.join = function (list, separator=\"\") {\n    ensureList(list);\n    for (let item of list) ensureString(item);\n    ensureString(separator);\n    return list.join(separator);\n}\n\nexports.reverse = function (list) {\n    ensureList(list);\n    const rlist = [];\n    for (let i=list.length-1; i>=0; i--) {\n        rlist.push(list[i]);\n    }\n    return rlist;\n}\n\nexports.slice = function (list, startIndex, endIndex) {\n    ensureList(list);\n    ensureNumber(startIndex);\n    if (endIndex !== undefined) ensureNumber(endIndex);\n    return list.slice(startIndex, endIndex);\n}\n\n\nfunction ensureList (list) {\n    if (!Array.isArray(list)) throw new Error(\"List type expected\");\n}\n\nfunction ensureString (string) {\n    if (typeof string !== \"string\") throw new Error(\"String type expected\");\n}\n\nfunction ensureNumber (number) {\n    if (Number.isNaN(number)) throw new Error(\"Number type expected\");\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/expression/stdlib/list.js?");

/***/ }),

/***/ "../../lib/expression/stdlib/markdown.js":
/*!**************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/expression/stdlib/markdown.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const marked = __webpack_require__(/*! marked */ \"../../node_modules/marked/src/marked.js\");\n\nexports.__apply__ = text => marked(text);\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/expression/stdlib/markdown.js?");

/***/ }),

/***/ "../../lib/expression/stdlib/math.js":
/*!**********************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/expression/stdlib/math.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nmodule.exports = {\n\n    // E\n    // Euler's constant and the base of natural logarithms, approximately 2.718.\n    E: Math.E,\n\n    // PI\n    // Ratio of the a circle's circumference to its diameter, approximately 3.14159.\n    PI: Math.PI,\n\n    // abs(x)\n    // Returns the absolute value of a number.\n    abs: Math.abs,\n\n    // acos(x)\n    // Returns the arccosine of a number.\n    acos: Math.acos,\n\n    // acosh(x)\n    // Returns the hyperbolic arccosine of a number.\n    acosh: Math.acosh,\n\n    // asin(x)\n    // Returns the arcsine of a number.\n    asin: Math.asin,\n\n    // asinh(x)\n    // Returns the hyperbolic arcsine of a number.\n    asinh: Math.asinh,\n\n    // atan(x)\n    // Returns the arctangent of a number.\n    atan: Math.atan,\n\n    // atanh(x)\n    // Returns the hyperbolic arctangent of a number.\n    atanh: Math.atanh,\n\n    // ceil(x)\n    // Returns the smallest integer greater than or equal to a number.\n    ceil: Math.ceil,\n\n    // cos(x)\n    // Returns the cosine of a number.\n    cos: Math.cos,\n\n    // cosh(x)\n    // Returns the hyperbolic cosine of a number.\n    cosh: Math.cosh,\n\n    // exp(x)\n    // Returns Ex, where x is the argument, and E is Euler's constant (2.718…, the base of the natural logarithm).\n    exp: Math.exp,\n\n    // floor(x)\n    // Returns the largest integer less than or equal to a number.\n    floor: Math.floor,\n\n    // log(x)\n    // Returns the natural logarithm (㏒e, also, ㏑) of a number.\n    log: Math.log,\n\n    // log10(x)\n    // Returns the base 10 logarithm of a number.\n    log10: Math.log10,\n\n    // max([x[, y[, …]]])\n    // Returns the largest of zero or more numbers.\n    max: Math.max,\n\n    // min([x[, y[, …]]])\n    // Returns the smallest of zero or more numbers.\n    min: Math.min,\n\n    // random()\n    // Returns a pseudo-random number between 0 and 1.\n    random: Math.random,\n\n    // round(x)\n    // Returns the value of a number rounded to the nearest integer.\n    round: Math.round,\n\n    // sin(x)\n    // Returns the sine of a number.\n    sin: Math.sin,\n\n    // sinh(x)\n    // Returns the hyperbolic sine of a number.\n    sinh: Math.sinh,\n\n    // sqrt(x)\n    // Returns the positive square root of a number.\n    sqrt: Math.sqrt,\n\n    // tan(x)\n    // Returns the tangent of a number.\n    tan: Math.tan,\n\n    // tanh(x)\n    // Returns the hyperbolic tangent of a number.\n    tanh: Math.tanh,\n\n    // trunc(x)\n    // Returns the integer part of the number x, removing any fractional digits.\n    trunc: Math.trunc,    \n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/expression/stdlib/math.js?");

/***/ }),

/***/ "../../lib/expression/stdlib/path.js":
/*!**********************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/expression/stdlib/path.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const pathlib = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\n\nmodule.exports = {\n    getBaseName: pathlib.basename,\n    getDirName: pathlib.dirname,\n    getExtName: pathlib.extname,\n    normalize: pathlib.normalize,\n    resolve: (...paths) => pathlib.resolve(\"/\", ...paths)\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/expression/stdlib/path.js?");

/***/ }),

/***/ "../../lib/expression/stdlib/text.js":
/*!**********************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/expression/stdlib/text.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\nexports.find = function (str, subStr) {\n    ensureString(str);\n    ensureString(subStr);\n    return str.indexOf(subStr);\n}\n\nexports.rfind = function (str, subStr) {\n    ensureString(str);\n    ensureString(subStr);\n    return str.lastIndexOf(subStr);\n}\n\nexports.lower = function (str) {\n    ensureString(str);\n    return str.toLowerCase();\n}\n\nexports.upper = function (str) {\n    ensureString(str);    \n    return str.toUpperCase();\n}\n\nexports.char = function (...charCodes) {\n    for (let charCode of charCodes) ensureNumber(charCode);\n    return String.fromCharCode(...charCodes);\n}\nexports.code = function (str) {\n    ensureString(str);    \n    return Array.from(str).map(c => c.charCodeAt(0));\n}\n\nexports.slice = function (str, firstIndex, lastIndex) {\n    ensureString(str);\n    ensureNumber(firstIndex);\n    if (lastIndex !== undefined) ensureNumber(lastIndex);\n    return str.slice(firstIndex, lastIndex);\n}\n\nexports.split = function (str, divider) {\n    ensureString(str);\n    ensureString(divider);\n    return str.split(divider);\n}\n\nexports.replace = (str, subStr, newSubStr) => {\n    ensureString(str);\n    ensureString(subStr);\n    ensureString(newSubStr);\n    while (str.indexOf(subStr) !== -1) {\n        str = str.replace(subStr, newSubStr);\n    }\n    return str;\n}\n\n\n\nfunction ensureString (string) {\n    if (typeof string !== \"string\") throw new Error(\"String type expected\");\n}\n\nfunction ensureNumber (number) {\n    if (Number.isNaN(number)) throw new Error(\"Number type expected\");\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/expression/stdlib/text.js?");

/***/ }),

/***/ "../../lib/stores/empty.js":
/*!************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/stores/empty.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const errors = __webpack_require__(/*! ./store-errors */ \"../../lib/stores/store-errors.js\");\nconst pathlib = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\n\nclass EmptyStore {\n    \n    async get (path) {\n        return \"\";\n    }\n    \n    async set (path, source) {\n        throw new errors.OperationNotAllowed('SET', pathlib.normalize(`/${path}`));\n    }\n    \n    async delete (path, source) {\n        throw new errors.OperationNotAllowed('DELETE', pathlib.normalize(`/${path}`));\n    }\n    \n    static createIndexDocument (children) {\n        return `<% children = ${JSON.stringify(children)} %>`;\n    }\n}\n\n\nmodule.exports = EmptyStore;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/stores/empty.js?");

/***/ }),

/***/ "../../lib/stores/http.js":
/*!***********************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/stores/http.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! isomorphic-fetch */ \"../../node_modules/isomorphic-fetch/fetch-npm-browserify.js\");\nconst pathlib = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\nconst URI = __webpack_require__(/*! uri-js */ \"../../node_modules/uri-js/dist/es5/uri.all.js\");\nconst errors = __webpack_require__(/*! ./store-errors */ \"../../lib/stores/store-errors.js\");\nconst EmptyStore = __webpack_require__(/*! ./empty */ \"../../lib/stores/empty.js\");\n\n\nconst isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);\n\n\n/**\n *  HTTPStore\n *  ============================================================================\n *  This store handles read/write operations on remote olo-documents\n *  via HTTP(S).\n *\n *  ```js\n *  httpStore = new HTTPStore(rootURL, options)\n *  ```\n *  \n *  - `rootURL` is the base URL that will be prepended to the paths passed to\n *    the `get`, `set` and `delete` methods.\n *  - `options.headers` are custom headers that will be added to every HTTP\n *    request.\n *  - `httpStore` is an object that exposes the standard olojs store API: `get`,\n *    `set` and `delete`.\n */\nclass HTTPStore extends EmptyStore {\n    \n    constructor (rootURL, options={}) {\n        super();\n        this.rootURL = URI.normalize(`${rootURL}/`);\n        this.headers = isObject(options.headers) ? options.headers : {};\n    }\n    \n    resolveURL (path) {\n        return this.rootURL + pathlib.normalize(`/${path}`).slice(1);\n    }\n    \n\n    /**\n     *  HTTPStore.prototype.get - async method\n     *  ------------------------------------------------------------------------\n     *  Retrieves a remote olo-document via HTTP GET (HTTPS GET).\n     *  \n     *  ```js\n     *  const source = await httpStore.get(\"/path/to/doc\")\n     *  ```\n     *  \n     *  - On 200 status code, returns the response body as string\n     *  - On 403 status code, throws a PermissionDenied error\n     *  - On 404 status code, return an empty string\n     *  - On 405 status code, throws an OperationNotAllowed error\n     *  - On any other status code, throws a generic error\n     */\n    async get (path) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'get',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'text/*',\n            }),\n        });\n        \n        switch (response.status) {\n            case 200:\n                return await response.text();            \n            case 403:\n                throw new errors.PermissionDenied('GET', url);\n            case 404:\n                return \"\";\n            case 405:\n                throw new errors.OperationNotAllowed('GET', url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }                            \n    }\n    \n    \n    /**\n     *  HTTPStore.prototype.set - async method\n     *  ------------------------------------------------------------------------\n     *  Modifies a remote olo-document via HTTP PUT (HTTPS PUT).\n     *  \n     *  ```js\n     *  await httpStore.set(\"/path/to/doc\", source)\n     *  ```\n     *  \n     *  - On 200 and 201 status code, returns\n     *  - On 403 status code, throws a PermissionDenied error\n     *  - On 405 status code, throws an OperationNotAllowed error\n     *  - On any other status code, throws a generic error\n     */\n    async set (path, source) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'put',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'text/*',\n                'Content-Type': 'text/plain',\n            }),\n            body: String(source)\n        });\n        \n        switch (response.status) {\n            case 200:\n            case 201:\n                break;\n            case 403:\n                throw new errors.PermissionDenied('SET', url);\n            case 405:\n                throw new errors.OperationNotAllowed('SET', url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }                    \n    }    \n    \n    \n    /**\n     *  HTTPStore.prototype.delete - async method\n     *  ------------------------------------------------------------------------\n     *  Modifies a remote olo-document via HTTP DELETE (HTTPS DELETE).\n     *  \n     *  ```js\n     *  await httpStore.delete(\"/path/to/doc\")\n     *  ```\n     *  \n     *  - On 200 status code, returns\n     *  - On 403 status code, throws a PermissionDenied error\n     *  - On 405 status code, throws an OperationNotAllowed error\n     *  - On any other status code, throws a generic error\n     */\n    async delete (path) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'delete',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'text/*',\n                'Content-Type': 'text/plain',\n            })\n        });\n        \n        switch (response.status) {\n            case 200:\n                break;\n            case 403:\n                throw new errors.PermissionDenied('DELETE', url);\n            case 405:\n                throw new errors.OperationNotAllowed('DELETE', url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }        \n    }    \n}\n\n\nmodule.exports = HTTPStore;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/stores/http.js?");

/***/ }),

/***/ "../../lib/stores/memory.js":
/*!*************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/stores/memory.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const pathlib = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\nconst EmptyStore = __webpack_require__(/*! ./empty */ \"../../lib/stores/empty.js\");\n\n\n\n/**\n *  MemoryStore\n *  ============================================================================\n *  This store handles read/write operations on an in-memory map object.\n *\n *  ```js\n *  memStore = new MemoryStore()\n *  ```\n */\nclass MemoryStore extends EmptyStore {\n    \n    constructor () {\n        super();\n        this._content = new Map();\n    }\n    \n    normalizePath (path) {\n        return pathlib.normalize(`/${path}`);\n    }\n    \n    /**\n     *  memStore.get - method\n     *  ----------------------------------------------------------------------------\n     *  Retrieves the in-memory document source mapped to the given path.\n     *\n     *  ```js\n     *  const source = await memStore.get(\"/path/to/doc\");\n     *  ```\n     *  \n     *  - When requesting `path/to/x/../doc`, the content of `/path/to/doc` will\n     *    be returned\n     *  - When requesting an entry that doesn't exist, and empty string will be returned\n     */\n    get (path) {\n        const normPath = this.normalizePath(path);\n        return this._content.get(normPath) || \"\";\n    }\n\n\n    /**\n     *  memStore.set - method\n     *  ----------------------------------------------------------------------------\n     *  Maps a document path to a source, in memory.\n     *\n     *  ```js\n     *  await memStore.set(\"/path/to/doc\", source);\n     *  ```\n     *  \n     *  - If path is `path/to/x/../doc`, the content of `/path/to/doc` will\n     *    be modified with the passed source\n     *  - `source` will be always converted to string\n     */\n    set (path, source) {\n        const normPath = this.normalizePath(path);\n        return this._content.set(normPath, String(source));\n    }\n    \n\n    /**\n     *  memStore.delete - method\n     *  ----------------------------------------------------------------------------\n     *  Erases the doc source mapped in memory to the given path.\n     *\n     *  ```js\n     *  await memStore.delete(\"/path/to/doc\");\n     *  ```\n     *  \n     *  - If path is `path/to/x/../doc`, the entry `/path/to/doc` will be deleted\n     */\n    delete (path) {\n        const normPath = this.normalizePath(path);\n        return this._content.delete(normPath);\n    }\n}\n\nmodule.exports = MemoryStore;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/stores/memory.js?");

/***/ }),

/***/ "../../lib/stores/router.js":
/*!*************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/stores/router.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst pathlib = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\nconst EmptyStore = __webpack_require__(/*! ./empty */ \"../../lib/stores/empty.js\");\n\n/**\n *  RouterStore\n *  ============================================================================\n *  This store is a container for other stores and routes the `get`, `set` and\n *  delete requests to the store matching the path.\n *\n *  ```js\n *  router = new RouterStore({name1:store1, name2:store2, ...})\n *  ```\n *  \n *  - Each `name_i:store_i` parameter is a mount point. All the `get`, `set` and\n *    delete calls to paths like `/name_i/path/to/doc` will be rerouted to\n *    `store_i` after reducing the path to `/path/to/doc`.\n *  - `router` is an object that exposes the standard olojs store API: `get`,\n *    `set` and `delete`.\n */\n\nclass RouterStore extends EmptyStore {\n    \n    constructor (routes) {\n        super();\n        this._routes = new Map();\n        if (isObject(routes)) {\n            for (let name in routes) {\n                this.mount(name, routes[name]);\n            }\n        }\n    }\n    \n    mount (name, store) {\n        if (!isValidName(name)) throw new Error(`Invalid route name: ${name}`);\n        if (!isStore(store)) throw new Error(`Invalid store`);\n        this._routes.set(name, store);\n    }\n    \n    unmount (name) {\n        this._routes.delete(name);\n    }\n    \n\n    /**\n     *  router.get - async method\n     *  ----------------------------------------------------------------------------\n     *  Retrieves an olo-document from the matching sub-store.\n     *\n     *  ```js\n     *  const source = await router.get(\"/name_i/path/to/doc\");\n     *  ```\n     *  \n     *  - When requesting `/store_i/path/to/doc`, the request will be forwarded\n     *    to the store mounted on `/store_i`, with path `/path/to/doc`\n     *  - When no store is mounted on `/store_i`, it returns an empty string\n     *  - When requesting `/`, it returns a document whose namespace contains a \n     *    `children` list of the mounted store names, followed by a `/`.\n     */\n    async get (path) {\n        if (isRootPath(path)) {\n            let children = Array.from(this._routes.keys()).map(name => `/${name}/`);\n            return this.constructor.createIndexDocument(children);\n        }\n        const store = this._routes.get(routeName(path));\n        if (store) {\n            return await store.get(routeSubPath(path));\n        } else {\n            return super.get(routeSubPath(path));\n        }\n    }\n    \n\n    /**\n     *  router.set - async method\n     *  ----------------------------------------------------------------------------\n     *  Modifies an olo-document contained in the matching sub-store.\n     *\n     *  ```js\n     *  await router.set(\"/name_i/path/to/doc\", source);\n     *  ```\n     *  \n     *  - When passing `/store_i/path/to/doc`, the request will be forwarded\n     *    to the store mounted on `/store_i`, with path `/path/to/doc`\n     *  - When no store is mounted on `/store_i`, it throws an `OperationNotAllowed`\n     *    error.\n     *  - When path is the root path `/`, it throws an `OperationNotAllowed`\n     *    error.\n     */\n    async set (path, source) {\n        const store = this._routes.get(routeName(path));\n        if (store) {\n            return await store.set(routeSubPath(path), source);\n        } else {\n            return super.set(path, source);\n        }\n    }\n\n\n    /**\n     *  router.delete - async method\n     *  ----------------------------------------------------------------------------\n     *  Deletes an olo-document contained in the matching sub-store.\n     *\n     *  ```js\n     *  await router.delete(\"/name_i/path/to/doc\");\n     *  ```\n     *  \n     *  - When passing `/store_i/path/to/doc`, the request will be forwarded\n     *    to the store mounted on `/store_i`, with path `/path/to/doc`\n     *  - When no store is mounted on `/store_i`, it throws an `OperationNotAllowed`\n     *    error.\n     *  - When path is the root path `/`, it throws an `OperationNotAllowed`\n     *    error.\n     */\n    async delete (path, source) {\n        const store = this._routes.get(routeName(path));\n        if (store) {\n            return await store.delete(routeSubPath(path));\n        } else {\n            return super.delete(path);\n        }\n    }    \n}\n\n\nmodule.exports = RouterStore;\n\n\n\n// -----------------------------------------------------------------------------\n//  SERVICE FUNCTIONS\n// -----------------------------------------------------------------------------\n\nconst isStore = obj => obj instanceof EmptyStore;\nconst isValidName = name => name.indexOf('/') === -1;\nconst isObject = o => o && typeof o === 'object' && !Array.isArray(o); \nconst normPath = path => pathlib.normalize(`/${path}`).slice(1);\nconst routeName = path => normPath(path).split('/')[0];\nconst routeSubPath = path => normPath(path).slice(routeName(path).length+1);\nconst isRootPath = path => normPath(path) === '';\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/stores/router.js?");

/***/ }),

/***/ "../../lib/stores/store-errors.js":
/*!*******************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/lib/stores/store-errors.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nexports.OperationNotAllowed = class extends Error {\n    \n    constructor (operation, path) {\n        super(`Operation not allowed: ${operation} ${path}`);\n    }\n}\n\n\nexports.PermissionDenied = class extends Error {\n    \n    constructor (operation, path) {\n        super(`Permission denied: ${operation} ${path}`);\n    }\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/lib/stores/store-errors.js?");

/***/ }),

/***/ "../../node_modules/assertion-error/index.js":
/*!******************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/assertion-error/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * assertion-error\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Return a function that will copy properties from\n * one object to another excluding any originally\n * listed. Returned function will create a new `{}`.\n *\n * @param {String} excluded properties ...\n * @return {Function}\n */\n\nfunction exclude () {\n  var excludes = [].slice.call(arguments);\n\n  function excludeProps (res, obj) {\n    Object.keys(obj).forEach(function (key) {\n      if (!~excludes.indexOf(key)) res[key] = obj[key];\n    });\n  }\n\n  return function extendExclude () {\n    var args = [].slice.call(arguments)\n      , i = 0\n      , res = {};\n\n    for (; i < args.length; i++) {\n      excludeProps(res, args[i]);\n    }\n\n    return res;\n  };\n};\n\n/*!\n * Primary Exports\n */\n\nmodule.exports = AssertionError;\n\n/**\n * ### AssertionError\n *\n * An extension of the JavaScript `Error` constructor for\n * assertion and validation scenarios.\n *\n * @param {String} message\n * @param {Object} properties to include (optional)\n * @param {callee} start stack function (optional)\n */\n\nfunction AssertionError (message, _props, ssf) {\n  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')\n    , props = extend(_props || {});\n\n  // default values\n  this.message = message || 'Unspecified AssertionError';\n  this.showDiff = false;\n\n  // copy from properties\n  for (var key in props) {\n    this[key] = props[key];\n  }\n\n  // capture stack trace\n  ssf = ssf || AssertionError;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, ssf);\n  } else {\n    try {\n      throw new Error();\n    } catch(e) {\n      this.stack = e.stack;\n    }\n  }\n}\n\n/*!\n * Inherit from Error.prototype\n */\n\nAssertionError.prototype = Object.create(Error.prototype);\n\n/*!\n * Statically set name\n */\n\nAssertionError.prototype.name = 'AssertionError';\n\n/*!\n * Ensure correct constructor\n */\n\nAssertionError.prototype.constructor = AssertionError;\n\n/**\n * Allow errors to be converted to JSON for static transfer.\n *\n * @param {Boolean} include stack (default: `true`)\n * @return {Object} object that can be `JSON.stringify`\n */\n\nAssertionError.prototype.toJSON = function (stack) {\n  var extend = exclude('constructor', 'toJSON', 'stack')\n    , props = extend({ name: this.name }, this);\n\n  // include stack if exists and not turned off\n  if (false !== stack && this.stack) {\n    props.stack = this.stack;\n  }\n\n  return props;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/assertion-error/index.js?");

/***/ }),

/***/ "../../node_modules/chai/index.js":
/*!*******************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/index.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/chai */ \"../../node_modules/chai/lib/chai.js\");\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/index.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai.js":
/*!**********************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar used = [];\n\n/*!\n * Chai version\n */\n\nexports.version = '4.2.0';\n\n/*!\n * Assertion Error\n */\n\nexports.AssertionError = __webpack_require__(/*! assertion-error */ \"../../node_modules/assertion-error/index.js\");\n\n/*!\n * Utils for plugins (not exported)\n */\n\nvar util = __webpack_require__(/*! ./chai/utils */ \"../../node_modules/chai/lib/chai/utils/index.js\");\n\n/**\n * # .use(function)\n *\n * Provides a way to extend the internals of Chai.\n *\n * @param {Function}\n * @returns {this} for chaining\n * @api public\n */\n\nexports.use = function (fn) {\n  if (!~used.indexOf(fn)) {\n    fn(exports, util);\n    used.push(fn);\n  }\n\n  return exports;\n};\n\n/*!\n * Utility Functions\n */\n\nexports.util = util;\n\n/*!\n * Configuration\n */\n\nvar config = __webpack_require__(/*! ./chai/config */ \"../../node_modules/chai/lib/chai/config.js\");\nexports.config = config;\n\n/*!\n * Primary `Assertion` prototype\n */\n\nvar assertion = __webpack_require__(/*! ./chai/assertion */ \"../../node_modules/chai/lib/chai/assertion.js\");\nexports.use(assertion);\n\n/*!\n * Core Assertions\n */\n\nvar core = __webpack_require__(/*! ./chai/core/assertions */ \"../../node_modules/chai/lib/chai/core/assertions.js\");\nexports.use(core);\n\n/*!\n * Expect interface\n */\n\nvar expect = __webpack_require__(/*! ./chai/interface/expect */ \"../../node_modules/chai/lib/chai/interface/expect.js\");\nexports.use(expect);\n\n/*!\n * Should interface\n */\n\nvar should = __webpack_require__(/*! ./chai/interface/should */ \"../../node_modules/chai/lib/chai/interface/should.js\");\nexports.use(should);\n\n/*!\n * Assert interface\n */\n\nvar assert = __webpack_require__(/*! ./chai/interface/assert */ \"../../node_modules/chai/lib/chai/interface/assert.js\");\nexports.use(assert);\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/assertion.js":
/*!********************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/assertion.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = __webpack_require__(/*! ./config */ \"../../node_modules/chai/lib/chai/config.js\");\n\nmodule.exports = function (_chai, util) {\n  /*!\n   * Module dependencies.\n   */\n\n  var AssertionError = _chai.AssertionError\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  _chai.Assertion = Assertion;\n\n  /*!\n   * Assertion Constructor\n   *\n   * Creates object for chaining.\n   *\n   * `Assertion` objects contain metadata in the form of flags. Three flags can\n   * be assigned during instantiation by passing arguments to this constructor:\n   *\n   * - `object`: This flag contains the target of the assertion. For example, in\n   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will\n   *   contain `numKittens` so that the `equal` assertion can reference it when\n   *   needed.\n   *\n   * - `message`: This flag contains an optional custom error message to be\n   *   prepended to the error message that's generated by the assertion when it\n   *   fails.\n   *\n   * - `ssfi`: This flag stands for \"start stack function indicator\". It\n   *   contains a function reference that serves as the starting point for\n   *   removing frames from the stack trace of the error that's created by the\n   *   assertion when it fails. The goal is to provide a cleaner stack trace to\n   *   end users by removing Chai's internal functions. Note that it only works\n   *   in environments that support `Error.captureStackTrace`, and only when\n   *   `Chai.config.includeStack` hasn't been set to `false`.\n   *\n   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag\n   *   should retain its current value, even as assertions are chained off of\n   *   this object. This is usually set to `true` when creating a new assertion\n   *   from within another assertion. It's also temporarily set to `true` before\n   *   an overwritten assertion gets called by the overwriting assertion.\n   *\n   * @param {Mixed} obj target of the assertion\n   * @param {String} msg (optional) custom error message\n   * @param {Function} ssfi (optional) starting point for removing stack frames\n   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked\n   * @api private\n   */\n\n  function Assertion (obj, msg, ssfi, lockSsfi) {\n    flag(this, 'ssfi', ssfi || Assertion);\n    flag(this, 'lockSsfi', lockSsfi);\n    flag(this, 'object', obj);\n    flag(this, 'message', msg);\n\n    return util.proxify(this);\n  }\n\n  Object.defineProperty(Assertion, 'includeStack', {\n    get: function() {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      return config.includeStack;\n    },\n    set: function(value) {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      config.includeStack = value;\n    }\n  });\n\n  Object.defineProperty(Assertion, 'showDiff', {\n    get: function() {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      return config.showDiff;\n    },\n    set: function(value) {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      config.showDiff = value;\n    }\n  });\n\n  Assertion.addProperty = function (name, fn) {\n    util.addProperty(this.prototype, name, fn);\n  };\n\n  Assertion.addMethod = function (name, fn) {\n    util.addMethod(this.prototype, name, fn);\n  };\n\n  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\n    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  Assertion.overwriteProperty = function (name, fn) {\n    util.overwriteProperty(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteMethod = function (name, fn) {\n    util.overwriteMethod(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  /**\n   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)\n   *\n   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\n   *\n   * @name assert\n   * @param {Philosophical} expression to be tested\n   * @param {String|Function} message or function that returns message to display if expression fails\n   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails\n   * @param {Mixed} expected value (remember to check for negation)\n   * @param {Mixed} actual (optional) will default to `this.obj`\n   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails\n   * @api private\n   */\n\n  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n    var ok = util.test(this, arguments);\n    if (false !== showDiff) showDiff = true;\n    if (undefined === expected && undefined === _actual) showDiff = false;\n    if (true !== config.showDiff) showDiff = false;\n\n    if (!ok) {\n      msg = util.getMessage(this, arguments);\n      var actual = util.getActual(this, arguments);\n      throw new AssertionError(msg, {\n          actual: actual\n        , expected: expected\n        , showDiff: showDiff\n      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));\n    }\n  };\n\n  /*!\n   * ### ._obj\n   *\n   * Quick reference to stored `actual` value for plugin developers.\n   *\n   * @api private\n   */\n\n  Object.defineProperty(Assertion.prototype, '_obj',\n    { get: function () {\n        return flag(this, 'object');\n      }\n    , set: function (val) {\n        flag(this, 'object', val);\n      }\n  });\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/assertion.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/config.js":
/*!*****************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/config.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n\n  /**\n   * ### config.includeStack\n   *\n   * User configurable property, influences whether stack trace\n   * is included in Assertion error message. Default of false\n   * suppresses stack trace in the error message.\n   *\n   *     chai.config.includeStack = true;  // enable stack on error\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  includeStack: false,\n\n  /**\n   * ### config.showDiff\n   *\n   * User configurable property, influences whether or not\n   * the `showDiff` flag should be included in the thrown\n   * AssertionErrors. `false` will always be `false`; `true`\n   * will be true when the assertion has requested a diff\n   * be shown.\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  showDiff: true,\n\n  /**\n   * ### config.truncateThreshold\n   *\n   * User configurable property, sets length threshold for actual and\n   * expected values in assertion errors. If this threshold is exceeded, for\n   * example for large data structures, the value is replaced with something\n   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.\n   *\n   * Set it to zero if you want to disable truncating altogether.\n   *\n   * This is especially userful when doing assertions on arrays: having this\n   * set to a reasonable large value makes the failure messages readily\n   * inspectable.\n   *\n   *     chai.config.truncateThreshold = 0;  // disable truncating\n   *\n   * @param {Number}\n   * @api public\n   */\n\n  truncateThreshold: 40,\n\n  /**\n   * ### config.useProxy\n   *\n   * User configurable property, defines if chai will use a Proxy to throw\n   * an error when a non-existent property is read, which protects users\n   * from typos when using property-based assertions.\n   *\n   * Set it to false if you want to disable this feature.\n   *\n   *     chai.config.useProxy = false;  // disable use of Proxy\n   *\n   * This feature is automatically disabled regardless of this config value\n   * in environments that don't support proxies.\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  useProxy: true,\n\n  /**\n   * ### config.proxyExcludedKeys\n   *\n   * User configurable property, defines which properties should be ignored\n   * instead of throwing an error if they do not exist on the assertion.\n   * This is only applied if the environment Chai is running in supports proxies and\n   * if the `useProxy` configuration setting is enabled.\n   * By default, `then` and `inspect` will not throw an error if they do not exist on the\n   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when\n   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.\n   *\n   *     // By default these keys will not throw an error if they do not exist on the assertion object\n   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];\n   *\n   * @param {Array}\n   * @api public\n   */\n\n  proxyExcludedKeys: ['then', 'catch', 'inspect', 'toJSON']\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/config.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/core/assertions.js":
/*!**************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/core/assertions.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, _) {\n  var Assertion = chai.Assertion\n    , AssertionError = chai.AssertionError\n    , flag = _.flag;\n\n  /**\n   * ### Language Chains\n   *\n   * The following are provided as chainable getters to improve the readability\n   * of your assertions.\n   *\n   * **Chains**\n   *\n   * - to\n   * - be\n   * - been\n   * - is\n   * - that\n   * - which\n   * - and\n   * - has\n   * - have\n   * - with\n   * - at\n   * - of\n   * - same\n   * - but\n   * - does\n   * - still\n   *\n   * @name language chains\n   * @namespace BDD\n   * @api public\n   */\n\n  [ 'to', 'be', 'been', 'is'\n  , 'and', 'has', 'have', 'with'\n  , 'that', 'which', 'at', 'of'\n  , 'same', 'but', 'does', 'still' ].forEach(function (chain) {\n    Assertion.addProperty(chain);\n  });\n\n  /**\n   * ### .not\n   *\n   * Negates all assertions that follow in the chain.\n   *\n   *     expect(function () {}).to.not.throw();\n   *     expect({a: 1}).to.not.have.property('b');\n   *     expect([1, 2]).to.be.an('array').that.does.not.include(3);\n   *\n   * Just because you can negate any assertion with `.not` doesn't mean you\n   * should. With great power comes great responsibility. It's often best to\n   * assert that the one expected output was produced, rather than asserting\n   * that one of countless unexpected outputs wasn't produced. See individual\n   * assertions for specific guidance.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.not.equal(1); // Not recommended\n   *\n   * @name not\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('not', function () {\n    flag(this, 'negate', true);\n  });\n\n  /**\n   * ### .deep\n   *\n   * Causes all `.equal`, `.include`, `.members`, `.keys`, and `.property`\n   * assertions that follow in the chain to use deep equality instead of strict\n   * (`===`) equality. See the `deep-eql` project page for info on the deep\n   * equality algorithm: https://github.com/chaijs/deep-eql.\n   *\n   *     // Target object deeply (but not strictly) equals `{a: 1}`\n   *     expect({a: 1}).to.deep.equal({a: 1});\n   *     expect({a: 1}).to.not.equal({a: 1});\n   *\n   *     // Target array deeply (but not strictly) includes `{a: 1}`\n   *     expect([{a: 1}]).to.deep.include({a: 1});\n   *     expect([{a: 1}]).to.not.include({a: 1});\n   *\n   *     // Target object deeply (but not strictly) includes `x: {a: 1}`\n   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});\n   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});\n   *\n   *     // Target array deeply (but not strictly) has member `{a: 1}`\n   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);\n   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);\n   *\n   *     // Target set deeply (but not strictly) has key `{a: 1}`\n   *     expect(new Set([{a: 1}])).to.have.deep.keys([{a: 1}]);\n   *     expect(new Set([{a: 1}])).to.not.have.keys([{a: 1}]);\n   *\n   *     // Target object deeply (but not strictly) has property `x: {a: 1}`\n   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\n   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});\n   *\n   * @name deep\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('deep', function () {\n    flag(this, 'deep', true);\n  });\n\n  /**\n   * ### .nested\n   *\n   * Enables dot- and bracket-notation in all `.property` and `.include`\n   * assertions that follow in the chain.\n   *\n   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\n   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\n   *\n   * If `.` or `[]` are part of an actual property name, they can be escaped by\n   * adding two backslashes before them.\n   *\n   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n   *     expect({'.a': {'[b]': 'x'}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 'x'});\n   *\n   * `.nested` cannot be combined with `.own`.\n   *\n   * @name nested\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('nested', function () {\n    flag(this, 'nested', true);\n  });\n\n  /**\n   * ### .own\n   *\n   * Causes all `.property` and `.include` assertions that follow in the chain\n   * to ignore inherited properties.\n   *\n   *     Object.prototype.b = 2;\n   *\n   *     expect({a: 1}).to.have.own.property('a');\n   *     expect({a: 1}).to.have.property('b');\n   *     expect({a: 1}).to.not.have.own.property('b');\n   *\n   *     expect({a: 1}).to.own.include({a: 1});\n   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\n   *\n   * `.own` cannot be combined with `.nested`.\n   *\n   * @name own\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('own', function () {\n    flag(this, 'own', true);\n  });\n\n  /**\n   * ### .ordered\n   *\n   * Causes all `.members` assertions that follow in the chain to require that\n   * members be in the same order.\n   *\n   *     expect([1, 2]).to.have.ordered.members([1, 2])\n   *       .but.not.have.ordered.members([2, 1]);\n   *\n   * When `.include` and `.ordered` are combined, the ordering begins at the\n   * start of both arrays.\n   *\n   *     expect([1, 2, 3]).to.include.ordered.members([1, 2])\n   *       .but.not.include.ordered.members([2, 3]);\n   *\n   * @name ordered\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('ordered', function () {\n    flag(this, 'ordered', true);\n  });\n\n  /**\n   * ### .any\n   *\n   * Causes all `.keys` assertions that follow in the chain to only require that\n   * the target have at least one of the given keys. This is the opposite of\n   * `.all`, which requires that the target have all of the given keys.\n   *\n   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\n   *\n   * See the `.keys` doc for guidance on when to use `.any` or `.all`.\n   *\n   * @name any\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('any', function () {\n    flag(this, 'any', true);\n    flag(this, 'all', false);\n  });\n\n  /**\n   * ### .all\n   *\n   * Causes all `.keys` assertions that follow in the chain to require that the\n   * target have all of the given keys. This is the opposite of `.any`, which\n   * only requires that the target have at least one of the given keys.\n   *\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n   *\n   * Note that `.all` is used by default when neither `.all` nor `.any` are\n   * added earlier in the chain. However, it's often best to add `.all` anyway\n   * because it improves readability.\n   *\n   * See the `.keys` doc for guidance on when to use `.any` or `.all`.\n   *\n   * @name all\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('all', function () {\n    flag(this, 'all', true);\n    flag(this, 'any', false);\n  });\n\n  /**\n   * ### .a(type[, msg])\n   *\n   * Asserts that the target's type is equal to the given string `type`. Types\n   * are case insensitive. See the `type-detect` project page for info on the\n   * type detection algorithm: https://github.com/chaijs/type-detect.\n   *\n   *     expect('foo').to.be.a('string');\n   *     expect({a: 1}).to.be.an('object');\n   *     expect(null).to.be.a('null');\n   *     expect(undefined).to.be.an('undefined');\n   *     expect(new Error).to.be.an('error');\n   *     expect(Promise.resolve()).to.be.a('promise');\n   *     expect(new Float32Array).to.be.a('float32array');\n   *     expect(Symbol()).to.be.a('symbol');\n   *\n   * `.a` supports objects that have a custom type set via `Symbol.toStringTag`.\n   *\n   *     var myObj = {\n   *       [Symbol.toStringTag]: 'myCustomType'\n   *     };\n   *\n   *     expect(myObj).to.be.a('myCustomType').but.not.an('object');\n   *\n   * It's often best to use `.a` to check a target's type before making more\n   * assertions on the same target. That way, you avoid unexpected behavior from\n   * any assertion that does different things based on the target's type.\n   *\n   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);\n   *     expect([]).to.be.an('array').that.is.empty;\n   *\n   * Add `.not` earlier in the chain to negate `.a`. However, it's often best to\n   * assert that the target is the expected type, rather than asserting that it\n   * isn't one of many unexpected types.\n   *\n   *     expect('foo').to.be.a('string'); // Recommended\n   *     expect('foo').to.not.be.an('array'); // Not recommended\n   *\n   * `.a` accepts an optional `msg` argument which is a custom error message to\n   * show when the assertion fails. The message can also be given as the second\n   * argument to `expect`.\n   *\n   *     expect(1).to.be.a('string', 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.a('string');\n   *\n   * `.a` can also be used as a language chain to improve the readability of\n   * your assertions.\n   *\n   *     expect({b: 2}).to.have.a.property('b');\n   *\n   * The alias `.an` can be used interchangeably with `.a`.\n   *\n   * @name a\n   * @alias an\n   * @param {String} type\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function an (type, msg) {\n    if (msg) flag(this, 'message', msg);\n    type = type.toLowerCase();\n    var obj = flag(this, 'object')\n      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n\n    this.assert(\n        type === _.type(obj).toLowerCase()\n      , 'expected #{this} to be ' + article + type\n      , 'expected #{this} not to be ' + article + type\n    );\n  }\n\n  Assertion.addChainableMethod('an', an);\n  Assertion.addChainableMethod('a', an);\n\n  /**\n   * ### .include(val[, msg])\n   *\n   * When the target is a string, `.include` asserts that the given string `val`\n   * is a substring of the target.\n   *\n   *     expect('foobar').to.include('foo');\n   *\n   * When the target is an array, `.include` asserts that the given `val` is a\n   * member of the target.\n   *\n   *     expect([1, 2, 3]).to.include(2);\n   *\n   * When the target is an object, `.include` asserts that the given object\n   * `val`'s properties are a subset of the target's properties.\n   *\n   *     expect({a: 1, b: 2, c: 3}).to.include({a: 1, b: 2});\n   *\n   * When the target is a Set or WeakSet, `.include` asserts that the given `val` is a\n   * member of the target. SameValueZero equality algorithm is used.\n   *\n   *     expect(new Set([1, 2])).to.include(2);\n   *\n   * When the target is a Map, `.include` asserts that the given `val` is one of\n   * the values of the target. SameValueZero equality algorithm is used.\n   *\n   *     expect(new Map([['a', 1], ['b', 2]])).to.include(2);\n   *\n   * Because `.include` does different things based on the target's type, it's\n   * important to check the target's type before using `.include`. See the `.a`\n   * doc for info on testing a target's type.\n   *\n   *     expect([1, 2, 3]).to.be.an('array').that.includes(2);\n   *\n   * By default, strict (`===`) equality is used to compare array members and\n   * object properties. Add `.deep` earlier in the chain to use deep equality\n   * instead (WeakSet targets are not supported). See the `deep-eql` project\n   * page for info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n   *\n   *     // Target array deeply (but not strictly) includes `{a: 1}`\n   *     expect([{a: 1}]).to.deep.include({a: 1});\n   *     expect([{a: 1}]).to.not.include({a: 1});\n   *\n   *     // Target object deeply (but not strictly) includes `x: {a: 1}`\n   *     expect({x: {a: 1}}).to.deep.include({x: {a: 1}});\n   *     expect({x: {a: 1}}).to.not.include({x: {a: 1}});\n   *\n   * By default, all of the target's properties are searched when working with\n   * objects. This includes properties that are inherited and/or non-enumerable.\n   * Add `.own` earlier in the chain to exclude the target's inherited\n   * properties from the search.\n   *\n   *     Object.prototype.b = 2;\n   *\n   *     expect({a: 1}).to.own.include({a: 1});\n   *     expect({a: 1}).to.include({b: 2}).but.not.own.include({b: 2});\n   *\n   * Note that a target object is always only searched for `val`'s own\n   * enumerable properties.\n   *\n   * `.deep` and `.own` can be combined.\n   *\n   *     expect({a: {b: 2}}).to.deep.own.include({a: {b: 2}});\n   *\n   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when\n   * referencing nested properties.\n   *\n   *     expect({a: {b: ['x', 'y']}}).to.nested.include({'a.b[1]': 'y'});\n   *\n   * If `.` or `[]` are part of an actual property name, they can be escaped by\n   * adding two backslashes before them.\n   *\n   *     expect({'.a': {'[b]': 2}}).to.nested.include({'\\\\.a.\\\\[b\\\\]': 2});\n   *\n   * `.deep` and `.nested` can be combined.\n   *\n   *     expect({a: {b: [{c: 3}]}}).to.deep.nested.include({'a.b[0]': {c: 3}});\n   *\n   * `.own` and `.nested` cannot be combined.\n   *\n   * Add `.not` earlier in the chain to negate `.include`.\n   *\n   *     expect('foobar').to.not.include('taco');\n   *     expect([1, 2, 3]).to.not.include(4);\n   *\n   * However, it's dangerous to negate `.include` when the target is an object.\n   * The problem is that it creates uncertain expectations by asserting that the\n   * target object doesn't have all of `val`'s key/value pairs but may or may\n   * not have some of them. It's often best to identify the exact output that's\n   * expected, and then write an assertion that only accepts that exact output.\n   *\n   * When the target object isn't even expected to have `val`'s keys, it's\n   * often best to assert exactly that.\n   *\n   *     expect({c: 3}).to.not.have.any.keys('a', 'b'); // Recommended\n   *     expect({c: 3}).to.not.include({a: 1, b: 2}); // Not recommended\n   *\n   * When the target object is expected to have `val`'s keys, it's often best to\n   * assert that each of the properties has its expected value, rather than\n   * asserting that each property doesn't have one of many unexpected values.\n   *\n   *     expect({a: 3, b: 4}).to.include({a: 3, b: 4}); // Recommended\n   *     expect({a: 3, b: 4}).to.not.include({a: 1, b: 2}); // Not recommended\n   *\n   * `.include` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect([1, 2, 3]).to.include(4, 'nooo why fail??');\n   *     expect([1, 2, 3], 'nooo why fail??').to.include(4);\n   *\n   * `.include` can also be used as a language chain, causing all `.members` and\n   * `.keys` assertions that follow in the chain to require the target to be a\n   * superset of the expected set, rather than an identical set. Note that\n   * `.members` ignores duplicates in the subset when `.include` is added.\n   *\n   *     // Target object's keys are a superset of ['a', 'b'] but not identical\n   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\n   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\n   *\n   *     // Target array is a superset of [1, 2] but not identical\n   *     expect([1, 2, 3]).to.include.members([1, 2]);\n   *     expect([1, 2, 3]).to.not.have.members([1, 2]);\n   *\n   *     // Duplicates in the subset are ignored\n   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\n   *\n   * Note that adding `.any` earlier in the chain causes the `.keys` assertion\n   * to ignore `.include`.\n   *\n   *     // Both assertions are identical\n   *     expect({a: 1}).to.include.any.keys('a', 'b');\n   *     expect({a: 1}).to.have.any.keys('a', 'b');\n   *\n   * The aliases `.includes`, `.contain`, and `.contains` can be used\n   * interchangeably with `.include`.\n   *\n   * @name include\n   * @alias contain\n   * @alias includes\n   * @alias contains\n   * @param {Mixed} val\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function SameValueZero(a, b) {\n    return (_.isNaN(a) && _.isNaN(b)) || a === b;\n  }\n\n  function includeChainingBehavior () {\n    flag(this, 'contains', true);\n  }\n\n  function include (val, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var obj = flag(this, 'object')\n      , objType = _.type(obj).toLowerCase()\n      , flagMsg = flag(this, 'message')\n      , negate = flag(this, 'negate')\n      , ssfi = flag(this, 'ssfi')\n      , isDeep = flag(this, 'deep')\n      , descriptor = isDeep ? 'deep ' : '';\n\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n    var included = false;\n\n    switch (objType) {\n      case 'string':\n        included = obj.indexOf(val) !== -1;\n        break;\n\n      case 'weakset':\n        if (isDeep) {\n          throw new AssertionError(\n            flagMsg + 'unable to use .deep.include with WeakSet',\n            undefined,\n            ssfi\n          );\n        }\n\n        included = obj.has(val);\n        break;\n\n      case 'map':\n        var isEql = isDeep ? _.eql : SameValueZero;\n        obj.forEach(function (item) {\n          included = included || isEql(item, val);\n        });\n        break;\n\n      case 'set':\n        if (isDeep) {\n          obj.forEach(function (item) {\n            included = included || _.eql(item, val);\n          });\n        } else {\n          included = obj.has(val);\n        }\n        break;\n\n      case 'array':\n        if (isDeep) {\n          included = obj.some(function (item) {\n            return _.eql(item, val);\n          })\n        } else {\n          included = obj.indexOf(val) !== -1;\n        }\n        break;\n\n      default:\n        // This block is for asserting a subset of properties in an object.\n        // `_.expectTypes` isn't used here because `.include` should work with\n        // objects with a custom `@@toStringTag`.\n        if (val !== Object(val)) {\n          throw new AssertionError(\n            flagMsg + 'object tested must be an array, a map, an object,'\n              + ' a set, a string, or a weakset, but ' + objType + ' given',\n            undefined,\n            ssfi\n          );\n        }\n\n        var props = Object.keys(val)\n          , firstErr = null\n          , numErrs = 0;\n\n        props.forEach(function (prop) {\n          var propAssertion = new Assertion(obj);\n          _.transferFlags(this, propAssertion, true);\n          flag(propAssertion, 'lockSsfi', true);\n\n          if (!negate || props.length === 1) {\n            propAssertion.property(prop, val[prop]);\n            return;\n          }\n\n          try {\n            propAssertion.property(prop, val[prop]);\n          } catch (err) {\n            if (!_.checkError.compatibleConstructor(err, AssertionError)) {\n              throw err;\n            }\n            if (firstErr === null) firstErr = err;\n            numErrs++;\n          }\n        }, this);\n\n        // When validating .not.include with multiple properties, we only want\n        // to throw an assertion error if all of the properties are included,\n        // in which case we throw the first property assertion error that we\n        // encountered.\n        if (negate && props.length > 1 && numErrs === props.length) {\n          throw firstErr;\n        }\n        return;\n    }\n\n    // Assert inclusion in collection or substring in a string.\n    this.assert(\n      included\n      , 'expected #{this} to ' + descriptor + 'include ' + _.inspect(val)\n      , 'expected #{this} to not ' + descriptor + 'include ' + _.inspect(val));\n  }\n\n  Assertion.addChainableMethod('include', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contain', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contains', include, includeChainingBehavior);\n  Assertion.addChainableMethod('includes', include, includeChainingBehavior);\n\n  /**\n   * ### .ok\n   *\n   * Asserts that the target is a truthy value (considered `true` in boolean context).\n   * However, it's often best to assert that the target is strictly (`===`) or\n   * deeply equal to its expected value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.be.ok; // Not recommended\n   *\n   *     expect(true).to.be.true; // Recommended\n   *     expect(true).to.be.ok; // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.ok`.\n   *\n   *     expect(0).to.equal(0); // Recommended\n   *     expect(0).to.not.be.ok; // Not recommended\n   *\n   *     expect(false).to.be.false; // Recommended\n   *     expect(false).to.not.be.ok; // Not recommended\n   *\n   *     expect(null).to.be.null; // Recommended\n   *     expect(null).to.not.be.ok; // Not recommended\n   *\n   *     expect(undefined).to.be.undefined; // Recommended\n   *     expect(undefined).to.not.be.ok; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(false, 'nooo why fail??').to.be.ok;\n   *\n   * @name ok\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('ok', function () {\n    this.assert(\n        flag(this, 'object')\n      , 'expected #{this} to be truthy'\n      , 'expected #{this} to be falsy');\n  });\n\n  /**\n   * ### .true\n   *\n   * Asserts that the target is strictly (`===`) equal to `true`.\n   *\n   *     expect(true).to.be.true;\n   *\n   * Add `.not` earlier in the chain to negate `.true`. However, it's often best\n   * to assert that the target is equal to its expected value, rather than not\n   * equal to `true`.\n   *\n   *     expect(false).to.be.false; // Recommended\n   *     expect(false).to.not.be.true; // Not recommended\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.true; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(false, 'nooo why fail??').to.be.true;\n   *\n   * @name true\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('true', function () {\n    this.assert(\n        true === flag(this, 'object')\n      , 'expected #{this} to be true'\n      , 'expected #{this} to be false'\n      , flag(this, 'negate') ? false : true\n    );\n  });\n\n  /**\n   * ### .false\n   *\n   * Asserts that the target is strictly (`===`) equal to `false`.\n   *\n   *     expect(false).to.be.false;\n   *\n   * Add `.not` earlier in the chain to negate `.false`. However, it's often\n   * best to assert that the target is equal to its expected value, rather than\n   * not equal to `false`.\n   *\n   *     expect(true).to.be.true; // Recommended\n   *     expect(true).to.not.be.false; // Not recommended\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.false; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(true, 'nooo why fail??').to.be.false;\n   *\n   * @name false\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('false', function () {\n    this.assert(\n        false === flag(this, 'object')\n      , 'expected #{this} to be false'\n      , 'expected #{this} to be true'\n      , flag(this, 'negate') ? true : false\n    );\n  });\n\n  /**\n   * ### .null\n   *\n   * Asserts that the target is strictly (`===`) equal to `null`.\n   *\n   *     expect(null).to.be.null;\n   *\n   * Add `.not` earlier in the chain to negate `.null`. However, it's often best\n   * to assert that the target is equal to its expected value, rather than not\n   * equal to `null`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.null; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(42, 'nooo why fail??').to.be.null;\n   *\n   * @name null\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('null', function () {\n    this.assert(\n        null === flag(this, 'object')\n      , 'expected #{this} to be null'\n      , 'expected #{this} not to be null'\n    );\n  });\n\n  /**\n   * ### .undefined\n   *\n   * Asserts that the target is strictly (`===`) equal to `undefined`.\n   *\n   *     expect(undefined).to.be.undefined;\n   *\n   * Add `.not` earlier in the chain to negate `.undefined`. However, it's often\n   * best to assert that the target is equal to its expected value, rather than\n   * not equal to `undefined`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.undefined; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(42, 'nooo why fail??').to.be.undefined;\n   *\n   * @name undefined\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('undefined', function () {\n    this.assert(\n        undefined === flag(this, 'object')\n      , 'expected #{this} to be undefined'\n      , 'expected #{this} not to be undefined'\n    );\n  });\n\n  /**\n   * ### .NaN\n   *\n   * Asserts that the target is exactly `NaN`.\n   *\n   *     expect(NaN).to.be.NaN;\n   *\n   * Add `.not` earlier in the chain to negate `.NaN`. However, it's often best\n   * to assert that the target is equal to its expected value, rather than not\n   * equal to `NaN`.\n   *\n   *     expect('foo').to.equal('foo'); // Recommended\n   *     expect('foo').to.not.be.NaN; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(42, 'nooo why fail??').to.be.NaN;\n   *\n   * @name NaN\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('NaN', function () {\n    this.assert(\n        _.isNaN(flag(this, 'object'))\n        , 'expected #{this} to be NaN'\n        , 'expected #{this} not to be NaN'\n    );\n  });\n\n  /**\n   * ### .exist\n   *\n   * Asserts that the target is not strictly (`===`) equal to either `null` or\n   * `undefined`. However, it's often best to assert that the target is equal to\n   * its expected value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.exist; // Not recommended\n   *\n   *     expect(0).to.equal(0); // Recommended\n   *     expect(0).to.exist; // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.exist`.\n   *\n   *     expect(null).to.be.null; // Recommended\n   *     expect(null).to.not.exist; // Not recommended\n   *\n   *     expect(undefined).to.be.undefined; // Recommended\n   *     expect(undefined).to.not.exist; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(null, 'nooo why fail??').to.exist;\n   *\n   * @name exist\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('exist', function () {\n    var val = flag(this, 'object');\n    this.assert(\n        val !== null && val !== undefined\n      , 'expected #{this} to exist'\n      , 'expected #{this} to not exist'\n    );\n  });\n\n  /**\n   * ### .empty\n   *\n   * When the target is a string or array, `.empty` asserts that the target's\n   * `length` property is strictly (`===`) equal to `0`.\n   *\n   *     expect([]).to.be.empty;\n   *     expect('').to.be.empty;\n   *\n   * When the target is a map or set, `.empty` asserts that the target's `size`\n   * property is strictly equal to `0`.\n   *\n   *     expect(new Set()).to.be.empty;\n   *     expect(new Map()).to.be.empty;\n   *\n   * When the target is a non-function object, `.empty` asserts that the target\n   * doesn't have any own enumerable properties. Properties with Symbol-based\n   * keys are excluded from the count.\n   *\n   *     expect({}).to.be.empty;\n   *\n   * Because `.empty` does different things based on the target's type, it's\n   * important to check the target's type before using `.empty`. See the `.a`\n   * doc for info on testing a target's type.\n   *\n   *     expect([]).to.be.an('array').that.is.empty;\n   *\n   * Add `.not` earlier in the chain to negate `.empty`. However, it's often\n   * best to assert that the target contains its expected number of values,\n   * rather than asserting that it's not empty.\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.not.be.empty; // Not recommended\n   *\n   *     expect(new Set([1, 2, 3])).to.have.property('size', 3); // Recommended\n   *     expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended\n   *\n   *     expect(Object.keys({a: 1})).to.have.lengthOf(1); // Recommended\n   *     expect({a: 1}).to.not.be.empty; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect([1, 2, 3], 'nooo why fail??').to.be.empty;\n   *\n   * @name empty\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('empty', function () {\n    var val = flag(this, 'object')\n      , ssfi = flag(this, 'ssfi')\n      , flagMsg = flag(this, 'message')\n      , itemsCount;\n\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n    switch (_.type(val).toLowerCase()) {\n      case 'array':\n      case 'string':\n        itemsCount = val.length;\n        break;\n      case 'map':\n      case 'set':\n        itemsCount = val.size;\n        break;\n      case 'weakmap':\n      case 'weakset':\n        throw new AssertionError(\n          flagMsg + '.empty was passed a weak collection',\n          undefined,\n          ssfi\n        );\n      case 'function':\n        var msg = flagMsg + '.empty was passed a function ' + _.getName(val);\n        throw new AssertionError(msg.trim(), undefined, ssfi);\n      default:\n        if (val !== Object(val)) {\n          throw new AssertionError(\n            flagMsg + '.empty was passed non-string primitive ' + _.inspect(val),\n            undefined,\n            ssfi\n          );\n        }\n        itemsCount = Object.keys(val).length;\n    }\n\n    this.assert(\n        0 === itemsCount\n      , 'expected #{this} to be empty'\n      , 'expected #{this} not to be empty'\n    );\n  });\n\n  /**\n   * ### .arguments\n   *\n   * Asserts that the target is an `arguments` object.\n   *\n   *     function test () {\n   *       expect(arguments).to.be.arguments;\n   *     }\n   *\n   *     test();\n   *\n   * Add `.not` earlier in the chain to negate `.arguments`. However, it's often\n   * best to assert which type the target is expected to be, rather than\n   * asserting that its not an `arguments` object.\n   *\n   *     expect('foo').to.be.a('string'); // Recommended\n   *     expect('foo').to.not.be.arguments; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect({}, 'nooo why fail??').to.be.arguments;\n   *\n   * The alias `.Arguments` can be used interchangeably with `.arguments`.\n   *\n   * @name arguments\n   * @alias Arguments\n   * @namespace BDD\n   * @api public\n   */\n\n  function checkArguments () {\n    var obj = flag(this, 'object')\n      , type = _.type(obj);\n    this.assert(\n        'Arguments' === type\n      , 'expected #{this} to be arguments but got ' + type\n      , 'expected #{this} to not be arguments'\n    );\n  }\n\n  Assertion.addProperty('arguments', checkArguments);\n  Assertion.addProperty('Arguments', checkArguments);\n\n  /**\n   * ### .equal(val[, msg])\n   *\n   * Asserts that the target is strictly (`===`) equal to the given `val`.\n   *\n   *     expect(1).to.equal(1);\n   *     expect('foo').to.equal('foo');\n   *\n   * Add `.deep` earlier in the chain to use deep equality instead. See the\n   * `deep-eql` project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     // Target object deeply (but not strictly) equals `{a: 1}`\n   *     expect({a: 1}).to.deep.equal({a: 1});\n   *     expect({a: 1}).to.not.equal({a: 1});\n   *\n   *     // Target array deeply (but not strictly) equals `[1, 2]`\n   *     expect([1, 2]).to.deep.equal([1, 2]);\n   *     expect([1, 2]).to.not.equal([1, 2]);\n   *\n   * Add `.not` earlier in the chain to negate `.equal`. However, it's often\n   * best to assert that the target is equal to its expected value, rather than\n   * not equal to one of countless unexpected values.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.equal(2); // Not recommended\n   *\n   * `.equal` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(1).to.equal(2, 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.equal(2);\n   *\n   * The aliases `.equals` and `eq` can be used interchangeably with `.equal`.\n   *\n   * @name equal\n   * @alias equals\n   * @alias eq\n   * @param {Mixed} val\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertEqual (val, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'deep')) {\n      var prevLockSsfi = flag(this, 'lockSsfi');\n      flag(this, 'lockSsfi', true);\n      this.eql(val);\n      flag(this, 'lockSsfi', prevLockSsfi);\n    } else {\n      this.assert(\n          val === obj\n        , 'expected #{this} to equal #{exp}'\n        , 'expected #{this} to not equal #{exp}'\n        , val\n        , this._obj\n        , true\n      );\n    }\n  }\n\n  Assertion.addMethod('equal', assertEqual);\n  Assertion.addMethod('equals', assertEqual);\n  Assertion.addMethod('eq', assertEqual);\n\n  /**\n   * ### .eql(obj[, msg])\n   *\n   * Asserts that the target is deeply equal to the given `obj`. See the\n   * `deep-eql` project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     // Target object is deeply (but not strictly) equal to {a: 1}\n   *     expect({a: 1}).to.eql({a: 1}).but.not.equal({a: 1});\n   *\n   *     // Target array is deeply (but not strictly) equal to [1, 2]\n   *     expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);\n   *\n   * Add `.not` earlier in the chain to negate `.eql`. However, it's often best\n   * to assert that the target is deeply equal to its expected value, rather\n   * than not deeply equal to one of countless unexpected values.\n   *\n   *     expect({a: 1}).to.eql({a: 1}); // Recommended\n   *     expect({a: 1}).to.not.eql({b: 2}); // Not recommended\n   *\n   * `.eql` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect({a: 1}).to.eql({b: 2}, 'nooo why fail??');\n   *     expect({a: 1}, 'nooo why fail??').to.eql({b: 2});\n   *\n   * The alias `.eqls` can be used interchangeably with `.eql`.\n   *\n   * The `.deep.equal` assertion is almost identical to `.eql` but with one\n   * difference: `.deep.equal` causes deep equality comparisons to also be used\n   * for any other assertions that follow in the chain.\n   *\n   * @name eql\n   * @alias eqls\n   * @param {Mixed} obj\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertEql(obj, msg) {\n    if (msg) flag(this, 'message', msg);\n    this.assert(\n        _.eql(obj, flag(this, 'object'))\n      , 'expected #{this} to deeply equal #{exp}'\n      , 'expected #{this} to not deeply equal #{exp}'\n      , obj\n      , this._obj\n      , true\n    );\n  }\n\n  Assertion.addMethod('eql', assertEql);\n  Assertion.addMethod('eqls', assertEql);\n\n  /**\n   * ### .above(n[, msg])\n   *\n   * Asserts that the target is a number or a date greater than the given number or date `n` respectively.\n   * However, it's often best to assert that the target is equal to its expected\n   * value.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.be.above(1); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is greater than the given number `n`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.above(2); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.above`.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(1).to.not.be.above(2); // Not recommended\n   *\n   * `.above` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(1).to.be.above(2, 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.above(2);\n   *\n   * The aliases `.gt` and `.greaterThan` can be used interchangeably with\n   * `.above`.\n   *\n   * @name above\n   * @alias gt\n   * @alias greaterThan\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertAbove (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , nType = _.type(n).toLowerCase()\n      , errorMessage\n      , shouldThrow = true;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\n      errorMessage = msgPrefix + 'the argument to above must be a date';\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the argument to above must be a number';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount > n\n        , 'expected #{this} to have a ' + descriptor + ' above #{exp} but got #{act}'\n        , 'expected #{this} to not have a ' + descriptor + ' above #{exp}'\n        , n\n        , itemsCount\n      );\n    } else {\n      this.assert(\n          obj > n\n        , 'expected #{this} to be above #{exp}'\n        , 'expected #{this} to be at most #{exp}'\n        , n\n      );\n    }\n  }\n\n  Assertion.addMethod('above', assertAbove);\n  Assertion.addMethod('gt', assertAbove);\n  Assertion.addMethod('greaterThan', assertAbove);\n\n  /**\n   * ### .least(n[, msg])\n   *\n   * Asserts that the target is a number or a date greater than or equal to the given\n   * number or date `n` respectively. However, it's often best to assert that the target is equal to\n   * its expected value.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.be.at.least(1); // Not recommended\n   *     expect(2).to.be.at.least(2); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is greater than or equal to the given number `n`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.at.least(2); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.least`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.at.least(2); // Not recommended\n   *\n   * `.least` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(1).to.be.at.least(2, 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.at.least(2);\n   *\n   * The alias `.gte` can be used interchangeably with `.least`.\n   *\n   * @name least\n   * @alias gte\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertLeast (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , nType = _.type(n).toLowerCase()\n      , errorMessage\n      , shouldThrow = true;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\n      errorMessage = msgPrefix + 'the argument to least must be a date';\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the argument to least must be a number';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount >= n\n        , 'expected #{this} to have a ' + descriptor + ' at least #{exp} but got #{act}'\n        , 'expected #{this} to have a ' + descriptor + ' below #{exp}'\n        , n\n        , itemsCount\n      );\n    } else {\n      this.assert(\n          obj >= n\n        , 'expected #{this} to be at least #{exp}'\n        , 'expected #{this} to be below #{exp}'\n        , n\n      );\n    }\n  }\n\n  Assertion.addMethod('least', assertLeast);\n  Assertion.addMethod('gte', assertLeast);\n\n  /**\n   * ### .below(n[, msg])\n   *\n   * Asserts that the target is a number or a date less than the given number or date `n` respectively.\n   * However, it's often best to assert that the target is equal to its expected\n   * value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.be.below(2); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is less than the given number `n`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.below(4); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.length(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.below`.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.not.be.below(1); // Not recommended\n   *\n   * `.below` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(2).to.be.below(1, 'nooo why fail??');\n   *     expect(2, 'nooo why fail??').to.be.below(1);\n   *\n   * The aliases `.lt` and `.lessThan` can be used interchangeably with\n   * `.below`.\n   *\n   * @name below\n   * @alias lt\n   * @alias lessThan\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertBelow (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , nType = _.type(n).toLowerCase()\n      , errorMessage\n      , shouldThrow = true;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\n      errorMessage = msgPrefix + 'the argument to below must be a date';\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the argument to below must be a number';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount < n\n        , 'expected #{this} to have a ' + descriptor + ' below #{exp} but got #{act}'\n        , 'expected #{this} to not have a ' + descriptor + ' below #{exp}'\n        , n\n        , itemsCount\n      );\n    } else {\n      this.assert(\n          obj < n\n        , 'expected #{this} to be below #{exp}'\n        , 'expected #{this} to be at least #{exp}'\n        , n\n      );\n    }\n  }\n\n  Assertion.addMethod('below', assertBelow);\n  Assertion.addMethod('lt', assertBelow);\n  Assertion.addMethod('lessThan', assertBelow);\n\n  /**\n   * ### .most(n[, msg])\n   *\n   * Asserts that the target is a number or a date less than or equal to the given number\n   * or date `n` respectively. However, it's often best to assert that the target is equal to its\n   * expected value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.be.at.most(2); // Not recommended\n   *     expect(1).to.be.at.most(1); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is less than or equal to the given number `n`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.at.most(4); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.most`.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.not.be.at.most(1); // Not recommended\n   *\n   * `.most` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(2).to.be.at.most(1, 'nooo why fail??');\n   *     expect(2, 'nooo why fail??').to.be.at.most(1);\n   *\n   * The alias `.lte` can be used interchangeably with `.most`.\n   *\n   * @name most\n   * @alias lte\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertMost (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , nType = _.type(n).toLowerCase()\n      , errorMessage\n      , shouldThrow = true;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && nType !== 'date')) {\n      errorMessage = msgPrefix + 'the argument to most must be a date';\n    } else if (nType !== 'number' && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the argument to most must be a number';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount <= n\n        , 'expected #{this} to have a ' + descriptor + ' at most #{exp} but got #{act}'\n        , 'expected #{this} to have a ' + descriptor + ' above #{exp}'\n        , n\n        , itemsCount\n      );\n    } else {\n      this.assert(\n          obj <= n\n        , 'expected #{this} to be at most #{exp}'\n        , 'expected #{this} to be above #{exp}'\n        , n\n      );\n    }\n  }\n\n  Assertion.addMethod('most', assertMost);\n  Assertion.addMethod('lte', assertMost);\n\n  /**\n   * ### .within(start, finish[, msg])\n   *\n   * Asserts that the target is a number or a date greater than or equal to the given\n   * number or date `start`, and less than or equal to the given number or date `finish` respectively.\n   * However, it's often best to assert that the target is equal to its expected\n   * value.\n   *\n   *     expect(2).to.equal(2); // Recommended\n   *     expect(2).to.be.within(1, 3); // Not recommended\n   *     expect(2).to.be.within(2, 3); // Not recommended\n   *     expect(2).to.be.within(1, 2); // Not recommended\n   *\n   * Add `.lengthOf` earlier in the chain to assert that the target's `length`\n   * or `size` is greater than or equal to the given number `start`, and less\n   * than or equal to the given number `finish`.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.have.lengthOf.within(2, 4); // Not recommended\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3); // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.within`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.within(2, 4); // Not recommended\n   *\n   * `.within` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect(4).to.be.within(1, 3, 'nooo why fail??');\n   *     expect(4, 'nooo why fail??').to.be.within(1, 3);\n   *\n   * @name within\n   * @param {Number} start lower bound inclusive\n   * @param {Number} finish upper bound inclusive\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addMethod('within', function (start, finish, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , doLength = flag(this, 'doLength')\n      , flagMsg = flag(this, 'message')\n      , msgPrefix = ((flagMsg) ? flagMsg + ': ' : '')\n      , ssfi = flag(this, 'ssfi')\n      , objType = _.type(obj).toLowerCase()\n      , startType = _.type(start).toLowerCase()\n      , finishType = _.type(finish).toLowerCase()\n      , errorMessage\n      , shouldThrow = true\n      , range = (startType === 'date' && finishType === 'date')\n          ? start.toUTCString() + '..' + finish.toUTCString()\n          : start + '..' + finish;\n\n    if (doLength && objType !== 'map' && objType !== 'set') {\n      new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n    }\n\n    if (!doLength && (objType === 'date' && (startType !== 'date' || finishType !== 'date'))) {\n      errorMessage = msgPrefix + 'the arguments to within must be dates';\n    } else if ((startType !== 'number' || finishType !== 'number') && (doLength || objType === 'number')) {\n      errorMessage = msgPrefix + 'the arguments to within must be numbers';\n    } else if (!doLength && (objType !== 'date' && objType !== 'number')) {\n      var printObj = (objType === 'string') ? \"'\" + obj + \"'\" : obj;\n      errorMessage = msgPrefix + 'expected ' + printObj + ' to be a number or a date';\n    } else {\n      shouldThrow = false;\n    }\n\n    if (shouldThrow) {\n      throw new AssertionError(errorMessage, undefined, ssfi);\n    }\n\n    if (doLength) {\n      var descriptor = 'length'\n        , itemsCount;\n      if (objType === 'map' || objType === 'set') {\n        descriptor = 'size';\n        itemsCount = obj.size;\n      } else {\n        itemsCount = obj.length;\n      }\n      this.assert(\n          itemsCount >= start && itemsCount <= finish\n        , 'expected #{this} to have a ' + descriptor + ' within ' + range\n        , 'expected #{this} to not have a ' + descriptor + ' within ' + range\n      );\n    } else {\n      this.assert(\n          obj >= start && obj <= finish\n        , 'expected #{this} to be within ' + range\n        , 'expected #{this} to not be within ' + range\n      );\n    }\n  });\n\n  /**\n   * ### .instanceof(constructor[, msg])\n   *\n   * Asserts that the target is an instance of the given `constructor`.\n   *\n   *     function Cat () { }\n   *\n   *     expect(new Cat()).to.be.an.instanceof(Cat);\n   *     expect([1, 2]).to.be.an.instanceof(Array);\n   *\n   * Add `.not` earlier in the chain to negate `.instanceof`.\n   *\n   *     expect({a: 1}).to.not.be.an.instanceof(Array);\n   *\n   * `.instanceof` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect(1).to.be.an.instanceof(Array, 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.an.instanceof(Array);\n   *\n   * Due to limitations in ES5, `.instanceof` may not always work as expected\n   * when using a transpiler such as Babel or TypeScript. In particular, it may\n   * produce unexpected results when subclassing built-in object such as\n   * `Array`, `Error`, and `Map`. See your transpiler's docs for details:\n   *\n   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\n   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\n   *\n   * The alias `.instanceOf` can be used interchangeably with `.instanceof`.\n   *\n   * @name instanceof\n   * @param {Constructor} constructor\n   * @param {String} msg _optional_\n   * @alias instanceOf\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertInstanceOf (constructor, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var target = flag(this, 'object')\n    var ssfi = flag(this, 'ssfi');\n    var flagMsg = flag(this, 'message');\n\n    try {\n      var isInstanceOf = target instanceof constructor;\n    } catch (err) {\n      if (err instanceof TypeError) {\n        flagMsg = flagMsg ? flagMsg + ': ' : '';\n        throw new AssertionError(\n          flagMsg + 'The instanceof assertion needs a constructor but '\n            + _.type(constructor) + ' was given.',\n          undefined,\n          ssfi\n        );\n      }\n      throw err;\n    }\n\n    var name = _.getName(constructor);\n    if (name === null) {\n      name = 'an unnamed constructor';\n    }\n\n    this.assert(\n        isInstanceOf\n      , 'expected #{this} to be an instance of ' + name\n      , 'expected #{this} to not be an instance of ' + name\n    );\n  };\n\n  Assertion.addMethod('instanceof', assertInstanceOf);\n  Assertion.addMethod('instanceOf', assertInstanceOf);\n\n  /**\n   * ### .property(name[, val[, msg]])\n   *\n   * Asserts that the target has a property with the given key `name`.\n   *\n   *     expect({a: 1}).to.have.property('a');\n   *\n   * When `val` is provided, `.property` also asserts that the property's value\n   * is equal to the given `val`.\n   *\n   *     expect({a: 1}).to.have.property('a', 1);\n   *\n   * By default, strict (`===`) equality is used. Add `.deep` earlier in the\n   * chain to use deep equality instead. See the `deep-eql` project page for\n   * info on the deep equality algorithm: https://github.com/chaijs/deep-eql.\n   *\n   *     // Target object deeply (but not strictly) has property `x: {a: 1}`\n   *     expect({x: {a: 1}}).to.have.deep.property('x', {a: 1});\n   *     expect({x: {a: 1}}).to.not.have.property('x', {a: 1});\n   *\n   * The target's enumerable and non-enumerable properties are always included\n   * in the search. By default, both own and inherited properties are included.\n   * Add `.own` earlier in the chain to exclude inherited properties from the\n   * search.\n   *\n   *     Object.prototype.b = 2;\n   *\n   *     expect({a: 1}).to.have.own.property('a');\n   *     expect({a: 1}).to.have.own.property('a', 1);\n   *     expect({a: 1}).to.have.property('b');\n   *     expect({a: 1}).to.not.have.own.property('b');\n   *\n   * `.deep` and `.own` can be combined.\n   *\n   *     expect({x: {a: 1}}).to.have.deep.own.property('x', {a: 1});\n   *\n   * Add `.nested` earlier in the chain to enable dot- and bracket-notation when\n   * referencing nested properties.\n   *\n   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]');\n   *     expect({a: {b: ['x', 'y']}}).to.have.nested.property('a.b[1]', 'y');\n   *\n   * If `.` or `[]` are part of an actual property name, they can be escaped by\n   * adding two backslashes before them.\n   *\n   *     expect({'.a': {'[b]': 'x'}}).to.have.nested.property('\\\\.a.\\\\[b\\\\]');\n   *\n   * `.deep` and `.nested` can be combined.\n   *\n   *     expect({a: {b: [{c: 3}]}})\n   *       .to.have.deep.nested.property('a.b[0]', {c: 3});\n   *\n   * `.own` and `.nested` cannot be combined.\n   *\n   * Add `.not` earlier in the chain to negate `.property`.\n   *\n   *     expect({a: 1}).to.not.have.property('b');\n   *\n   * However, it's dangerous to negate `.property` when providing `val`. The\n   * problem is that it creates uncertain expectations by asserting that the\n   * target either doesn't have a property with the given key `name`, or that it\n   * does have a property with the given key `name` but its value isn't equal to\n   * the given `val`. It's often best to identify the exact output that's\n   * expected, and then write an assertion that only accepts that exact output.\n   *\n   * When the target isn't expected to have a property with the given key\n   * `name`, it's often best to assert exactly that.\n   *\n   *     expect({b: 2}).to.not.have.property('a'); // Recommended\n   *     expect({b: 2}).to.not.have.property('a', 1); // Not recommended\n   *\n   * When the target is expected to have a property with the given key `name`,\n   * it's often best to assert that the property has its expected value, rather\n   * than asserting that it doesn't have one of many unexpected values.\n   *\n   *     expect({a: 3}).to.have.property('a', 3); // Recommended\n   *     expect({a: 3}).to.not.have.property('a', 1); // Not recommended\n   *\n   * `.property` changes the target of any assertions that follow in the chain\n   * to be the value of the property from the original target object.\n   *\n   *     expect({a: 1}).to.have.property('a').that.is.a('number');\n   *\n   * `.property` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`. When not providing `val`, only use the\n   * second form.\n   *\n   *     // Recommended\n   *     expect({a: 1}).to.have.property('a', 2, 'nooo why fail??');\n   *     expect({a: 1}, 'nooo why fail??').to.have.property('a', 2);\n   *     expect({a: 1}, 'nooo why fail??').to.have.property('b');\n   *\n   *     // Not recommended\n   *     expect({a: 1}).to.have.property('b', undefined, 'nooo why fail??');\n   *\n   * The above assertion isn't the same thing as not providing `val`. Instead,\n   * it's asserting that the target object has a `b` property that's equal to\n   * `undefined`.\n   *\n   * The assertions `.ownProperty` and `.haveOwnProperty` can be used\n   * interchangeably with `.own.property`.\n   *\n   * @name property\n   * @param {String} name\n   * @param {Mixed} val (optional)\n   * @param {String} msg _optional_\n   * @returns value of property for chaining\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertProperty (name, val, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var isNested = flag(this, 'nested')\n      , isOwn = flag(this, 'own')\n      , flagMsg = flag(this, 'message')\n      , obj = flag(this, 'object')\n      , ssfi = flag(this, 'ssfi')\n      , nameType = typeof name;\n\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n    if (isNested) {\n      if (nameType !== 'string') {\n        throw new AssertionError(\n          flagMsg + 'the argument to property must be a string when using nested syntax',\n          undefined,\n          ssfi\n        );\n      }\n    } else {\n      if (nameType !== 'string' && nameType !== 'number' && nameType !== 'symbol') {\n        throw new AssertionError(\n          flagMsg + 'the argument to property must be a string, number, or symbol',\n          undefined,\n          ssfi\n        );\n      }\n    }\n\n    if (isNested && isOwn) {\n      throw new AssertionError(\n        flagMsg + 'The \"nested\" and \"own\" flags cannot be combined.',\n        undefined,\n        ssfi\n      );\n    }\n\n    if (obj === null || obj === undefined) {\n      throw new AssertionError(\n        flagMsg + 'Target cannot be null or undefined.',\n        undefined,\n        ssfi\n      );\n    }\n\n    var isDeep = flag(this, 'deep')\n      , negate = flag(this, 'negate')\n      , pathInfo = isNested ? _.getPathInfo(obj, name) : null\n      , value = isNested ? pathInfo.value : obj[name];\n\n    var descriptor = '';\n    if (isDeep) descriptor += 'deep ';\n    if (isOwn) descriptor += 'own ';\n    if (isNested) descriptor += 'nested ';\n    descriptor += 'property ';\n\n    var hasProperty;\n    if (isOwn) hasProperty = Object.prototype.hasOwnProperty.call(obj, name);\n    else if (isNested) hasProperty = pathInfo.exists;\n    else hasProperty = _.hasProperty(obj, name);\n\n    // When performing a negated assertion for both name and val, merely having\n    // a property with the given name isn't enough to cause the assertion to\n    // fail. It must both have a property with the given name, and the value of\n    // that property must equal the given val. Therefore, skip this assertion in\n    // favor of the next.\n    if (!negate || arguments.length === 1) {\n      this.assert(\n          hasProperty\n        , 'expected #{this} to have ' + descriptor + _.inspect(name)\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name));\n    }\n\n    if (arguments.length > 1) {\n      this.assert(\n          hasProperty && (isDeep ? _.eql(val, value) : val === value)\n        , 'expected #{this} to have ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name) + ' of #{act}'\n        , val\n        , value\n      );\n    }\n\n    flag(this, 'object', value);\n  }\n\n  Assertion.addMethod('property', assertProperty);\n\n  function assertOwnProperty (name, value, msg) {\n    flag(this, 'own', true);\n    assertProperty.apply(this, arguments);\n  }\n\n  Assertion.addMethod('ownProperty', assertOwnProperty);\n  Assertion.addMethod('haveOwnProperty', assertOwnProperty);\n\n  /**\n   * ### .ownPropertyDescriptor(name[, descriptor[, msg]])\n   *\n   * Asserts that the target has its own property descriptor with the given key\n   * `name`. Enumerable and non-enumerable properties are included in the\n   * search.\n   *\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a');\n   *\n   * When `descriptor` is provided, `.ownPropertyDescriptor` also asserts that\n   * the property's descriptor is deeply equal to the given `descriptor`. See\n   * the `deep-eql` project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 1,\n   *     });\n   *\n   * Add `.not` earlier in the chain to negate `.ownPropertyDescriptor`.\n   *\n   *     expect({a: 1}).to.not.have.ownPropertyDescriptor('b');\n   *\n   * However, it's dangerous to negate `.ownPropertyDescriptor` when providing\n   * a `descriptor`. The problem is that it creates uncertain expectations by\n   * asserting that the target either doesn't have a property descriptor with\n   * the given key `name`, or that it does have a property descriptor with the\n   * given key `name` but its not deeply equal to the given `descriptor`. It's\n   * often best to identify the exact output that's expected, and then write an\n   * assertion that only accepts that exact output.\n   *\n   * When the target isn't expected to have a property descriptor with the given\n   * key `name`, it's often best to assert exactly that.\n   *\n   *     // Recommended\n   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a');\n   *\n   *     // Not recommended\n   *     expect({b: 2}).to.not.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 1,\n   *     });\n   *\n   * When the target is expected to have a property descriptor with the given\n   * key `name`, it's often best to assert that the property has its expected\n   * descriptor, rather than asserting that it doesn't have one of many\n   * unexpected descriptors.\n   *\n   *     // Recommended\n   *     expect({a: 3}).to.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 3,\n   *     });\n   *\n   *     // Not recommended\n   *     expect({a: 3}).to.not.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 1,\n   *     });\n   *\n   * `.ownPropertyDescriptor` changes the target of any assertions that follow\n   * in the chain to be the value of the property descriptor from the original\n   * target object.\n   *\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a')\n   *       .that.has.property('enumerable', true);\n   *\n   * `.ownPropertyDescriptor` accepts an optional `msg` argument which is a\n   * custom error message to show when the assertion fails. The message can also\n   * be given as the second argument to `expect`. When not providing\n   * `descriptor`, only use the second form.\n   *\n   *     // Recommended\n   *     expect({a: 1}).to.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 2,\n   *     }, 'nooo why fail??');\n   *\n   *     // Recommended\n   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('a', {\n   *       configurable: true,\n   *       enumerable: true,\n   *       writable: true,\n   *       value: 2,\n   *     });\n   *\n   *     // Recommended\n   *     expect({a: 1}, 'nooo why fail??').to.have.ownPropertyDescriptor('b');\n   *\n   *     // Not recommended\n   *     expect({a: 1})\n   *       .to.have.ownPropertyDescriptor('b', undefined, 'nooo why fail??');\n   *\n   * The above assertion isn't the same thing as not providing `descriptor`.\n   * Instead, it's asserting that the target object has a `b` property\n   * descriptor that's deeply equal to `undefined`.\n   *\n   * The alias `.haveOwnPropertyDescriptor` can be used interchangeably with\n   * `.ownPropertyDescriptor`.\n   *\n   * @name ownPropertyDescriptor\n   * @alias haveOwnPropertyDescriptor\n   * @param {String} name\n   * @param {Object} descriptor _optional_\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertOwnPropertyDescriptor (name, descriptor, msg) {\n    if (typeof descriptor === 'string') {\n      msg = descriptor;\n      descriptor = null;\n    }\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);\n    if (actualDescriptor && descriptor) {\n      this.assert(\n          _.eql(descriptor, actualDescriptor)\n        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)\n        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)\n        , descriptor\n        , actualDescriptor\n        , true\n      );\n    } else {\n      this.assert(\n          actualDescriptor\n        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)\n        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)\n      );\n    }\n    flag(this, 'object', actualDescriptor);\n  }\n\n  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);\n  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);\n\n  /**\n   * ### .lengthOf(n[, msg])\n   *\n   * Asserts that the target's `length` or `size` is equal to the given number\n   * `n`.\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(3);\n   *     expect('foo').to.have.lengthOf(3);\n   *     expect(new Set([1, 2, 3])).to.have.lengthOf(3);\n   *     expect(new Map([['a', 1], ['b', 2], ['c', 3]])).to.have.lengthOf(3);\n   *\n   * Add `.not` earlier in the chain to negate `.lengthOf`. However, it's often\n   * best to assert that the target's `length` property is equal to its expected\n   * value, rather than not equal to one of many unexpected values.\n   *\n   *     expect('foo').to.have.lengthOf(3); // Recommended\n   *     expect('foo').to.not.have.lengthOf(4); // Not recommended\n   *\n   * `.lengthOf` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect([1, 2, 3]).to.have.lengthOf(2, 'nooo why fail??');\n   *     expect([1, 2, 3], 'nooo why fail??').to.have.lengthOf(2);\n   *\n   * `.lengthOf` can also be used as a language chain, causing all `.above`,\n   * `.below`, `.least`, `.most`, and `.within` assertions that follow in the\n   * chain to use the target's `length` property as the target. However, it's\n   * often best to assert that the target's `length` property is equal to its\n   * expected length, rather than asserting that its `length` property falls\n   * within some range of values.\n   *\n   *     // Recommended\n   *     expect([1, 2, 3]).to.have.lengthOf(3);\n   *\n   *     // Not recommended\n   *     expect([1, 2, 3]).to.have.lengthOf.above(2);\n   *     expect([1, 2, 3]).to.have.lengthOf.below(4);\n   *     expect([1, 2, 3]).to.have.lengthOf.at.least(3);\n   *     expect([1, 2, 3]).to.have.lengthOf.at.most(3);\n   *     expect([1, 2, 3]).to.have.lengthOf.within(2,4);\n   *\n   * Due to a compatibility issue, the alias `.length` can't be chained directly\n   * off of an uninvoked method such as `.a`. Therefore, `.length` can't be used\n   * interchangeably with `.lengthOf` in every situation. It's recommended to\n   * always use `.lengthOf` instead of `.length`.\n   *\n   *     expect([1, 2, 3]).to.have.a.length(3); // incompatible; throws error\n   *     expect([1, 2, 3]).to.have.a.lengthOf(3);  // passes as expected\n   *\n   * @name lengthOf\n   * @alias length\n   * @param {Number} n\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertLengthChain () {\n    flag(this, 'doLength', true);\n  }\n\n  function assertLength (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , objType = _.type(obj).toLowerCase()\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi')\n      , descriptor = 'length'\n      , itemsCount;\n\n    switch (objType) {\n      case 'map':\n      case 'set':\n        descriptor = 'size';\n        itemsCount = obj.size;\n        break;\n      default:\n        new Assertion(obj, flagMsg, ssfi, true).to.have.property('length');\n        itemsCount = obj.length;\n    }\n\n    this.assert(\n        itemsCount == n\n      , 'expected #{this} to have a ' + descriptor + ' of #{exp} but got #{act}'\n      , 'expected #{this} to not have a ' + descriptor + ' of #{act}'\n      , n\n      , itemsCount\n    );\n  }\n\n  Assertion.addChainableMethod('length', assertLength, assertLengthChain);\n  Assertion.addChainableMethod('lengthOf', assertLength, assertLengthChain);\n\n  /**\n   * ### .match(re[, msg])\n   *\n   * Asserts that the target matches the given regular expression `re`.\n   *\n   *     expect('foobar').to.match(/^foo/);\n   *\n   * Add `.not` earlier in the chain to negate `.match`.\n   *\n   *     expect('foobar').to.not.match(/taco/);\n   *\n   * `.match` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect('foobar').to.match(/taco/, 'nooo why fail??');\n   *     expect('foobar', 'nooo why fail??').to.match(/taco/);\n   *\n   * The alias `.matches` can be used interchangeably with `.match`.\n   *\n   * @name match\n   * @alias matches\n   * @param {RegExp} re\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n  function assertMatch(re, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        re.exec(obj)\n      , 'expected #{this} to match ' + re\n      , 'expected #{this} not to match ' + re\n    );\n  }\n\n  Assertion.addMethod('match', assertMatch);\n  Assertion.addMethod('matches', assertMatch);\n\n  /**\n   * ### .string(str[, msg])\n   *\n   * Asserts that the target string contains the given substring `str`.\n   *\n   *     expect('foobar').to.have.string('bar');\n   *\n   * Add `.not` earlier in the chain to negate `.string`.\n   *\n   *     expect('foobar').to.not.have.string('taco');\n   *\n   * `.string` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect('foobar').to.have.string('taco', 'nooo why fail??');\n   *     expect('foobar', 'nooo why fail??').to.have.string('taco');\n   *\n   * @name string\n   * @param {String} str\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addMethod('string', function (str, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(obj, flagMsg, ssfi, true).is.a('string');\n\n    this.assert(\n        ~obj.indexOf(str)\n      , 'expected #{this} to contain ' + _.inspect(str)\n      , 'expected #{this} to not contain ' + _.inspect(str)\n    );\n  });\n\n  /**\n   * ### .keys(key1[, key2[, ...]])\n   *\n   * Asserts that the target object, array, map, or set has the given keys. Only\n   * the target's own inherited properties are included in the search.\n   *\n   * When the target is an object or array, keys can be provided as one or more\n   * string arguments, a single array argument, or a single object argument. In\n   * the latter case, only the keys in the given object matter; the values are\n   * ignored.\n   *\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n   *     expect(['x', 'y']).to.have.all.keys(0, 1);\n   *\n   *     expect({a: 1, b: 2}).to.have.all.keys(['a', 'b']);\n   *     expect(['x', 'y']).to.have.all.keys([0, 1]);\n   *\n   *     expect({a: 1, b: 2}).to.have.all.keys({a: 4, b: 5}); // ignore 4 and 5\n   *     expect(['x', 'y']).to.have.all.keys({0: 4, 1: 5}); // ignore 4 and 5\n   *\n   * When the target is a map or set, each key must be provided as a separate\n   * argument.\n   *\n   *     expect(new Map([['a', 1], ['b', 2]])).to.have.all.keys('a', 'b');\n   *     expect(new Set(['a', 'b'])).to.have.all.keys('a', 'b');\n   *\n   * Because `.keys` does different things based on the target's type, it's\n   * important to check the target's type before using `.keys`. See the `.a` doc\n   * for info on testing a target's type.\n   *\n   *     expect({a: 1, b: 2}).to.be.an('object').that.has.all.keys('a', 'b');\n   *\n   * By default, strict (`===`) equality is used to compare keys of maps and\n   * sets. Add `.deep` earlier in the chain to use deep equality instead. See\n   * the `deep-eql` project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     // Target set deeply (but not strictly) has key `{a: 1}`\n   *     expect(new Set([{a: 1}])).to.have.all.deep.keys([{a: 1}]);\n   *     expect(new Set([{a: 1}])).to.not.have.all.keys([{a: 1}]);\n   *\n   * By default, the target must have all of the given keys and no more. Add\n   * `.any` earlier in the chain to only require that the target have at least\n   * one of the given keys. Also, add `.not` earlier in the chain to negate\n   * `.keys`. It's often best to add `.any` when negating `.keys`, and to use\n   * `.all` when asserting `.keys` without negation.\n   *\n   * When negating `.keys`, `.any` is preferred because `.not.any.keys` asserts\n   * exactly what's expected of the output, whereas `.not.all.keys` creates\n   * uncertain expectations.\n   *\n   *     // Recommended; asserts that target doesn't have any of the given keys\n   *     expect({a: 1, b: 2}).to.not.have.any.keys('c', 'd');\n   *\n   *     // Not recommended; asserts that target doesn't have all of the given\n   *     // keys but may or may not have some of them\n   *     expect({a: 1, b: 2}).to.not.have.all.keys('c', 'd');\n   *\n   * When asserting `.keys` without negation, `.all` is preferred because\n   * `.all.keys` asserts exactly what's expected of the output, whereas\n   * `.any.keys` creates uncertain expectations.\n   *\n   *     // Recommended; asserts that target has all the given keys\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b');\n   *\n   *     // Not recommended; asserts that target has at least one of the given\n   *     // keys but may or may not have more of them\n   *     expect({a: 1, b: 2}).to.have.any.keys('a', 'b');\n   *\n   * Note that `.all` is used by default when neither `.all` nor `.any` appear\n   * earlier in the chain. However, it's often best to add `.all` anyway because\n   * it improves readability.\n   *\n   *     // Both assertions are identical\n   *     expect({a: 1, b: 2}).to.have.all.keys('a', 'b'); // Recommended\n   *     expect({a: 1, b: 2}).to.have.keys('a', 'b'); // Not recommended\n   *\n   * Add `.include` earlier in the chain to require that the target's keys be a\n   * superset of the expected keys, rather than identical sets.\n   *\n   *     // Target object's keys are a superset of ['a', 'b'] but not identical\n   *     expect({a: 1, b: 2, c: 3}).to.include.all.keys('a', 'b');\n   *     expect({a: 1, b: 2, c: 3}).to.not.have.all.keys('a', 'b');\n   *\n   * However, if `.any` and `.include` are combined, only the `.any` takes\n   * effect. The `.include` is ignored in this case.\n   *\n   *     // Both assertions are identical\n   *     expect({a: 1}).to.have.any.keys('a', 'b');\n   *     expect({a: 1}).to.include.any.keys('a', 'b');\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect({a: 1}, 'nooo why fail??').to.have.key('b');\n   *\n   * The alias `.key` can be used interchangeably with `.keys`.\n   *\n   * @name keys\n   * @alias key\n   * @param {...String|Array|Object} keys\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertKeys (keys) {\n    var obj = flag(this, 'object')\n      , objType = _.type(obj)\n      , keysType = _.type(keys)\n      , ssfi = flag(this, 'ssfi')\n      , isDeep = flag(this, 'deep')\n      , str\n      , deepStr = ''\n      , actual\n      , ok = true\n      , flagMsg = flag(this, 'message');\n\n    flagMsg = flagMsg ? flagMsg + ': ' : '';\n    var mixedArgsMsg = flagMsg + 'when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments';\n\n    if (objType === 'Map' || objType === 'Set') {\n      deepStr = isDeep ? 'deeply ' : '';\n      actual = [];\n\n      // Map and Set '.keys' aren't supported in IE 11. Therefore, use .forEach.\n      obj.forEach(function (val, key) { actual.push(key) });\n\n      if (keysType !== 'Array') {\n        keys = Array.prototype.slice.call(arguments);\n      }\n    } else {\n      actual = _.getOwnEnumerableProperties(obj);\n\n      switch (keysType) {\n        case 'Array':\n          if (arguments.length > 1) {\n            throw new AssertionError(mixedArgsMsg, undefined, ssfi);\n          }\n          break;\n        case 'Object':\n          if (arguments.length > 1) {\n            throw new AssertionError(mixedArgsMsg, undefined, ssfi);\n          }\n          keys = Object.keys(keys);\n          break;\n        default:\n          keys = Array.prototype.slice.call(arguments);\n      }\n\n      // Only stringify non-Symbols because Symbols would become \"Symbol()\"\n      keys = keys.map(function (val) {\n        return typeof val === 'symbol' ? val : String(val);\n      });\n    }\n\n    if (!keys.length) {\n      throw new AssertionError(flagMsg + 'keys required', undefined, ssfi);\n    }\n\n    var len = keys.length\n      , any = flag(this, 'any')\n      , all = flag(this, 'all')\n      , expected = keys;\n\n    if (!any && !all) {\n      all = true;\n    }\n\n    // Has any\n    if (any) {\n      ok = expected.some(function(expectedKey) {\n        return actual.some(function(actualKey) {\n          if (isDeep) {\n            return _.eql(expectedKey, actualKey);\n          } else {\n            return expectedKey === actualKey;\n          }\n        });\n      });\n    }\n\n    // Has all\n    if (all) {\n      ok = expected.every(function(expectedKey) {\n        return actual.some(function(actualKey) {\n          if (isDeep) {\n            return _.eql(expectedKey, actualKey);\n          } else {\n            return expectedKey === actualKey;\n          }\n        });\n      });\n\n      if (!flag(this, 'contains')) {\n        ok = ok && keys.length == actual.length;\n      }\n    }\n\n    // Key string\n    if (len > 1) {\n      keys = keys.map(function(key) {\n        return _.inspect(key);\n      });\n      var last = keys.pop();\n      if (all) {\n        str = keys.join(', ') + ', and ' + last;\n      }\n      if (any) {\n        str = keys.join(', ') + ', or ' + last;\n      }\n    } else {\n      str = _.inspect(keys[0]);\n    }\n\n    // Form\n    str = (len > 1 ? 'keys ' : 'key ') + str;\n\n    // Have / include\n    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\n\n    // Assertion\n    this.assert(\n        ok\n      , 'expected #{this} to ' + deepStr + str\n      , 'expected #{this} to not ' + deepStr + str\n      , expected.slice(0).sort(_.compareByInspect)\n      , actual.sort(_.compareByInspect)\n      , true\n    );\n  }\n\n  Assertion.addMethod('keys', assertKeys);\n  Assertion.addMethod('key', assertKeys);\n\n  /**\n   * ### .throw([errorLike], [errMsgMatcher], [msg])\n   *\n   * When no arguments are provided, `.throw` invokes the target function and\n   * asserts that an error is thrown.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw();\n   *\n   * When one argument is provided, and it's an error constructor, `.throw`\n   * invokes the target function and asserts that an error is thrown that's an\n   * instance of that error constructor.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw(TypeError);\n   *\n   * When one argument is provided, and it's an error instance, `.throw` invokes\n   * the target function and asserts that an error is thrown that's strictly\n   * (`===`) equal to that error instance.\n   *\n   *     var err = new TypeError('Illegal salmon!');\n   *     var badFn = function () { throw err; };\n   *\n   *     expect(badFn).to.throw(err);\n   *\n   * When one argument is provided, and it's a string, `.throw` invokes the\n   * target function and asserts that an error is thrown with a message that\n   * contains that string.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw('salmon');\n   *\n   * When one argument is provided, and it's a regular expression, `.throw`\n   * invokes the target function and asserts that an error is thrown with a\n   * message that matches that regular expression.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw(/salmon/);\n   *\n   * When two arguments are provided, and the first is an error instance or\n   * constructor, and the second is a string or regular expression, `.throw`\n   * invokes the function and asserts that an error is thrown that fulfills both\n   * conditions as described above.\n   *\n   *     var err = new TypeError('Illegal salmon!');\n   *     var badFn = function () { throw err; };\n   *\n   *     expect(badFn).to.throw(TypeError, 'salmon');\n   *     expect(badFn).to.throw(TypeError, /salmon/);\n   *     expect(badFn).to.throw(err, 'salmon');\n   *     expect(badFn).to.throw(err, /salmon/);\n   *\n   * Add `.not` earlier in the chain to negate `.throw`.\n   *\n   *     var goodFn = function () {};\n   *\n   *     expect(goodFn).to.not.throw();\n   *\n   * However, it's dangerous to negate `.throw` when providing any arguments.\n   * The problem is that it creates uncertain expectations by asserting that the\n   * target either doesn't throw an error, or that it throws an error but of a\n   * different type than the given type, or that it throws an error of the given\n   * type but with a message that doesn't include the given string. It's often\n   * best to identify the exact output that's expected, and then write an\n   * assertion that only accepts that exact output.\n   *\n   * When the target isn't expected to throw an error, it's often best to assert\n   * exactly that.\n   *\n   *     var goodFn = function () {};\n   *\n   *     expect(goodFn).to.not.throw(); // Recommended\n   *     expect(goodFn).to.not.throw(ReferenceError, 'x'); // Not recommended\n   *\n   * When the target is expected to throw an error, it's often best to assert\n   * that the error is of its expected type, and has a message that includes an\n   * expected string, rather than asserting that it doesn't have one of many\n   * unexpected types, and doesn't have a message that includes some string.\n   *\n   *     var badFn = function () { throw new TypeError('Illegal salmon!'); };\n   *\n   *     expect(badFn).to.throw(TypeError, 'salmon'); // Recommended\n   *     expect(badFn).to.not.throw(ReferenceError, 'x'); // Not recommended\n   *\n   * `.throw` changes the target of any assertions that follow in the chain to\n   * be the error object that's thrown.\n   *\n   *     var err = new TypeError('Illegal salmon!');\n   *     err.code = 42;\n   *     var badFn = function () { throw err; };\n   *\n   *     expect(badFn).to.throw(TypeError).with.property('code', 42);\n   *\n   * `.throw` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`. When not providing two arguments, always use\n   * the second form.\n   *\n   *     var goodFn = function () {};\n   *\n   *     expect(goodFn).to.throw(TypeError, 'x', 'nooo why fail??');\n   *     expect(goodFn, 'nooo why fail??').to.throw();\n   *\n   * Due to limitations in ES5, `.throw` may not always work as expected when\n   * using a transpiler such as Babel or TypeScript. In particular, it may\n   * produce unexpected results when subclassing the built-in `Error` object and\n   * then passing the subclassed constructor to `.throw`. See your transpiler's\n   * docs for details:\n   *\n   * - ([Babel](https://babeljs.io/docs/usage/caveats/#classes))\n   * - ([TypeScript](https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work))\n   *\n   * Beware of some common mistakes when using the `throw` assertion. One common\n   * mistake is to accidentally invoke the function yourself instead of letting\n   * the `throw` assertion invoke the function for you. For example, when\n   * testing if a function named `fn` throws, provide `fn` instead of `fn()` as\n   * the target for the assertion.\n   *\n   *     expect(fn).to.throw();     // Good! Tests `fn` as desired\n   *     expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`\n   *\n   * If you need to assert that your function `fn` throws when passed certain\n   * arguments, then wrap a call to `fn` inside of another function.\n   *\n   *     expect(function () { fn(42); }).to.throw();  // Function expression\n   *     expect(() => fn(42)).to.throw();             // ES6 arrow function\n   *\n   * Another common mistake is to provide an object method (or any stand-alone\n   * function that relies on `this`) as the target of the assertion. Doing so is\n   * problematic because the `this` context will be lost when the function is\n   * invoked by `.throw`; there's no way for it to know what `this` is supposed\n   * to be. There are two ways around this problem. One solution is to wrap the\n   * method or function call inside of another function. Another solution is to\n   * use `bind`.\n   *\n   *     expect(function () { cat.meow(); }).to.throw();  // Function expression\n   *     expect(() => cat.meow()).to.throw();             // ES6 arrow function\n   *     expect(cat.meow.bind(cat)).to.throw();           // Bind\n   *\n   * Finally, it's worth mentioning that it's a best practice in JavaScript to\n   * only throw `Error` and derivatives of `Error` such as `ReferenceError`,\n   * `TypeError`, and user-defined objects that extend `Error`. No other type of\n   * value will generate a stack trace when initialized. With that said, the\n   * `throw` assertion does technically support any type of value being thrown,\n   * not just `Error` and its derivatives.\n   *\n   * The aliases `.throws` and `.Throw` can be used interchangeably with\n   * `.throw`.\n   *\n   * @name throw\n   * @alias throws\n   * @alias Throw\n   * @param {Error|ErrorConstructor} errorLike\n   * @param {String|RegExp} errMsgMatcher error message\n   * @param {String} msg _optional_\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @returns error for chaining (null if no error)\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertThrows (errorLike, errMsgMatcher, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , ssfi = flag(this, 'ssfi')\n      , flagMsg = flag(this, 'message')\n      , negate = flag(this, 'negate') || false;\n    new Assertion(obj, flagMsg, ssfi, true).is.a('function');\n\n    if (errorLike instanceof RegExp || typeof errorLike === 'string') {\n      errMsgMatcher = errorLike;\n      errorLike = null;\n    }\n\n    var caughtErr;\n    try {\n      obj();\n    } catch (err) {\n      caughtErr = err;\n    }\n\n    // If we have the negate flag enabled and at least one valid argument it means we do expect an error\n    // but we want it to match a given set of criteria\n    var everyArgIsUndefined = errorLike === undefined && errMsgMatcher === undefined;\n\n    // If we've got the negate flag enabled and both args, we should only fail if both aren't compatible\n    // See Issue #551 and PR #683@GitHub\n    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);\n    var errorLikeFail = false;\n    var errMsgMatcherFail = false;\n\n    // Checking if error was thrown\n    if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {\n      // We need this to display results correctly according to their types\n      var errorLikeString = 'an error';\n      if (errorLike instanceof Error) {\n        errorLikeString = '#{exp}';\n      } else if (errorLike) {\n        errorLikeString = _.checkError.getConstructorName(errorLike);\n      }\n\n      this.assert(\n          caughtErr\n        , 'expected #{this} to throw ' + errorLikeString\n        , 'expected #{this} to not throw an error but #{act} was thrown'\n        , errorLike && errorLike.toString()\n        , (caughtErr instanceof Error ?\n            caughtErr.toString() : (typeof caughtErr === 'string' ? caughtErr : caughtErr &&\n                                    _.checkError.getConstructorName(caughtErr)))\n      );\n    }\n\n    if (errorLike && caughtErr) {\n      // We should compare instances only if `errorLike` is an instance of `Error`\n      if (errorLike instanceof Error) {\n        var isCompatibleInstance = _.checkError.compatibleInstance(caughtErr, errorLike);\n\n        if (isCompatibleInstance === negate) {\n          // These checks were created to ensure we won't fail too soon when we've got both args and a negate\n          // See Issue #551 and PR #683@GitHub\n          if (everyArgIsDefined && negate) {\n            errorLikeFail = true;\n          } else {\n            this.assert(\n                negate\n              , 'expected #{this} to throw #{exp} but #{act} was thrown'\n              , 'expected #{this} to not throw #{exp}' + (caughtErr && !negate ? ' but #{act} was thrown' : '')\n              , errorLike.toString()\n              , caughtErr.toString()\n            );\n          }\n        }\n      }\n\n      var isCompatibleConstructor = _.checkError.compatibleConstructor(caughtErr, errorLike);\n      if (isCompatibleConstructor === negate) {\n        if (everyArgIsDefined && negate) {\n            errorLikeFail = true;\n        } else {\n          this.assert(\n              negate\n            , 'expected #{this} to throw #{exp} but #{act} was thrown'\n            , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')\n            , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))\n            , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))\n          );\n        }\n      }\n    }\n\n    if (caughtErr && errMsgMatcher !== undefined && errMsgMatcher !== null) {\n      // Here we check compatible messages\n      var placeholder = 'including';\n      if (errMsgMatcher instanceof RegExp) {\n        placeholder = 'matching'\n      }\n\n      var isCompatibleMessage = _.checkError.compatibleMessage(caughtErr, errMsgMatcher);\n      if (isCompatibleMessage === negate) {\n        if (everyArgIsDefined && negate) {\n            errMsgMatcherFail = true;\n        } else {\n          this.assert(\n            negate\n            , 'expected #{this} to throw error ' + placeholder + ' #{exp} but got #{act}'\n            , 'expected #{this} to throw error not ' + placeholder + ' #{exp}'\n            ,  errMsgMatcher\n            ,  _.checkError.getMessage(caughtErr)\n          );\n        }\n      }\n    }\n\n    // If both assertions failed and both should've matched we throw an error\n    if (errorLikeFail && errMsgMatcherFail) {\n      this.assert(\n        negate\n        , 'expected #{this} to throw #{exp} but #{act} was thrown'\n        , 'expected #{this} to not throw #{exp}' + (caughtErr ? ' but #{act} was thrown' : '')\n        , (errorLike instanceof Error ? errorLike.toString() : errorLike && _.checkError.getConstructorName(errorLike))\n        , (caughtErr instanceof Error ? caughtErr.toString() : caughtErr && _.checkError.getConstructorName(caughtErr))\n      );\n    }\n\n    flag(this, 'object', caughtErr);\n  };\n\n  Assertion.addMethod('throw', assertThrows);\n  Assertion.addMethod('throws', assertThrows);\n  Assertion.addMethod('Throw', assertThrows);\n\n  /**\n   * ### .respondTo(method[, msg])\n   *\n   * When the target is a non-function object, `.respondTo` asserts that the\n   * target has a method with the given name `method`. The method can be own or\n   * inherited, and it can be enumerable or non-enumerable.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *\n   *     expect(new Cat()).to.respondTo('meow');\n   *\n   * When the target is a function, `.respondTo` asserts that the target's\n   * `prototype` property has a method with the given name `method`. Again, the\n   * method can be own or inherited, and it can be enumerable or non-enumerable.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *\n   *     expect(Cat).to.respondTo('meow');\n   *\n   * Add `.itself` earlier in the chain to force `.respondTo` to treat the\n   * target as a non-function object, even if it's a function. Thus, it asserts\n   * that the target has a method with the given name `method`, rather than\n   * asserting that the target's `prototype` property has a method with the\n   * given name `method`.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *     Cat.hiss = function () {};\n   *\n   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');\n   *\n   * When not adding `.itself`, it's important to check the target's type before\n   * using `.respondTo`. See the `.a` doc for info on checking a target's type.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *\n   *     expect(new Cat()).to.be.an('object').that.respondsTo('meow');\n   *\n   * Add `.not` earlier in the chain to negate `.respondTo`.\n   *\n   *     function Dog () {}\n   *     Dog.prototype.bark = function () {};\n   *\n   *     expect(new Dog()).to.not.respondTo('meow');\n   *\n   * `.respondTo` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect({}).to.respondTo('meow', 'nooo why fail??');\n   *     expect({}, 'nooo why fail??').to.respondTo('meow');\n   *\n   * The alias `.respondsTo` can be used interchangeably with `.respondTo`.\n   *\n   * @name respondTo\n   * @alias respondsTo\n   * @param {String} method\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function respondTo (method, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , itself = flag(this, 'itself')\n      , context = ('function' === typeof obj && !itself)\n        ? obj.prototype[method]\n        : obj[method];\n\n    this.assert(\n        'function' === typeof context\n      , 'expected #{this} to respond to ' + _.inspect(method)\n      , 'expected #{this} to not respond to ' + _.inspect(method)\n    );\n  }\n\n  Assertion.addMethod('respondTo', respondTo);\n  Assertion.addMethod('respondsTo', respondTo);\n\n  /**\n   * ### .itself\n   *\n   * Forces all `.respondTo` assertions that follow in the chain to behave as if\n   * the target is a non-function object, even if it's a function. Thus, it\n   * causes `.respondTo` to assert that the target has a method with the given\n   * name, rather than asserting that the target's `prototype` property has a\n   * method with the given name.\n   *\n   *     function Cat () {}\n   *     Cat.prototype.meow = function () {};\n   *     Cat.hiss = function () {};\n   *\n   *     expect(Cat).itself.to.respondTo('hiss').but.not.respondTo('meow');\n   *\n   * @name itself\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('itself', function () {\n    flag(this, 'itself', true);\n  });\n\n  /**\n   * ### .satisfy(matcher[, msg])\n   *\n   * Invokes the given `matcher` function with the target being passed as the\n   * first argument, and asserts that the value returned is truthy.\n   *\n   *     expect(1).to.satisfy(function(num) {\n   *       return num > 0;\n   *     });\n   *\n   * Add `.not` earlier in the chain to negate `.satisfy`.\n   *\n   *     expect(1).to.not.satisfy(function(num) {\n   *       return num > 2;\n   *     });\n   *\n   * `.satisfy` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect(1).to.satisfy(function(num) {\n   *       return num > 2;\n   *     }, 'nooo why fail??');\n   *\n   *     expect(1, 'nooo why fail??').to.satisfy(function(num) {\n   *       return num > 2;\n   *     });\n   *\n   * The alias `.satisfies` can be used interchangeably with `.satisfy`.\n   *\n   * @name satisfy\n   * @alias satisfies\n   * @param {Function} matcher\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function satisfy (matcher, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var result = matcher(obj);\n    this.assert(\n        result\n      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\n      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\n      , flag(this, 'negate') ? false : true\n      , result\n    );\n  }\n\n  Assertion.addMethod('satisfy', satisfy);\n  Assertion.addMethod('satisfies', satisfy);\n\n  /**\n   * ### .closeTo(expected, delta[, msg])\n   *\n   * Asserts that the target is a number that's within a given +/- `delta` range\n   * of the given number `expected`. However, it's often best to assert that the\n   * target is equal to its expected value.\n   *\n   *     // Recommended\n   *     expect(1.5).to.equal(1.5);\n   *\n   *     // Not recommended\n   *     expect(1.5).to.be.closeTo(1, 0.5);\n   *     expect(1.5).to.be.closeTo(2, 0.5);\n   *     expect(1.5).to.be.closeTo(1, 1);\n   *\n   * Add `.not` earlier in the chain to negate `.closeTo`.\n   *\n   *     expect(1.5).to.equal(1.5); // Recommended\n   *     expect(1.5).to.not.be.closeTo(3, 1); // Not recommended\n   *\n   * `.closeTo` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect(1.5).to.be.closeTo(3, 1, 'nooo why fail??');\n   *     expect(1.5, 'nooo why fail??').to.be.closeTo(3, 1);\n   *\n   * The alias `.approximately` can be used interchangeably with `.closeTo`.\n   *\n   * @name closeTo\n   * @alias approximately\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function closeTo(expected, delta, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n\n    new Assertion(obj, flagMsg, ssfi, true).is.a('number');\n    if (typeof expected !== 'number' || typeof delta !== 'number') {\n      flagMsg = flagMsg ? flagMsg + ': ' : '';\n      throw new AssertionError(\n          flagMsg + 'the arguments to closeTo or approximately must be numbers',\n          undefined,\n          ssfi\n      );\n    }\n\n    this.assert(\n        Math.abs(obj - expected) <= delta\n      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\n      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\n    );\n  }\n\n  Assertion.addMethod('closeTo', closeTo);\n  Assertion.addMethod('approximately', closeTo);\n\n  // Note: Duplicates are ignored if testing for inclusion instead of sameness.\n  function isSubsetOf(subset, superset, cmp, contains, ordered) {\n    if (!contains) {\n      if (subset.length !== superset.length) return false;\n      superset = superset.slice();\n    }\n\n    return subset.every(function(elem, idx) {\n      if (ordered) return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];\n\n      if (!cmp) {\n        var matchIdx = superset.indexOf(elem);\n        if (matchIdx === -1) return false;\n\n        // Remove match from superset so not counted twice if duplicate in subset.\n        if (!contains) superset.splice(matchIdx, 1);\n        return true;\n      }\n\n      return superset.some(function(elem2, matchIdx) {\n        if (!cmp(elem, elem2)) return false;\n\n        // Remove match from superset so not counted twice if duplicate in subset.\n        if (!contains) superset.splice(matchIdx, 1);\n        return true;\n      });\n    });\n  }\n\n  /**\n   * ### .members(set[, msg])\n   *\n   * Asserts that the target array has the same members as the given array\n   * `set`.\n   *\n   *     expect([1, 2, 3]).to.have.members([2, 1, 3]);\n   *     expect([1, 2, 2]).to.have.members([2, 1, 2]);\n   *\n   * By default, members are compared using strict (`===`) equality. Add `.deep`\n   * earlier in the chain to use deep equality instead. See the `deep-eql`\n   * project page for info on the deep equality algorithm:\n   * https://github.com/chaijs/deep-eql.\n   *\n   *     // Target array deeply (but not strictly) has member `{a: 1}`\n   *     expect([{a: 1}]).to.have.deep.members([{a: 1}]);\n   *     expect([{a: 1}]).to.not.have.members([{a: 1}]);\n   *\n   * By default, order doesn't matter. Add `.ordered` earlier in the chain to\n   * require that members appear in the same order.\n   *\n   *     expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);\n   *     expect([1, 2, 3]).to.have.members([2, 1, 3])\n   *       .but.not.ordered.members([2, 1, 3]);\n   *\n   * By default, both arrays must be the same size. Add `.include` earlier in\n   * the chain to require that the target's members be a superset of the\n   * expected members. Note that duplicates are ignored in the subset when\n   * `.include` is added.\n   *\n   *     // Target array is a superset of [1, 2] but not identical\n   *     expect([1, 2, 3]).to.include.members([1, 2]);\n   *     expect([1, 2, 3]).to.not.have.members([1, 2]);\n   *\n   *     // Duplicates in the subset are ignored\n   *     expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);\n   *\n   * `.deep`, `.ordered`, and `.include` can all be combined. However, if\n   * `.include` and `.ordered` are combined, the ordering begins at the start of\n   * both arrays.\n   *\n   *     expect([{a: 1}, {b: 2}, {c: 3}])\n   *       .to.include.deep.ordered.members([{a: 1}, {b: 2}])\n   *       .but.not.include.deep.ordered.members([{b: 2}, {c: 3}]);\n   *\n   * Add `.not` earlier in the chain to negate `.members`. However, it's\n   * dangerous to do so. The problem is that it creates uncertain expectations\n   * by asserting that the target array doesn't have all of the same members as\n   * the given array `set` but may or may not have some of them. It's often best\n   * to identify the exact output that's expected, and then write an assertion\n   * that only accepts that exact output.\n   *\n   *     expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended\n   *     expect([1, 2]).to.not.have.members([3, 4]); // Not recommended\n   *\n   * `.members` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`.\n   *\n   *     expect([1, 2]).to.have.members([1, 2, 3], 'nooo why fail??');\n   *     expect([1, 2], 'nooo why fail??').to.have.members([1, 2, 3]);\n   *\n   * @name members\n   * @param {Array} set\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addMethod('members', function (subset, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n\n    new Assertion(obj, flagMsg, ssfi, true).to.be.an('array');\n    new Assertion(subset, flagMsg, ssfi, true).to.be.an('array');\n\n    var contains = flag(this, 'contains');\n    var ordered = flag(this, 'ordered');\n\n    var subject, failMsg, failNegateMsg;\n\n    if (contains) {\n      subject = ordered ? 'an ordered superset' : 'a superset';\n      failMsg = 'expected #{this} to be ' + subject + ' of #{exp}';\n      failNegateMsg = 'expected #{this} to not be ' + subject + ' of #{exp}';\n    } else {\n      subject = ordered ? 'ordered members' : 'members';\n      failMsg = 'expected #{this} to have the same ' + subject + ' as #{exp}';\n      failNegateMsg = 'expected #{this} to not have the same ' + subject + ' as #{exp}';\n    }\n\n    var cmp = flag(this, 'deep') ? _.eql : undefined;\n\n    this.assert(\n        isSubsetOf(subset, obj, cmp, contains, ordered)\n      , failMsg\n      , failNegateMsg\n      , subset\n      , obj\n      , true\n    );\n  });\n\n  /**\n   * ### .oneOf(list[, msg])\n   *\n   * Asserts that the target is a member of the given array `list`. However,\n   * it's often best to assert that the target is equal to its expected value.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.be.oneOf([1, 2, 3]); // Not recommended\n   *\n   * Comparisons are performed using strict (`===`) equality.\n   *\n   * Add `.not` earlier in the chain to negate `.oneOf`.\n   *\n   *     expect(1).to.equal(1); // Recommended\n   *     expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended\n   *\n   * `.oneOf` accepts an optional `msg` argument which is a custom error message\n   * to show when the assertion fails. The message can also be given as the\n   * second argument to `expect`.\n   *\n   *     expect(1).to.be.oneOf([2, 3, 4], 'nooo why fail??');\n   *     expect(1, 'nooo why fail??').to.be.oneOf([2, 3, 4]);\n   *\n   * @name oneOf\n   * @param {Array<*>} list\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function oneOf (list, msg) {\n    if (msg) flag(this, 'message', msg);\n    var expected = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(list, flagMsg, ssfi, true).to.be.an('array');\n\n    this.assert(\n        list.indexOf(expected) > -1\n      , 'expected #{this} to be one of #{exp}'\n      , 'expected #{this} to not be one of #{exp}'\n      , list\n      , expected\n    );\n  }\n\n  Assertion.addMethod('oneOf', oneOf);\n\n  /**\n   * ### .change(subject[, prop[, msg]])\n   *\n   * When one argument is provided, `.change` asserts that the given function\n   * `subject` returns a different value when it's invoked before the target\n   * function compared to when it's invoked afterward. However, it's often best\n   * to assert that `subject` is equal to its expected value.\n   *\n   *     var dots = ''\n   *       , addDot = function () { dots += '.'; }\n   *       , getDots = function () { return dots; };\n   *\n   *     // Recommended\n   *     expect(getDots()).to.equal('');\n   *     addDot();\n   *     expect(getDots()).to.equal('.');\n   *\n   *     // Not recommended\n   *     expect(addDot).to.change(getDots);\n   *\n   * When two arguments are provided, `.change` asserts that the value of the\n   * given object `subject`'s `prop` property is different before invoking the\n   * target function compared to afterward.\n   *\n   *     var myObj = {dots: ''}\n   *       , addDot = function () { myObj.dots += '.'; };\n   *\n   *     // Recommended\n   *     expect(myObj).to.have.property('dots', '');\n   *     addDot();\n   *     expect(myObj).to.have.property('dots', '.');\n   *\n   *     // Not recommended\n   *     expect(addDot).to.change(myObj, 'dots');\n   *\n   * Strict (`===`) equality is used to compare before and after values.\n   *\n   * Add `.not` earlier in the chain to negate `.change`.\n   *\n   *     var dots = ''\n   *       , noop = function () {}\n   *       , getDots = function () { return dots; };\n   *\n   *     expect(noop).to.not.change(getDots);\n   *\n   *     var myObj = {dots: ''}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.not.change(myObj, 'dots');\n   *\n   * `.change` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`. When not providing two arguments, always\n   * use the second form.\n   *\n   *     var myObj = {dots: ''}\n   *       , addDot = function () { myObj.dots += '.'; };\n   *\n   *     expect(addDot).to.not.change(myObj, 'dots', 'nooo why fail??');\n   *\n   *     var dots = ''\n   *       , addDot = function () { dots += '.'; }\n   *       , getDots = function () { return dots; };\n   *\n   *     expect(addDot, 'nooo why fail??').to.not.change(getDots);\n   *\n   * `.change` also causes all `.by` assertions that follow in the chain to\n   * assert how much a numeric subject was increased or decreased by. However,\n   * it's dangerous to use `.change.by`. The problem is that it creates\n   * uncertain expectations by asserting that the subject either increases by\n   * the given delta, or that it decreases by the given delta. It's often best\n   * to identify the exact output that's expected, and then write an assertion\n   * that only accepts that exact output.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; }\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\n   *\n   * The alias `.changes` can be used interchangeably with `.change`.\n   *\n   * @name change\n   * @alias changes\n   * @param {String} subject\n   * @param {String} prop name _optional_\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertChanges (subject, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(fn, flagMsg, ssfi, true).is.a('function');\n\n    var initial;\n    if (!prop) {\n      new Assertion(subject, flagMsg, ssfi, true).is.a('function');\n      initial = subject();\n    } else {\n      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\n      initial = subject[prop];\n    }\n\n    fn();\n\n    var final = prop === undefined || prop === null ? subject() : subject[prop];\n    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\n\n    // This gets flagged because of the .by(delta) assertion\n    flag(this, 'deltaMsgObj', msgObj);\n    flag(this, 'initialDeltaValue', initial);\n    flag(this, 'finalDeltaValue', final);\n    flag(this, 'deltaBehavior', 'change');\n    flag(this, 'realDelta', final !== initial);\n\n    this.assert(\n      initial !== final\n      , 'expected ' + msgObj + ' to change'\n      , 'expected ' + msgObj + ' to not change'\n    );\n  }\n\n  Assertion.addMethod('change', assertChanges);\n  Assertion.addMethod('changes', assertChanges);\n\n  /**\n   * ### .increase(subject[, prop[, msg]])\n   *\n   * When one argument is provided, `.increase` asserts that the given function\n   * `subject` returns a greater number when it's invoked after invoking the\n   * target function compared to when it's invoked beforehand. `.increase` also\n   * causes all `.by` assertions that follow in the chain to assert how much\n   * greater of a number is returned. It's often best to assert that the return\n   * value increased by the expected amount, rather than asserting it increased\n   * by any amount.\n   *\n   *     var val = 1\n   *       , addTwo = function () { val += 2; }\n   *       , getVal = function () { return val; };\n   *\n   *     expect(addTwo).to.increase(getVal).by(2); // Recommended\n   *     expect(addTwo).to.increase(getVal); // Not recommended\n   *\n   * When two arguments are provided, `.increase` asserts that the value of the\n   * given object `subject`'s `prop` property is greater after invoking the\n   * target function compared to beforehand.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n   *     expect(addTwo).to.increase(myObj, 'val'); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.increase`. However, it's\n   * dangerous to do so. The problem is that it creates uncertain expectations\n   * by asserting that the subject either decreases, or that it stays the same.\n   * It's often best to identify the exact output that's expected, and then\n   * write an assertion that only accepts that exact output.\n   *\n   * When the subject is expected to decrease, it's often best to assert that it\n   * decreased by the expected amount.\n   *\n   *     var myObj = {val: 1}\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n   *     expect(subtractTwo).to.not.increase(myObj, 'val'); // Not recommended\n   *\n   * When the subject is expected to stay the same, it's often best to assert\n   * exactly that.\n   *\n   *     var myObj = {val: 1}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.not.change(myObj, 'val'); // Recommended\n   *     expect(noop).to.not.increase(myObj, 'val'); // Not recommended\n   *\n   * `.increase` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`. When not providing two arguments, always\n   * use the second form.\n   *\n   *     var myObj = {val: 1}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.increase(myObj, 'val', 'nooo why fail??');\n   *\n   *     var val = 1\n   *       , noop = function () {}\n   *       , getVal = function () { return val; };\n   *\n   *     expect(noop, 'nooo why fail??').to.increase(getVal);\n   *\n   * The alias `.increases` can be used interchangeably with `.increase`.\n   *\n   * @name increase\n   * @alias increases\n   * @param {String|Function} subject\n   * @param {String} prop name _optional_\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertIncreases (subject, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(fn, flagMsg, ssfi, true).is.a('function');\n\n    var initial;\n    if (!prop) {\n      new Assertion(subject, flagMsg, ssfi, true).is.a('function');\n      initial = subject();\n    } else {\n      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\n      initial = subject[prop];\n    }\n\n    // Make sure that the target is a number\n    new Assertion(initial, flagMsg, ssfi, true).is.a('number');\n\n    fn();\n\n    var final = prop === undefined || prop === null ? subject() : subject[prop];\n    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\n\n    flag(this, 'deltaMsgObj', msgObj);\n    flag(this, 'initialDeltaValue', initial);\n    flag(this, 'finalDeltaValue', final);\n    flag(this, 'deltaBehavior', 'increase');\n    flag(this, 'realDelta', final - initial);\n\n    this.assert(\n      final - initial > 0\n      , 'expected ' + msgObj + ' to increase'\n      , 'expected ' + msgObj + ' to not increase'\n    );\n  }\n\n  Assertion.addMethod('increase', assertIncreases);\n  Assertion.addMethod('increases', assertIncreases);\n\n  /**\n   * ### .decrease(subject[, prop[, msg]])\n   *\n   * When one argument is provided, `.decrease` asserts that the given function\n   * `subject` returns a lesser number when it's invoked after invoking the\n   * target function compared to when it's invoked beforehand. `.decrease` also\n   * causes all `.by` assertions that follow in the chain to assert how much\n   * lesser of a number is returned. It's often best to assert that the return\n   * value decreased by the expected amount, rather than asserting it decreased\n   * by any amount.\n   *\n   *     var val = 1\n   *       , subtractTwo = function () { val -= 2; }\n   *       , getVal = function () { return val; };\n   *\n   *     expect(subtractTwo).to.decrease(getVal).by(2); // Recommended\n   *     expect(subtractTwo).to.decrease(getVal); // Not recommended\n   *\n   * When two arguments are provided, `.decrease` asserts that the value of the\n   * given object `subject`'s `prop` property is lesser after invoking the\n   * target function compared to beforehand.\n   *\n   *     var myObj = {val: 1}\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n   *     expect(subtractTwo).to.decrease(myObj, 'val'); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.decrease`. However, it's\n   * dangerous to do so. The problem is that it creates uncertain expectations\n   * by asserting that the subject either increases, or that it stays the same.\n   * It's often best to identify the exact output that's expected, and then\n   * write an assertion that only accepts that exact output.\n   *\n   * When the subject is expected to increase, it's often best to assert that it\n   * increased by the expected amount.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n   *     expect(addTwo).to.not.decrease(myObj, 'val'); // Not recommended\n   *\n   * When the subject is expected to stay the same, it's often best to assert\n   * exactly that.\n   *\n   *     var myObj = {val: 1}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.not.change(myObj, 'val'); // Recommended\n   *     expect(noop).to.not.decrease(myObj, 'val'); // Not recommended\n   *\n   * `.decrease` accepts an optional `msg` argument which is a custom error\n   * message to show when the assertion fails. The message can also be given as\n   * the second argument to `expect`. When not providing two arguments, always\n   * use the second form.\n   *\n   *     var myObj = {val: 1}\n   *       , noop = function () {};\n   *\n   *     expect(noop).to.decrease(myObj, 'val', 'nooo why fail??');\n   *\n   *     var val = 1\n   *       , noop = function () {}\n   *       , getVal = function () { return val; };\n   *\n   *     expect(noop, 'nooo why fail??').to.decrease(getVal);\n   *\n   * The alias `.decreases` can be used interchangeably with `.decrease`.\n   *\n   * @name decrease\n   * @alias decreases\n   * @param {String|Function} subject\n   * @param {String} prop name _optional_\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertDecreases (subject, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object')\n      , flagMsg = flag(this, 'message')\n      , ssfi = flag(this, 'ssfi');\n    new Assertion(fn, flagMsg, ssfi, true).is.a('function');\n\n    var initial;\n    if (!prop) {\n      new Assertion(subject, flagMsg, ssfi, true).is.a('function');\n      initial = subject();\n    } else {\n      new Assertion(subject, flagMsg, ssfi, true).to.have.property(prop);\n      initial = subject[prop];\n    }\n\n    // Make sure that the target is a number\n    new Assertion(initial, flagMsg, ssfi, true).is.a('number');\n\n    fn();\n\n    var final = prop === undefined || prop === null ? subject() : subject[prop];\n    var msgObj = prop === undefined || prop === null ? initial : '.' + prop;\n\n    flag(this, 'deltaMsgObj', msgObj);\n    flag(this, 'initialDeltaValue', initial);\n    flag(this, 'finalDeltaValue', final);\n    flag(this, 'deltaBehavior', 'decrease');\n    flag(this, 'realDelta', initial - final);\n\n    this.assert(\n      final - initial < 0\n      , 'expected ' + msgObj + ' to decrease'\n      , 'expected ' + msgObj + ' to not decrease'\n    );\n  }\n\n  Assertion.addMethod('decrease', assertDecreases);\n  Assertion.addMethod('decreases', assertDecreases);\n\n  /**\n   * ### .by(delta[, msg])\n   *\n   * When following an `.increase` assertion in the chain, `.by` asserts that\n   * the subject of the `.increase` assertion increased by the given `delta`.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2);\n   *\n   * When following a `.decrease` assertion in the chain, `.by` asserts that the\n   * subject of the `.decrease` assertion decreased by the given `delta`.\n   *\n   *     var myObj = {val: 1}\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2);\n   *\n   * When following a `.change` assertion in the chain, `.by` asserts that the\n   * subject of the `.change` assertion either increased or decreased by the\n   * given `delta`. However, it's dangerous to use `.change.by`. The problem is\n   * that it creates uncertain expectations. It's often best to identify the\n   * exact output that's expected, and then write an assertion that only accepts\n   * that exact output.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; }\n   *       , subtractTwo = function () { myObj.val -= 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(2); // Recommended\n   *     expect(addTwo).to.change(myObj, 'val').by(2); // Not recommended\n   *\n   *     expect(subtractTwo).to.decrease(myObj, 'val').by(2); // Recommended\n   *     expect(subtractTwo).to.change(myObj, 'val').by(2); // Not recommended\n   *\n   * Add `.not` earlier in the chain to negate `.by`. However, it's often best\n   * to assert that the subject changed by its expected delta, rather than\n   * asserting that it didn't change by one of countless unexpected deltas.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     // Recommended\n   *     expect(addTwo).to.increase(myObj, 'val').by(2);\n   *\n   *     // Not recommended\n   *     expect(addTwo).to.increase(myObj, 'val').but.not.by(3);\n   *\n   * `.by` accepts an optional `msg` argument which is a custom error message to\n   * show when the assertion fails. The message can also be given as the second\n   * argument to `expect`.\n   *\n   *     var myObj = {val: 1}\n   *       , addTwo = function () { myObj.val += 2; };\n   *\n   *     expect(addTwo).to.increase(myObj, 'val').by(3, 'nooo why fail??');\n   *     expect(addTwo, 'nooo why fail??').to.increase(myObj, 'val').by(3);\n   *\n   * @name by\n   * @param {Number} delta\n   * @param {String} msg _optional_\n   * @namespace BDD\n   * @api public\n   */\n\n  function assertDelta(delta, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var msgObj = flag(this, 'deltaMsgObj');\n    var initial = flag(this, 'initialDeltaValue');\n    var final = flag(this, 'finalDeltaValue');\n    var behavior = flag(this, 'deltaBehavior');\n    var realDelta = flag(this, 'realDelta');\n\n    var expression;\n    if (behavior === 'change') {\n      expression = Math.abs(final - initial) === Math.abs(delta);\n    } else {\n      expression = realDelta === Math.abs(delta);\n    }\n\n    this.assert(\n      expression\n      , 'expected ' + msgObj + ' to ' + behavior + ' by ' + delta\n      , 'expected ' + msgObj + ' to not ' + behavior + ' by ' + delta\n    );\n  }\n\n  Assertion.addMethod('by', assertDelta);\n\n  /**\n   * ### .extensible\n   *\n   * Asserts that the target is extensible, which means that new properties can\n   * be added to it. Primitives are never extensible.\n   *\n   *     expect({a: 1}).to.be.extensible;\n   *\n   * Add `.not` earlier in the chain to negate `.extensible`.\n   *\n   *     var nonExtensibleObject = Object.preventExtensions({})\n   *       , sealedObject = Object.seal({})\n   *       , frozenObject = Object.freeze({});\n   *\n   *     expect(nonExtensibleObject).to.not.be.extensible;\n   *     expect(sealedObject).to.not.be.extensible;\n   *     expect(frozenObject).to.not.be.extensible;\n   *     expect(1).to.not.be.extensible;\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect(1, 'nooo why fail??').to.be.extensible;\n   *\n   * @name extensible\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('extensible', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n    // The following provides ES6 behavior for ES5 environments.\n\n    var isExtensible = obj === Object(obj) && Object.isExtensible(obj);\n\n    this.assert(\n      isExtensible\n      , 'expected #{this} to be extensible'\n      , 'expected #{this} to not be extensible'\n    );\n  });\n\n  /**\n   * ### .sealed\n   *\n   * Asserts that the target is sealed, which means that new properties can't be\n   * added to it, and its existing properties can't be reconfigured or deleted.\n   * However, it's possible that its existing properties can still be reassigned\n   * to different values. Primitives are always sealed.\n   *\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.freeze({});\n   *\n   *     expect(sealedObject).to.be.sealed;\n   *     expect(frozenObject).to.be.sealed;\n   *     expect(1).to.be.sealed;\n   *\n   * Add `.not` earlier in the chain to negate `.sealed`.\n   *\n   *     expect({a: 1}).to.not.be.sealed;\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect({a: 1}, 'nooo why fail??').to.be.sealed;\n   *\n   * @name sealed\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('sealed', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n    // The following provides ES6 behavior for ES5 environments.\n\n    var isSealed = obj === Object(obj) ? Object.isSealed(obj) : true;\n\n    this.assert(\n      isSealed\n      , 'expected #{this} to be sealed'\n      , 'expected #{this} to not be sealed'\n    );\n  });\n\n  /**\n   * ### .frozen\n   *\n   * Asserts that the target is frozen, which means that new properties can't be\n   * added to it, and its existing properties can't be reassigned to different\n   * values, reconfigured, or deleted. Primitives are always frozen.\n   *\n   *     var frozenObject = Object.freeze({});\n   *\n   *     expect(frozenObject).to.be.frozen;\n   *     expect(1).to.be.frozen;\n   *\n   * Add `.not` earlier in the chain to negate `.frozen`.\n   *\n   *     expect({a: 1}).to.not.be.frozen;\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect({a: 1}, 'nooo why fail??').to.be.frozen;\n   *\n   * @name frozen\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('frozen', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is a primitive, then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n    // The following provides ES6 behavior for ES5 environments.\n\n    var isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : true;\n\n    this.assert(\n      isFrozen\n      , 'expected #{this} to be frozen'\n      , 'expected #{this} to not be frozen'\n    );\n  });\n\n  /**\n   * ### .finite\n   *\n   * Asserts that the target is a number, and isn't `NaN` or positive/negative\n   * `Infinity`.\n   *\n   *     expect(1).to.be.finite;\n   *\n   * Add `.not` earlier in the chain to negate `.finite`. However, it's\n   * dangerous to do so. The problem is that it creates uncertain expectations\n   * by asserting that the subject either isn't a number, or that it's `NaN`, or\n   * that it's positive `Infinity`, or that it's negative `Infinity`. It's often\n   * best to identify the exact output that's expected, and then write an\n   * assertion that only accepts that exact output.\n   *\n   * When the target isn't expected to be a number, it's often best to assert\n   * that it's the expected type, rather than asserting that it isn't one of\n   * many unexpected types.\n   *\n   *     expect('foo').to.be.a('string'); // Recommended\n   *     expect('foo').to.not.be.finite; // Not recommended\n   *\n   * When the target is expected to be `NaN`, it's often best to assert exactly\n   * that.\n   *\n   *     expect(NaN).to.be.NaN; // Recommended\n   *     expect(NaN).to.not.be.finite; // Not recommended\n   *\n   * When the target is expected to be positive infinity, it's often best to\n   * assert exactly that.\n   *\n   *     expect(Infinity).to.equal(Infinity); // Recommended\n   *     expect(Infinity).to.not.be.finite; // Not recommended\n   *\n   * When the target is expected to be negative infinity, it's often best to\n   * assert exactly that.\n   *\n   *     expect(-Infinity).to.equal(-Infinity); // Recommended\n   *     expect(-Infinity).to.not.be.finite; // Not recommended\n   *\n   * A custom error message can be given as the second argument to `expect`.\n   *\n   *     expect('foo', 'nooo why fail??').to.be.finite;\n   *\n   * @name finite\n   * @namespace BDD\n   * @api public\n   */\n\n  Assertion.addProperty('finite', function(msg) {\n    var obj = flag(this, 'object');\n\n    this.assert(\n        typeof obj === 'number' && isFinite(obj)\n      , 'expected #{this} to be a finite number'\n      , 'expected #{this} to not be a finite number'\n    );\n  });\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/core/assertions.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/interface/assert.js":
/*!***************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/interface/assert.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  /*!\n   * Chai dependencies.\n   */\n\n  var Assertion = chai.Assertion\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  /**\n   * ### assert(expression, message)\n   *\n   * Write your own test expressions.\n   *\n   *     assert('foo' !== 'bar', 'foo is not bar');\n   *     assert(Array.isArray([]), 'empty arrays are arrays');\n   *\n   * @param {Mixed} expression to test for truthiness\n   * @param {String} message to display on error\n   * @name assert\n   * @namespace Assert\n   * @api public\n   */\n\n  var assert = chai.assert = function (express, errmsg) {\n    var test = new Assertion(null, null, chai.assert, true);\n    test.assert(\n        express\n      , errmsg\n      , '[ negation message unavailable ]'\n    );\n  };\n\n  /**\n   * ### .fail([message])\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure. Node.js `assert` module-compatible.\n   *\n   *     assert.fail();\n   *     assert.fail(\"custom error message\");\n   *     assert.fail(1, 2);\n   *     assert.fail(1, 2, \"custom error message\");\n   *     assert.fail(1, 2, \"custom error message\", \">\");\n   *     assert.fail(1, 2, undefined, \">\");\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.fail = function (actual, expected, message, operator) {\n    if (arguments.length < 2) {\n        // Comply with Node's fail([message]) interface\n\n        message = actual;\n        actual = undefined;\n    }\n\n    message = message || 'assert.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, assert.fail);\n  };\n\n  /**\n   * ### .isOk(object, [message])\n   *\n   * Asserts that `object` is truthy.\n   *\n   *     assert.isOk('everything', 'everything is ok');\n   *     assert.isOk(false, 'this will fail');\n   *\n   * @name isOk\n   * @alias ok\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isOk = function (val, msg) {\n    new Assertion(val, msg, assert.isOk, true).is.ok;\n  };\n\n  /**\n   * ### .isNotOk(object, [message])\n   *\n   * Asserts that `object` is falsy.\n   *\n   *     assert.isNotOk('everything', 'this will fail');\n   *     assert.isNotOk(false, 'this will pass');\n   *\n   * @name isNotOk\n   * @alias notOk\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotOk = function (val, msg) {\n    new Assertion(val, msg, assert.isNotOk, true).is.not.ok;\n  };\n\n  /**\n   * ### .equal(actual, expected, [message])\n   *\n   * Asserts non-strict equality (`==`) of `actual` and `expected`.\n   *\n   *     assert.equal(3, '3', '== coerces values to strings');\n   *\n   * @name equal\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.equal = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.equal, true);\n\n    test.assert(\n        exp == flag(test, 'object')\n      , 'expected #{this} to equal #{exp}'\n      , 'expected #{this} to not equal #{act}'\n      , exp\n      , act\n      , true\n    );\n  };\n\n  /**\n   * ### .notEqual(actual, expected, [message])\n   *\n   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n   *\n   *     assert.notEqual(3, 4, 'these numbers are not equal');\n   *\n   * @name notEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notEqual = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.notEqual, true);\n\n    test.assert(\n        exp != flag(test, 'object')\n      , 'expected #{this} to not equal #{exp}'\n      , 'expected #{this} to equal #{act}'\n      , exp\n      , act\n      , true\n    );\n  };\n\n  /**\n   * ### .strictEqual(actual, expected, [message])\n   *\n   * Asserts strict equality (`===`) of `actual` and `expected`.\n   *\n   *     assert.strictEqual(true, true, 'these booleans are strictly equal');\n   *\n   * @name strictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.strictEqual = function (act, exp, msg) {\n    new Assertion(act, msg, assert.strictEqual, true).to.equal(exp);\n  };\n\n  /**\n   * ### .notStrictEqual(actual, expected, [message])\n   *\n   * Asserts strict inequality (`!==`) of `actual` and `expected`.\n   *\n   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\n   *\n   * @name notStrictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notStrictEqual = function (act, exp, msg) {\n    new Assertion(act, msg, assert.notStrictEqual, true).to.not.equal(exp);\n  };\n\n  /**\n   * ### .deepEqual(actual, expected, [message])\n   *\n   * Asserts that `actual` is deeply equal to `expected`.\n   *\n   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\n   *\n   * @name deepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @alias deepStrictEqual\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepEqual = assert.deepStrictEqual = function (act, exp, msg) {\n    new Assertion(act, msg, assert.deepEqual, true).to.eql(exp);\n  };\n\n  /**\n   * ### .notDeepEqual(actual, expected, [message])\n   *\n   * Assert that `actual` is not deeply equal to `expected`.\n   *\n   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\n   *\n   * @name notDeepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepEqual = function (act, exp, msg) {\n    new Assertion(act, msg, assert.notDeepEqual, true).to.not.eql(exp);\n  };\n\n   /**\n   * ### .isAbove(valueToCheck, valueToBeAbove, [message])\n   *\n   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`.\n   *\n   *     assert.isAbove(5, 2, '5 is strictly greater than 2');\n   *\n   * @name isAbove\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAbove\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isAbove = function (val, abv, msg) {\n    new Assertion(val, msg, assert.isAbove, true).to.be.above(abv);\n  };\n\n   /**\n   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])\n   *\n   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`.\n   *\n   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');\n   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');\n   *\n   * @name isAtLeast\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAtLeast\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isAtLeast = function (val, atlst, msg) {\n    new Assertion(val, msg, assert.isAtLeast, true).to.be.least(atlst);\n  };\n\n   /**\n   * ### .isBelow(valueToCheck, valueToBeBelow, [message])\n   *\n   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`.\n   *\n   *     assert.isBelow(3, 6, '3 is strictly less than 6');\n   *\n   * @name isBelow\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeBelow\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isBelow = function (val, blw, msg) {\n    new Assertion(val, msg, assert.isBelow, true).to.be.below(blw);\n  };\n\n   /**\n   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])\n   *\n   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`.\n   *\n   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');\n   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');\n   *\n   * @name isAtMost\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAtMost\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isAtMost = function (val, atmst, msg) {\n    new Assertion(val, msg, assert.isAtMost, true).to.be.most(atmst);\n  };\n\n  /**\n   * ### .isTrue(value, [message])\n   *\n   * Asserts that `value` is true.\n   *\n   *     var teaServed = true;\n   *     assert.isTrue(teaServed, 'the tea has been served');\n   *\n   * @name isTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isTrue = function (val, msg) {\n    new Assertion(val, msg, assert.isTrue, true).is['true'];\n  };\n\n  /**\n   * ### .isNotTrue(value, [message])\n   *\n   * Asserts that `value` is not true.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotTrue(tea, 'great, time for tea!');\n   *\n   * @name isNotTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotTrue = function (val, msg) {\n    new Assertion(val, msg, assert.isNotTrue, true).to.not.equal(true);\n  };\n\n  /**\n   * ### .isFalse(value, [message])\n   *\n   * Asserts that `value` is false.\n   *\n   *     var teaServed = false;\n   *     assert.isFalse(teaServed, 'no tea yet? hmm...');\n   *\n   * @name isFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isFalse = function (val, msg) {\n    new Assertion(val, msg, assert.isFalse, true).is['false'];\n  };\n\n  /**\n   * ### .isNotFalse(value, [message])\n   *\n   * Asserts that `value` is not false.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotFalse(tea, 'great, time for tea!');\n   *\n   * @name isNotFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotFalse = function (val, msg) {\n    new Assertion(val, msg, assert.isNotFalse, true).to.not.equal(false);\n  };\n\n  /**\n   * ### .isNull(value, [message])\n   *\n   * Asserts that `value` is null.\n   *\n   *     assert.isNull(err, 'there was no error');\n   *\n   * @name isNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNull = function (val, msg) {\n    new Assertion(val, msg, assert.isNull, true).to.equal(null);\n  };\n\n  /**\n   * ### .isNotNull(value, [message])\n   *\n   * Asserts that `value` is not null.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotNull(tea, 'great, time for tea!');\n   *\n   * @name isNotNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotNull = function (val, msg) {\n    new Assertion(val, msg, assert.isNotNull, true).to.not.equal(null);\n  };\n\n  /**\n   * ### .isNaN\n   *\n   * Asserts that value is NaN.\n   *\n   *     assert.isNaN(NaN, 'NaN is NaN');\n   *\n   * @name isNaN\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNaN = function (val, msg) {\n    new Assertion(val, msg, assert.isNaN, true).to.be.NaN;\n  };\n\n  /**\n   * ### .isNotNaN\n   *\n   * Asserts that value is not NaN.\n   *\n   *     assert.isNotNaN(4, '4 is not NaN');\n   *\n   * @name isNotNaN\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n  assert.isNotNaN = function (val, msg) {\n    new Assertion(val, msg, assert.isNotNaN, true).not.to.be.NaN;\n  };\n\n  /**\n   * ### .exists\n   *\n   * Asserts that the target is neither `null` nor `undefined`.\n   *\n   *     var foo = 'hi';\n   *\n   *     assert.exists(foo, 'foo is neither `null` nor `undefined`');\n   *\n   * @name exists\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.exists = function (val, msg) {\n    new Assertion(val, msg, assert.exists, true).to.exist;\n  };\n\n  /**\n   * ### .notExists\n   *\n   * Asserts that the target is either `null` or `undefined`.\n   *\n   *     var bar = null\n   *       , baz;\n   *\n   *     assert.notExists(bar);\n   *     assert.notExists(baz, 'baz is either null or undefined');\n   *\n   * @name notExists\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notExists = function (val, msg) {\n    new Assertion(val, msg, assert.notExists, true).to.not.exist;\n  };\n\n  /**\n   * ### .isUndefined(value, [message])\n   *\n   * Asserts that `value` is `undefined`.\n   *\n   *     var tea;\n   *     assert.isUndefined(tea, 'no tea defined');\n   *\n   * @name isUndefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isUndefined = function (val, msg) {\n    new Assertion(val, msg, assert.isUndefined, true).to.equal(undefined);\n  };\n\n  /**\n   * ### .isDefined(value, [message])\n   *\n   * Asserts that `value` is not `undefined`.\n   *\n   *     var tea = 'cup of chai';\n   *     assert.isDefined(tea, 'tea has been defined');\n   *\n   * @name isDefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isDefined = function (val, msg) {\n    new Assertion(val, msg, assert.isDefined, true).to.not.equal(undefined);\n  };\n\n  /**\n   * ### .isFunction(value, [message])\n   *\n   * Asserts that `value` is a function.\n   *\n   *     function serveTea() { return 'cup of tea'; };\n   *     assert.isFunction(serveTea, 'great, we can have tea now');\n   *\n   * @name isFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isFunction = function (val, msg) {\n    new Assertion(val, msg, assert.isFunction, true).to.be.a('function');\n  };\n\n  /**\n   * ### .isNotFunction(value, [message])\n   *\n   * Asserts that `value` is _not_ a function.\n   *\n   *     var serveTea = [ 'heat', 'pour', 'sip' ];\n   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\n   *\n   * @name isNotFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotFunction = function (val, msg) {\n    new Assertion(val, msg, assert.isNotFunction, true).to.not.be.a('function');\n  };\n\n  /**\n   * ### .isObject(value, [message])\n   *\n   * Asserts that `value` is an object of type 'Object' (as revealed by `Object.prototype.toString`).\n   * _The assertion does not match subclassed objects._\n   *\n   *     var selection = { name: 'Chai', serve: 'with spices' };\n   *     assert.isObject(selection, 'tea selection is an object');\n   *\n   * @name isObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isObject = function (val, msg) {\n    new Assertion(val, msg, assert.isObject, true).to.be.a('object');\n  };\n\n  /**\n   * ### .isNotObject(value, [message])\n   *\n   * Asserts that `value` is _not_ an object of type 'Object' (as revealed by `Object.prototype.toString`).\n   *\n   *     var selection = 'chai'\n   *     assert.isNotObject(selection, 'tea selection is not an object');\n   *     assert.isNotObject(null, 'null is not an object');\n   *\n   * @name isNotObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotObject = function (val, msg) {\n    new Assertion(val, msg, assert.isNotObject, true).to.not.be.a('object');\n  };\n\n  /**\n   * ### .isArray(value, [message])\n   *\n   * Asserts that `value` is an array.\n   *\n   *     var menu = [ 'green', 'chai', 'oolong' ];\n   *     assert.isArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isArray = function (val, msg) {\n    new Assertion(val, msg, assert.isArray, true).to.be.an('array');\n  };\n\n  /**\n   * ### .isNotArray(value, [message])\n   *\n   * Asserts that `value` is _not_ an array.\n   *\n   *     var menu = 'green|chai|oolong';\n   *     assert.isNotArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isNotArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotArray = function (val, msg) {\n    new Assertion(val, msg, assert.isNotArray, true).to.not.be.an('array');\n  };\n\n  /**\n   * ### .isString(value, [message])\n   *\n   * Asserts that `value` is a string.\n   *\n   *     var teaOrder = 'chai';\n   *     assert.isString(teaOrder, 'order placed');\n   *\n   * @name isString\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isString = function (val, msg) {\n    new Assertion(val, msg, assert.isString, true).to.be.a('string');\n  };\n\n  /**\n   * ### .isNotString(value, [message])\n   *\n   * Asserts that `value` is _not_ a string.\n   *\n   *     var teaOrder = 4;\n   *     assert.isNotString(teaOrder, 'order placed');\n   *\n   * @name isNotString\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotString = function (val, msg) {\n    new Assertion(val, msg, assert.isNotString, true).to.not.be.a('string');\n  };\n\n  /**\n   * ### .isNumber(value, [message])\n   *\n   * Asserts that `value` is a number.\n   *\n   *     var cups = 2;\n   *     assert.isNumber(cups, 'how many cups');\n   *\n   * @name isNumber\n   * @param {Number} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNumber = function (val, msg) {\n    new Assertion(val, msg, assert.isNumber, true).to.be.a('number');\n  };\n\n  /**\n   * ### .isNotNumber(value, [message])\n   *\n   * Asserts that `value` is _not_ a number.\n   *\n   *     var cups = '2 cups please';\n   *     assert.isNotNumber(cups, 'how many cups');\n   *\n   * @name isNotNumber\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotNumber = function (val, msg) {\n    new Assertion(val, msg, assert.isNotNumber, true).to.not.be.a('number');\n  };\n\n   /**\n   * ### .isFinite(value, [message])\n   *\n   * Asserts that `value` is a finite number. Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.\n   *\n   *     var cups = 2;\n   *     assert.isFinite(cups, 'how many cups');\n   *\n   *     assert.isFinite(NaN); // throws\n   *\n   * @name isFinite\n   * @param {Number} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isFinite = function (val, msg) {\n    new Assertion(val, msg, assert.isFinite, true).to.be.finite;\n  };\n\n  /**\n   * ### .isBoolean(value, [message])\n   *\n   * Asserts that `value` is a boolean.\n   *\n   *     var teaReady = true\n   *       , teaServed = false;\n   *\n   *     assert.isBoolean(teaReady, 'is the tea ready');\n   *     assert.isBoolean(teaServed, 'has tea been served');\n   *\n   * @name isBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isBoolean = function (val, msg) {\n    new Assertion(val, msg, assert.isBoolean, true).to.be.a('boolean');\n  };\n\n  /**\n   * ### .isNotBoolean(value, [message])\n   *\n   * Asserts that `value` is _not_ a boolean.\n   *\n   *     var teaReady = 'yep'\n   *       , teaServed = 'nope';\n   *\n   *     assert.isNotBoolean(teaReady, 'is the tea ready');\n   *     assert.isNotBoolean(teaServed, 'has tea been served');\n   *\n   * @name isNotBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotBoolean = function (val, msg) {\n    new Assertion(val, msg, assert.isNotBoolean, true).to.not.be.a('boolean');\n  };\n\n  /**\n   * ### .typeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n   *     assert.typeOf('tea', 'string', 'we have a string');\n   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n   *     assert.typeOf(null, 'null', 'we have a null');\n   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\n   *\n   * @name typeOf\n   * @param {Mixed} value\n   * @param {String} name\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.typeOf = function (val, type, msg) {\n    new Assertion(val, msg, assert.typeOf, true).to.be.a(type);\n  };\n\n  /**\n   * ### .notTypeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is _not_ `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\n   *\n   * @name notTypeOf\n   * @param {Mixed} value\n   * @param {String} typeof name\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notTypeOf = function (val, type, msg) {\n    new Assertion(val, msg, assert.notTypeOf, true).to.not.be.a(type);\n  };\n\n  /**\n   * ### .instanceOf(object, constructor, [message])\n   *\n   * Asserts that `value` is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new Tea('chai');\n   *\n   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\n   *\n   * @name instanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.instanceOf = function (val, type, msg) {\n    new Assertion(val, msg, assert.instanceOf, true).to.be.instanceOf(type);\n  };\n\n  /**\n   * ### .notInstanceOf(object, constructor, [message])\n   *\n   * Asserts `value` is not an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new String('chai');\n   *\n   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\n   *\n   * @name notInstanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notInstanceOf = function (val, type, msg) {\n    new Assertion(val, msg, assert.notInstanceOf, true)\n      .to.not.be.instanceOf(type);\n  };\n\n  /**\n   * ### .include(haystack, needle, [message])\n   *\n   * Asserts that `haystack` includes `needle`. Can be used to assert the\n   * inclusion of a value in an array, a substring in a string, or a subset of\n   * properties in an object.\n   *\n   *     assert.include([1,2,3], 2, 'array contains value');\n   *     assert.include('foobar', 'foo', 'string contains substring');\n   *     assert.include({ foo: 'bar', hello: 'universe' }, { foo: 'bar' }, 'object contains property');\n   *\n   * Strict equality (===) is used. When asserting the inclusion of a value in\n   * an array, the array is searched for an element that's strictly equal to the\n   * given value. When asserting a subset of properties in an object, the object\n   * is searched for the given property keys, checking that each one is present\n   * and strictly equal to the given property value. For instance:\n   *\n   *     var obj1 = {a: 1}\n   *       , obj2 = {b: 2};\n   *     assert.include([obj1, obj2], obj1);\n   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1});\n   *     assert.include({foo: obj1, bar: obj2}, {foo: obj1, bar: obj2});\n   *\n   * @name include\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.include = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.include, true).include(inc);\n  };\n\n  /**\n   * ### .notInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` does not include `needle`. Can be used to assert\n   * the absence of a value in an array, a substring in a string, or a subset of\n   * properties in an object.\n   *\n   *     assert.notInclude([1,2,3], 4, \"array doesn't contain value\");\n   *     assert.notInclude('foobar', 'baz', \"string doesn't contain substring\");\n   *     assert.notInclude({ foo: 'bar', hello: 'universe' }, { foo: 'baz' }, 'object doesn't contain property');\n   *\n   * Strict equality (===) is used. When asserting the absence of a value in an\n   * array, the array is searched to confirm the absence of an element that's\n   * strictly equal to the given value. When asserting a subset of properties in\n   * an object, the object is searched to confirm that at least one of the given\n   * property keys is either not present or not strictly equal to the given\n   * property value. For instance:\n   *\n   *     var obj1 = {a: 1}\n   *       , obj2 = {b: 2};\n   *     assert.notInclude([obj1, obj2], {a: 1});\n   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\n   *     assert.notInclude({foo: obj1, bar: obj2}, {foo: obj1, bar: {b: 2}});\n   *\n   * @name notInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notInclude, true).not.include(inc);\n  };\n\n  /**\n   * ### .deepInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` includes `needle`. Can be used to assert the\n   * inclusion of a value in an array or a subset of properties in an object.\n   * Deep equality is used.\n   *\n   *     var obj1 = {a: 1}\n   *       , obj2 = {b: 2};\n   *     assert.deepInclude([obj1, obj2], {a: 1});\n   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}});\n   *     assert.deepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 2}});\n   *\n   * @name deepInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.deepInclude, true).deep.include(inc);\n  };\n\n  /**\n   * ### .notDeepInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` does not include `needle`. Can be used to assert\n   * the absence of a value in an array or a subset of properties in an object.\n   * Deep equality is used.\n   *\n   *     var obj1 = {a: 1}\n   *       , obj2 = {b: 2};\n   *     assert.notDeepInclude([obj1, obj2], {a: 9});\n   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 9}});\n   *     assert.notDeepInclude({foo: obj1, bar: obj2}, {foo: {a: 1}, bar: {b: 9}});\n   *\n   * @name notDeepInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notDeepInclude, true).not.deep.include(inc);\n  };\n\n  /**\n   * ### .nestedInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the inclusion of a subset of properties in an\n   * object.\n   * Enables the use of dot- and bracket-notation for referencing nested\n   * properties.\n   * '[]' and '.' in property names can be escaped using double backslashes.\n   *\n   *     assert.nestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.[b]': 'x'});\n   *     assert.nestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'x'});\n   *\n   * @name nestedInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.nestedInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.nestedInclude, true).nested.include(inc);\n  };\n\n  /**\n   * ### .notNestedInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' does not include 'needle'.\n   * Can be used to assert the absence of a subset of properties in an\n   * object.\n   * Enables the use of dot- and bracket-notation for referencing nested\n   * properties.\n   * '[]' and '.' in property names can be escaped using double backslashes.\n   *\n   *     assert.notNestedInclude({'.a': {'b': 'x'}}, {'\\\\.a.b': 'y'});\n   *     assert.notNestedInclude({'a': {'[b]': 'x'}}, {'a.\\\\[b\\\\]': 'y'});\n   *\n   * @name notNestedInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notNestedInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notNestedInclude, true)\n      .not.nested.include(inc);\n  };\n\n  /**\n   * ### .deepNestedInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the inclusion of a subset of properties in an\n   * object while checking for deep equality.\n   * Enables the use of dot- and bracket-notation for referencing nested\n   * properties.\n   * '[]' and '.' in property names can be escaped using double backslashes.\n   *\n   *     assert.deepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {x: 1}});\n   *     assert.deepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {x: 1}});\n   *\n   * @name deepNestedInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepNestedInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.deepNestedInclude, true)\n      .deep.nested.include(inc);\n  };\n\n  /**\n   * ### .notDeepNestedInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' does not include 'needle'.\n   * Can be used to assert the absence of a subset of properties in an\n   * object while checking for deep equality.\n   * Enables the use of dot- and bracket-notation for referencing nested\n   * properties.\n   * '[]' and '.' in property names can be escaped using double backslashes.\n   *\n   *     assert.notDeepNestedInclude({a: {b: [{x: 1}]}}, {'a.b[0]': {y: 1}})\n   *     assert.notDeepNestedInclude({'.a': {'[b]': {x: 1}}}, {'\\\\.a.\\\\[b\\\\]': {y: 2}});\n   *\n   * @name notDeepNestedInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepNestedInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.notDeepNestedInclude, true)\n      .not.deep.nested.include(inc);\n  };\n\n  /**\n   * ### .ownInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the inclusion of a subset of properties in an\n   * object while ignoring inherited properties.\n   *\n   *     assert.ownInclude({ a: 1 }, { a: 1 });\n   *\n   * @name ownInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.ownInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.ownInclude, true).own.include(inc);\n  };\n\n  /**\n   * ### .notOwnInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the absence of a subset of properties in an\n   * object while ignoring inherited properties.\n   *\n   *     Object.prototype.b = 2;\n   *\n   *     assert.notOwnInclude({ a: 1 }, { b: 2 });\n   *\n   * @name notOwnInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notOwnInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.notOwnInclude, true).not.own.include(inc);\n  };\n\n  /**\n   * ### .deepOwnInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the inclusion of a subset of properties in an\n   * object while ignoring inherited properties and checking for deep equality.\n   *\n   *      assert.deepOwnInclude({a: {b: 2}}, {a: {b: 2}});\n   *\n   * @name deepOwnInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepOwnInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.deepOwnInclude, true)\n      .deep.own.include(inc);\n  };\n\n   /**\n   * ### .notDeepOwnInclude(haystack, needle, [message])\n   *\n   * Asserts that 'haystack' includes 'needle'.\n   * Can be used to assert the absence of a subset of properties in an\n   * object while ignoring inherited properties and checking for deep equality.\n   *\n   *      assert.notDeepOwnInclude({a: {b: 2}}, {a: {c: 3}});\n   *\n   * @name notDeepOwnInclude\n   * @param {Object} haystack\n   * @param {Object} needle\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepOwnInclude = function(exp, inc, msg) {\n    new Assertion(exp, msg, assert.notDeepOwnInclude, true)\n      .not.deep.own.include(inc);\n  };\n\n  /**\n   * ### .match(value, regexp, [message])\n   *\n   * Asserts that `value` matches the regular expression `regexp`.\n   *\n   *     assert.match('foobar', /^foo/, 'regexp matches');\n   *\n   * @name match\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.match = function (exp, re, msg) {\n    new Assertion(exp, msg, assert.match, true).to.match(re);\n  };\n\n  /**\n   * ### .notMatch(value, regexp, [message])\n   *\n   * Asserts that `value` does not match the regular expression `regexp`.\n   *\n   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\n   *\n   * @name notMatch\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notMatch = function (exp, re, msg) {\n    new Assertion(exp, msg, assert.notMatch, true).to.not.match(re);\n  };\n\n  /**\n   * ### .property(object, property, [message])\n   *\n   * Asserts that `object` has a direct or inherited property named by\n   * `property`.\n   *\n   *     assert.property({ tea: { green: 'matcha' }}, 'tea');\n   *     assert.property({ tea: { green: 'matcha' }}, 'toString');\n   *\n   * @name property\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.property = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.property, true).to.have.property(prop);\n  };\n\n  /**\n   * ### .notProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a direct or inherited property named\n   * by `property`.\n   *\n   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\n   *\n   * @name notProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.notProperty, true)\n      .to.not.have.property(prop);\n  };\n\n  /**\n   * ### .propertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a direct or inherited property named by\n   * `property` with a value given by `value`. Uses a strict equality check\n   * (===).\n   *\n   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\n   *\n   * @name propertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.propertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.propertyVal, true)\n      .to.have.property(prop, val);\n  };\n\n  /**\n   * ### .notPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a direct or inherited property named\n   * by `property` with value given by `value`. Uses a strict equality check\n   * (===).\n   *\n   *     assert.notPropertyVal({ tea: 'is good' }, 'tea', 'is bad');\n   *     assert.notPropertyVal({ tea: 'is good' }, 'coffee', 'is good');\n   *\n   * @name notPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.notPropertyVal, true)\n      .to.not.have.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a direct or inherited property named by\n   * `property` with a value given by `value`. Uses a deep equality check.\n   *\n   *     assert.deepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });\n   *\n   * @name deepPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.deepPropertyVal, true)\n      .to.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .notDeepPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a direct or inherited property named\n   * by `property` with value given by `value`. Uses a deep equality check.\n   *\n   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\n   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\n   *     assert.notDeepPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });\n   *\n   * @name notDeepPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.notDeepPropertyVal, true)\n      .to.not.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .ownProperty(object, property, [message])\n   *\n   * Asserts that `object` has a direct property named by `property`. Inherited\n   * properties aren't checked.\n   *\n   *     assert.ownProperty({ tea: { green: 'matcha' }}, 'tea');\n   *\n   * @name ownProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.ownProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.ownProperty, true)\n      .to.have.own.property(prop);\n  };\n\n  /**\n   * ### .notOwnProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a direct property named by\n   * `property`. Inherited properties aren't checked.\n   *\n   *     assert.notOwnProperty({ tea: { green: 'matcha' }}, 'coffee');\n   *     assert.notOwnProperty({}, 'toString');\n   *\n   * @name notOwnProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notOwnProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.notOwnProperty, true)\n      .to.not.have.own.property(prop);\n  };\n\n  /**\n   * ### .ownPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a direct property named by `property` and a value\n   * equal to the provided `value`. Uses a strict equality check (===).\n   * Inherited properties aren't checked.\n   *\n   *     assert.ownPropertyVal({ coffee: 'is good'}, 'coffee', 'is good');\n   *\n   * @name ownPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.ownPropertyVal = function (obj, prop, value, msg) {\n    new Assertion(obj, msg, assert.ownPropertyVal, true)\n      .to.have.own.property(prop, value);\n  };\n\n  /**\n   * ### .notOwnPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a direct property named by `property`\n   * with a value equal to the provided `value`. Uses a strict equality check\n   * (===). Inherited properties aren't checked.\n   *\n   *     assert.notOwnPropertyVal({ tea: 'is better'}, 'tea', 'is worse');\n   *     assert.notOwnPropertyVal({}, 'toString', Object.prototype.toString);\n   *\n   * @name notOwnPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notOwnPropertyVal = function (obj, prop, value, msg) {\n    new Assertion(obj, msg, assert.notOwnPropertyVal, true)\n      .to.not.have.own.property(prop, value);\n  };\n\n  /**\n   * ### .deepOwnPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a direct property named by `property` and a value\n   * equal to the provided `value`. Uses a deep equality check. Inherited\n   * properties aren't checked.\n   *\n   *     assert.deepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'matcha' });\n   *\n   * @name deepOwnPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepOwnPropertyVal = function (obj, prop, value, msg) {\n    new Assertion(obj, msg, assert.deepOwnPropertyVal, true)\n      .to.have.deep.own.property(prop, value);\n  };\n\n  /**\n   * ### .notDeepOwnPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a direct property named by `property`\n   * with a value equal to the provided `value`. Uses a deep equality check.\n   * Inherited properties aren't checked.\n   *\n   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { black: 'matcha' });\n   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'tea', { green: 'oolong' });\n   *     assert.notDeepOwnPropertyVal({ tea: { green: 'matcha' } }, 'coffee', { green: 'matcha' });\n   *     assert.notDeepOwnPropertyVal({}, 'toString', Object.prototype.toString);\n   *\n   * @name notDeepOwnPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepOwnPropertyVal = function (obj, prop, value, msg) {\n    new Assertion(obj, msg, assert.notDeepOwnPropertyVal, true)\n      .to.not.have.deep.own.property(prop, value);\n  };\n\n  /**\n   * ### .nestedProperty(object, property, [message])\n   *\n   * Asserts that `object` has a direct or inherited property named by\n   * `property`, which can be a string using dot- and bracket-notation for\n   * nested reference.\n   *\n   *     assert.nestedProperty({ tea: { green: 'matcha' }}, 'tea.green');\n   *\n   * @name nestedProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.nestedProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.nestedProperty, true)\n      .to.have.nested.property(prop);\n  };\n\n  /**\n   * ### .notNestedProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`, which\n   * can be a string using dot- and bracket-notation for nested reference. The\n   * property cannot exist on the object nor anywhere in its prototype chain.\n   *\n   *     assert.notNestedProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\n   *\n   * @name notNestedProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notNestedProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg, assert.notNestedProperty, true)\n      .to.not.have.nested.property(prop);\n  };\n\n  /**\n   * ### .nestedPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`. `property` can use dot- and bracket-notation for nested\n   * reference. Uses a strict equality check (===).\n   *\n   *     assert.nestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\n   *\n   * @name nestedPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.nestedPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.nestedPropertyVal, true)\n      .to.have.nested.property(prop, val);\n  };\n\n  /**\n   * ### .notNestedPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property` with\n   * value given by `value`. `property` can use dot- and bracket-notation for\n   * nested reference. Uses a strict equality check (===).\n   *\n   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n   *     assert.notNestedPropertyVal({ tea: { green: 'matcha' }}, 'coffee.green', 'matcha');\n   *\n   * @name notNestedPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notNestedPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.notNestedPropertyVal, true)\n      .to.not.have.nested.property(prop, val);\n  };\n\n  /**\n   * ### .deepNestedPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with a value given\n   * by `value`. `property` can use dot- and bracket-notation for nested\n   * reference. Uses a deep equality check.\n   *\n   *     assert.deepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yum' });\n   *\n   * @name deepNestedPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.deepNestedPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.deepNestedPropertyVal, true)\n      .to.have.deep.nested.property(prop, val);\n  };\n\n  /**\n   * ### .notDeepNestedPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property` with\n   * value given by `value`. `property` can use dot- and bracket-notation for\n   * nested reference. Uses a deep equality check.\n   *\n   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { oolong: 'yum' });\n   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.green', { matcha: 'yuck' });\n   *     assert.notDeepNestedPropertyVal({ tea: { green: { matcha: 'yum' } } }, 'tea.black', { matcha: 'yum' });\n   *\n   * @name notDeepNestedPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notDeepNestedPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg, assert.notDeepNestedPropertyVal, true)\n      .to.not.have.deep.nested.property(prop, val);\n  }\n\n  /**\n   * ### .lengthOf(object, length, [message])\n   *\n   * Asserts that `object` has a `length` or `size` with the expected value.\n   *\n   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\n   *     assert.lengthOf('foobar', 6, 'string has length of 6');\n   *     assert.lengthOf(new Set([1,2,3]), 3, 'set has size of 3');\n   *     assert.lengthOf(new Map([['a',1],['b',2],['c',3]]), 3, 'map has size of 3');\n   *\n   * @name lengthOf\n   * @param {Mixed} object\n   * @param {Number} length\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.lengthOf = function (exp, len, msg) {\n    new Assertion(exp, msg, assert.lengthOf, true).to.have.lengthOf(len);\n  };\n\n  /**\n   * ### .hasAnyKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has at least one of the `keys` provided.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'iDontExist', 'baz']);\n   *     assert.hasAnyKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, iDontExist: 99, baz: 1337});\n   *     assert.hasAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n   *     assert.hasAnyKeys(new Set([{foo: 'bar'}, 'anotherKey']), [{foo: 'bar'}, 'anotherKey']);\n   *\n   * @name hasAnyKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.hasAnyKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.hasAnyKeys, true).to.have.any.keys(keys);\n  }\n\n  /**\n   * ### .hasAllKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has all and only all of the `keys` provided.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\n   *     assert.hasAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337]);\n   *     assert.hasAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n   *     assert.hasAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);\n   *\n   * @name hasAllKeys\n   * @param {Mixed} object\n   * @param {String[]} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.hasAllKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.hasAllKeys, true).to.have.all.keys(keys);\n  }\n\n  /**\n   * ### .containsAllKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has all of the `keys` provided but may have more keys not listed.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'baz']);\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, ['foo', 'bar', 'baz']);\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, baz: 1337});\n   *     assert.containsAllKeys({foo: 1, bar: 2, baz: 3}, {foo: 30, bar: 99, baz: 1337});\n   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}]);\n   *     assert.containsAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{foo: 1}, 'key']);\n   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}]);\n   *     assert.containsAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{foo: 'bar'}, 'anotherKey']);\n   *\n   * @name containsAllKeys\n   * @param {Mixed} object\n   * @param {String[]} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.containsAllKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.containsAllKeys, true)\n      .to.contain.all.keys(keys);\n  }\n\n  /**\n   * ### .doesNotHaveAnyKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has none of the `keys` provided.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\n   *     assert.doesNotHaveAnyKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\n   *     assert.doesNotHaveAnyKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\n   *     assert.doesNotHaveAnyKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);\n   *\n   * @name doesNotHaveAnyKeys\n   * @param {Mixed} object\n   * @param {String[]} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotHaveAnyKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.doesNotHaveAnyKeys, true)\n      .to.not.have.any.keys(keys);\n  }\n\n  /**\n   * ### .doesNotHaveAllKeys(object, [keys], [message])\n   *\n   * Asserts that `object` does not have at least one of the `keys` provided.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, ['one', 'two', 'example']);\n   *     assert.doesNotHaveAllKeys({foo: 1, bar: 2, baz: 3}, {one: 1, two: 2, example: 'foo'});\n   *     assert.doesNotHaveAllKeys(new Map([[{foo: 1}, 'bar'], ['key', 'value']]), [{one: 'two'}, 'example']);\n   *     assert.doesNotHaveAllKeys(new Set([{foo: 'bar'}, 'anotherKey'], [{one: 'two'}, 'example']);\n   *\n   * @name doesNotHaveAllKeys\n   * @param {Mixed} object\n   * @param {String[]} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotHaveAllKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.doesNotHaveAllKeys, true)\n      .to.not.have.all.keys(keys);\n  }\n\n  /**\n   * ### .hasAnyDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has at least one of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\n   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), [{one: 'one'}, {two: 'two'}]);\n   *     assert.hasAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\n   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {three: 'three'}]);\n   *     assert.hasAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\n   *\n   * @name doesNotHaveAllKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.hasAnyDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.hasAnyDeepKeys, true)\n      .to.have.any.deep.keys(keys);\n  }\n\n /**\n   * ### .hasAllDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has all and only all of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne']]), {one: 'one'});\n   *     assert.hasAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n   *     assert.hasAllDeepKeys(new Set([{one: 'one'}]), {one: 'one'});\n   *     assert.hasAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\n   *\n   * @name hasAllDeepKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.hasAllDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.hasAllDeepKeys, true)\n      .to.have.all.deep.keys(keys);\n  }\n\n /**\n   * ### .containsAllDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` contains all of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {one: 'one'});\n   *     assert.containsAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{one: 'one'}, {two: 'two'}]);\n   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {one: 'one'});\n   *     assert.containsAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {two: 'two'}]);\n   *\n   * @name containsAllDeepKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.containsAllDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.containsAllDeepKeys, true)\n      .to.contain.all.deep.keys(keys);\n  }\n\n /**\n   * ### .doesNotHaveAnyDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` has none of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\n   *     assert.doesNotHaveAnyDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);\n   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\n   *     assert.doesNotHaveAnyDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{twenty: 'twenty'}, {fifty: 'fifty'}]);\n   *\n   * @name doesNotHaveAnyDeepKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotHaveAnyDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.doesNotHaveAnyDeepKeys, true)\n      .to.not.have.any.deep.keys(keys);\n  }\n\n /**\n   * ### .doesNotHaveAllDeepKeys(object, [keys], [message])\n   *\n   * Asserts that `object` does not have at least one of the `keys` provided.\n   * Since Sets and Maps can have objects as keys you can use this assertion to perform\n   * a deep comparison.\n   * You can also provide a single object instead of a `keys` array and its keys\n   * will be used as the expected set of keys.\n   *\n   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [1, 2]]), {thisDoesNot: 'exist'});\n   *     assert.doesNotHaveAllDeepKeys(new Map([[{one: 'one'}, 'valueOne'], [{two: 'two'}, 'valueTwo']]), [{twenty: 'twenty'}, {one: 'one'}]);\n   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), {twenty: 'twenty'});\n   *     assert.doesNotHaveAllDeepKeys(new Set([{one: 'one'}, {two: 'two'}]), [{one: 'one'}, {fifty: 'fifty'}]);\n   *\n   * @name doesNotHaveAllDeepKeys\n   * @param {Mixed} object\n   * @param {Array|Object} keys\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotHaveAllDeepKeys = function (obj, keys, msg) {\n    new Assertion(obj, msg, assert.doesNotHaveAllDeepKeys, true)\n      .to.not.have.all.deep.keys(keys);\n  }\n\n /**\n   * ### .throws(fn, [errorLike/string/regexp], [string/regexp], [message])\n   *\n   * If `errorLike` is an `Error` constructor, asserts that `fn` will throw an error that is an\n   * instance of `errorLike`.\n   * If `errorLike` is an `Error` instance, asserts that the error thrown is the same\n   * instance as `errorLike`.\n   * If `errMsgMatcher` is provided, it also asserts that the error thrown will have a\n   * message matching `errMsgMatcher`.\n   *\n   *     assert.throws(fn, 'Error thrown must have this msg');\n   *     assert.throws(fn, /Error thrown must have a msg that matches this/);\n   *     assert.throws(fn, ReferenceError);\n   *     assert.throws(fn, errorInstance);\n   *     assert.throws(fn, ReferenceError, 'Error thrown must be a ReferenceError and have this msg');\n   *     assert.throws(fn, errorInstance, 'Error thrown must be the same errorInstance and have this msg');\n   *     assert.throws(fn, ReferenceError, /Error thrown must be a ReferenceError and match this/);\n   *     assert.throws(fn, errorInstance, /Error thrown must be the same errorInstance and match this/);\n   *\n   * @name throws\n   * @alias throw\n   * @alias Throw\n   * @param {Function} fn\n   * @param {ErrorConstructor|Error} errorLike\n   * @param {RegExp|String} errMsgMatcher\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.throws = function (fn, errorLike, errMsgMatcher, msg) {\n    if ('string' === typeof errorLike || errorLike instanceof RegExp) {\n      errMsgMatcher = errorLike;\n      errorLike = null;\n    }\n\n    var assertErr = new Assertion(fn, msg, assert.throws, true)\n      .to.throw(errorLike, errMsgMatcher);\n    return flag(assertErr, 'object');\n  };\n\n  /**\n   * ### .doesNotThrow(fn, [errorLike/string/regexp], [string/regexp], [message])\n   *\n   * If `errorLike` is an `Error` constructor, asserts that `fn` will _not_ throw an error that is an\n   * instance of `errorLike`.\n   * If `errorLike` is an `Error` instance, asserts that the error thrown is _not_ the same\n   * instance as `errorLike`.\n   * If `errMsgMatcher` is provided, it also asserts that the error thrown will _not_ have a\n   * message matching `errMsgMatcher`.\n   *\n   *     assert.doesNotThrow(fn, 'Any Error thrown must not have this message');\n   *     assert.doesNotThrow(fn, /Any Error thrown must not match this/);\n   *     assert.doesNotThrow(fn, Error);\n   *     assert.doesNotThrow(fn, errorInstance);\n   *     assert.doesNotThrow(fn, Error, 'Error must not have this message');\n   *     assert.doesNotThrow(fn, errorInstance, 'Error must not have this message');\n   *     assert.doesNotThrow(fn, Error, /Error must not match this/);\n   *     assert.doesNotThrow(fn, errorInstance, /Error must not match this/);\n   *\n   * @name doesNotThrow\n   * @param {Function} fn\n   * @param {ErrorConstructor} errorLike\n   * @param {RegExp|String} errMsgMatcher\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotThrow = function (fn, errorLike, errMsgMatcher, msg) {\n    if ('string' === typeof errorLike || errorLike instanceof RegExp) {\n      errMsgMatcher = errorLike;\n      errorLike = null;\n    }\n\n    new Assertion(fn, msg, assert.doesNotThrow, true)\n      .to.not.throw(errorLike, errMsgMatcher);\n  };\n\n  /**\n   * ### .operator(val1, operator, val2, [message])\n   *\n   * Compares two values using `operator`.\n   *\n   *     assert.operator(1, '<', 2, 'everything is ok');\n   *     assert.operator(1, '>', 2, 'this will fail');\n   *\n   * @name operator\n   * @param {Mixed} val1\n   * @param {String} operator\n   * @param {Mixed} val2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.operator = function (val, operator, val2, msg) {\n    var ok;\n    switch(operator) {\n      case '==':\n        ok = val == val2;\n        break;\n      case '===':\n        ok = val === val2;\n        break;\n      case '>':\n        ok = val > val2;\n        break;\n      case '>=':\n        ok = val >= val2;\n        break;\n      case '<':\n        ok = val < val2;\n        break;\n      case '<=':\n        ok = val <= val2;\n        break;\n      case '!=':\n        ok = val != val2;\n        break;\n      case '!==':\n        ok = val !== val2;\n        break;\n      default:\n        msg = msg ? msg + ': ' : msg;\n        throw new chai.AssertionError(\n          msg + 'Invalid operator \"' + operator + '\"',\n          undefined,\n          assert.operator\n        );\n    }\n    var test = new Assertion(ok, msg, assert.operator, true);\n    test.assert(\n        true === flag(test, 'object')\n      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\n      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\n  };\n\n  /**\n   * ### .closeTo(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name closeTo\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.closeTo = function (act, exp, delta, msg) {\n    new Assertion(act, msg, assert.closeTo, true).to.be.closeTo(exp, delta);\n  };\n\n  /**\n   * ### .approximately(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name approximately\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.approximately = function (act, exp, delta, msg) {\n    new Assertion(act, msg, assert.approximately, true)\n      .to.be.approximately(exp, delta);\n  };\n\n  /**\n   * ### .sameMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members in any order. Uses a\n   * strict equality check (===).\n   *\n   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\n   *\n   * @name sameMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.sameMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.sameMembers, true)\n      .to.have.same.members(set2);\n  }\n\n  /**\n   * ### .notSameMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` don't have the same members in any order.\n   * Uses a strict equality check (===).\n   *\n   *     assert.notSameMembers([ 1, 2, 3 ], [ 5, 1, 3 ], 'not same members');\n   *\n   * @name notSameMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notSameMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.notSameMembers, true)\n      .to.not.have.same.members(set2);\n  }\n\n  /**\n   * ### .sameDeepMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members in any order. Uses a\n   * deep equality check.\n   *\n   *     assert.sameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { c: 3 }], 'same deep members');\n   *\n   * @name sameDeepMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.sameDeepMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.sameDeepMembers, true)\n      .to.have.same.deep.members(set2);\n  }\n\n  /**\n   * ### .notSameDeepMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` don't have the same members in any order.\n   * Uses a deep equality check.\n   *\n   *     assert.notSameDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [{ b: 2 }, { a: 1 }, { f: 5 }], 'not same deep members');\n   *\n   * @name notSameDeepMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notSameDeepMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.notSameDeepMembers, true)\n      .to.not.have.same.deep.members(set2);\n  }\n\n  /**\n   * ### .sameOrderedMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members in the same order.\n   * Uses a strict equality check (===).\n   *\n   *     assert.sameOrderedMembers([ 1, 2, 3 ], [ 1, 2, 3 ], 'same ordered members');\n   *\n   * @name sameOrderedMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.sameOrderedMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.sameOrderedMembers, true)\n      .to.have.same.ordered.members(set2);\n  }\n\n  /**\n   * ### .notSameOrderedMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` don't have the same members in the same\n   * order. Uses a strict equality check (===).\n   *\n   *     assert.notSameOrderedMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'not same ordered members');\n   *\n   * @name notSameOrderedMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notSameOrderedMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.notSameOrderedMembers, true)\n      .to.not.have.same.ordered.members(set2);\n  }\n\n  /**\n   * ### .sameDeepOrderedMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members in the same order.\n   * Uses a deep equality check.\n   *\n   * assert.sameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { c: 3 } ], 'same deep ordered members');\n   *\n   * @name sameDeepOrderedMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.sameDeepOrderedMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.sameDeepOrderedMembers, true)\n      .to.have.same.deep.ordered.members(set2);\n  }\n\n  /**\n   * ### .notSameDeepOrderedMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` don't have the same members in the same\n   * order. Uses a deep equality check.\n   *\n   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 }, { z: 5 } ], 'not same deep ordered members');\n   * assert.notSameDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { c: 3 } ], 'not same deep ordered members');\n   *\n   * @name notSameDeepOrderedMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notSameDeepOrderedMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg, assert.notSameDeepOrderedMembers, true)\n      .to.not.have.same.deep.ordered.members(set2);\n  }\n\n  /**\n   * ### .includeMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset` in any order. Uses a\n   * strict equality check (===). Duplicates are ignored.\n   *\n   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1, 2 ], 'include members');\n   *\n   * @name includeMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.includeMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.includeMembers, true)\n      .to.include.members(subset);\n  }\n\n  /**\n   * ### .notIncludeMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` isn't included in `superset` in any order. Uses a\n   * strict equality check (===). Duplicates are ignored.\n   *\n   *     assert.notIncludeMembers([ 1, 2, 3 ], [ 5, 1 ], 'not include members');\n   *\n   * @name notIncludeMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notIncludeMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.notIncludeMembers, true)\n      .to.not.include.members(subset);\n  }\n\n  /**\n   * ### .includeDeepMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset` in any order. Uses a deep\n   * equality check. Duplicates are ignored.\n   *\n   *     assert.includeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 }, { b: 2 } ], 'include deep members');\n   *\n   * @name includeDeepMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.includeDeepMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.includeDeepMembers, true)\n      .to.include.deep.members(subset);\n  }\n\n  /**\n   * ### .notIncludeDeepMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` isn't included in `superset` in any order. Uses a\n   * deep equality check. Duplicates are ignored.\n   *\n   *     assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');\n   *\n   * @name notIncludeDeepMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notIncludeDeepMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.notIncludeDeepMembers, true)\n      .to.not.include.deep.members(subset);\n  }\n\n  /**\n   * ### .includeOrderedMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset` in the same order\n   * beginning with the first element in `superset`. Uses a strict equality\n   * check (===).\n   *\n   *     assert.includeOrderedMembers([ 1, 2, 3 ], [ 1, 2 ], 'include ordered members');\n   *\n   * @name includeOrderedMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.includeOrderedMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.includeOrderedMembers, true)\n      .to.include.ordered.members(subset);\n  }\n\n  /**\n   * ### .notIncludeOrderedMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` isn't included in `superset` in the same order\n   * beginning with the first element in `superset`. Uses a strict equality\n   * check (===).\n   *\n   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 1 ], 'not include ordered members');\n   *     assert.notIncludeOrderedMembers([ 1, 2, 3 ], [ 2, 3 ], 'not include ordered members');\n   *\n   * @name notIncludeOrderedMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notIncludeOrderedMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.notIncludeOrderedMembers, true)\n      .to.not.include.ordered.members(subset);\n  }\n\n  /**\n   * ### .includeDeepOrderedMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset` in the same order\n   * beginning with the first element in `superset`. Uses a deep equality\n   * check.\n   *\n   *     assert.includeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { b: 2 } ], 'include deep ordered members');\n   *\n   * @name includeDeepOrderedMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.includeDeepOrderedMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.includeDeepOrderedMembers, true)\n      .to.include.deep.ordered.members(subset);\n  }\n\n  /**\n   * ### .notIncludeDeepOrderedMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` isn't included in `superset` in the same order\n   * beginning with the first element in `superset`. Uses a deep equality\n   * check.\n   *\n   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { a: 1 }, { f: 5 } ], 'not include deep ordered members');\n   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { a: 1 } ], 'not include deep ordered members');\n   *     assert.notIncludeDeepOrderedMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { c: 3 } ], 'not include deep ordered members');\n   *\n   * @name notIncludeDeepOrderedMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.notIncludeDeepOrderedMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg, assert.notIncludeDeepOrderedMembers, true)\n      .to.not.include.deep.ordered.members(subset);\n  }\n\n  /**\n   * ### .oneOf(inList, list, [message])\n   *\n   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.\n   *\n   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');\n   *\n   * @name oneOf\n   * @param {*} inList\n   * @param {Array<*>} list\n   * @param {String} message\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.oneOf = function (inList, list, msg) {\n    new Assertion(inList, msg, assert.oneOf, true).to.be.oneOf(list);\n  }\n\n  /**\n   * ### .changes(function, object, property, [message])\n   *\n   * Asserts that a function changes the value of a property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 22 };\n   *     assert.changes(fn, obj, 'val');\n   *\n   * @name changes\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.changes = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.changes, true).to.change(obj, prop);\n  }\n\n   /**\n   * ### .changesBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function changes the value of a property by an amount (delta).\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 2 };\n   *     assert.changesBy(fn, obj, 'val', 2);\n   *\n   * @name changesBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.changesBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.changesBy, true)\n      .to.change(obj, prop).by(delta);\n  }\n\n   /**\n   * ### .doesNotChange(function, object, property, [message])\n   *\n   * Asserts that a function does not change the value of a property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { console.log('foo'); };\n   *     assert.doesNotChange(fn, obj, 'val');\n   *\n   * @name doesNotChange\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotChange = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.doesNotChange, true)\n      .to.not.change(obj, prop);\n  }\n\n  /**\n   * ### .changesButNotBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function does not change the value of a property or of a function's return value by an amount (delta)\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 10 };\n   *     assert.changesButNotBy(fn, obj, 'val', 5);\n   *\n   * @name changesButNotBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.changesButNotBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.changesButNotBy, true)\n      .to.change(obj, prop).but.not.by(delta);\n  }\n\n  /**\n   * ### .increases(function, object, property, [message])\n   *\n   * Asserts that a function increases a numeric object property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 13 };\n   *     assert.increases(fn, obj, 'val');\n   *\n   * @name increases\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.increases = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.increases, true)\n      .to.increase(obj, prop);\n  }\n\n  /**\n   * ### .increasesBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 10 };\n   *     assert.increasesBy(fn, obj, 'val', 10);\n   *\n   * @name increasesBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.increasesBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.increasesBy, true)\n      .to.increase(obj, prop).by(delta);\n  }\n\n  /**\n   * ### .doesNotIncrease(function, object, property, [message])\n   *\n   * Asserts that a function does not increase a numeric object property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 8 };\n   *     assert.doesNotIncrease(fn, obj, 'val');\n   *\n   * @name doesNotIncrease\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotIncrease = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.doesNotIncrease, true)\n      .to.not.increase(obj, prop);\n  }\n\n  /**\n   * ### .increasesButNotBy(function, object, property, [message])\n   *\n   * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     assert.increasesButNotBy(fn, obj, 'val', 10);\n   *\n   * @name increasesButNotBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.increasesButNotBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.increasesButNotBy, true)\n      .to.increase(obj, prop).but.not.by(delta);\n  }\n\n  /**\n   * ### .decreases(function, object, property, [message])\n   *\n   * Asserts that a function decreases a numeric object property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.decreases(fn, obj, 'val');\n   *\n   * @name decreases\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.decreases = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.decreases, true)\n      .to.decrease(obj, prop);\n  }\n\n  /**\n   * ### .decreasesBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val -= 5 };\n   *     assert.decreasesBy(fn, obj, 'val', 5);\n   *\n   * @name decreasesBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.decreasesBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.decreasesBy, true)\n      .to.decrease(obj, prop).by(delta);\n  }\n\n  /**\n   * ### .doesNotDecrease(function, object, property, [message])\n   *\n   * Asserts that a function does not decreases a numeric object property.\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     assert.doesNotDecrease(fn, obj, 'val');\n   *\n   * @name doesNotDecrease\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotDecrease = function (fn, obj, prop, msg) {\n    if (arguments.length === 3 && typeof obj === 'function') {\n      msg = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.doesNotDecrease, true)\n      .to.not.decrease(obj, prop);\n  }\n\n  /**\n   * ### .doesNotDecreaseBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.doesNotDecreaseBy(fn, obj, 'val', 1);\n   *\n   * @name doesNotDecrease\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.doesNotDecreaseBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    return new Assertion(fn, msg, assert.doesNotDecreaseBy, true)\n      .to.not.decrease(obj, prop).by(delta);\n  }\n\n  /**\n   * ### .decreasesButNotBy(function, object, property, delta, [message])\n   *\n   * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.decreasesButNotBy(fn, obj, 'val', 1);\n   *\n   * @name decreasesButNotBy\n   * @param {Function} modifier function\n   * @param {Object} object or getter function\n   * @param {String} property name _optional_\n   * @param {Number} change amount (delta)\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.decreasesButNotBy = function (fn, obj, prop, delta, msg) {\n    if (arguments.length === 4 && typeof obj === 'function') {\n      var tmpMsg = delta;\n      delta = prop;\n      msg = tmpMsg;\n    } else if (arguments.length === 3) {\n      delta = prop;\n      prop = null;\n    }\n\n    new Assertion(fn, msg, assert.decreasesButNotBy, true)\n      .to.decrease(obj, prop).but.not.by(delta);\n  }\n\n  /*!\n   * ### .ifError(object)\n   *\n   * Asserts if value is not a false value, and throws if it is a true value.\n   * This is added to allow for chai to be a drop-in replacement for Node's\n   * assert class.\n   *\n   *     var err = new Error('I am a custom error');\n   *     assert.ifError(err); // Rethrows err!\n   *\n   * @name ifError\n   * @param {Object} object\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.ifError = function (val) {\n    if (val) {\n      throw(val);\n    }\n  };\n\n  /**\n   * ### .isExtensible(object)\n   *\n   * Asserts that `object` is extensible (can have new properties added to it).\n   *\n   *     assert.isExtensible({});\n   *\n   * @name isExtensible\n   * @alias extensible\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isExtensible = function (obj, msg) {\n    new Assertion(obj, msg, assert.isExtensible, true).to.be.extensible;\n  };\n\n  /**\n   * ### .isNotExtensible(object)\n   *\n   * Asserts that `object` is _not_ extensible.\n   *\n   *     var nonExtensibleObject = Object.preventExtensions({});\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.freeze({});\n   *\n   *     assert.isNotExtensible(nonExtensibleObject);\n   *     assert.isNotExtensible(sealedObject);\n   *     assert.isNotExtensible(frozenObject);\n   *\n   * @name isNotExtensible\n   * @alias notExtensible\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotExtensible = function (obj, msg) {\n    new Assertion(obj, msg, assert.isNotExtensible, true).to.not.be.extensible;\n  };\n\n  /**\n   * ### .isSealed(object)\n   *\n   * Asserts that `object` is sealed (cannot have new properties added to it\n   * and its existing properties cannot be removed).\n   *\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.seal({});\n   *\n   *     assert.isSealed(sealedObject);\n   *     assert.isSealed(frozenObject);\n   *\n   * @name isSealed\n   * @alias sealed\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isSealed = function (obj, msg) {\n    new Assertion(obj, msg, assert.isSealed, true).to.be.sealed;\n  };\n\n  /**\n   * ### .isNotSealed(object)\n   *\n   * Asserts that `object` is _not_ sealed.\n   *\n   *     assert.isNotSealed({});\n   *\n   * @name isNotSealed\n   * @alias notSealed\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotSealed = function (obj, msg) {\n    new Assertion(obj, msg, assert.isNotSealed, true).to.not.be.sealed;\n  };\n\n  /**\n   * ### .isFrozen(object)\n   *\n   * Asserts that `object` is frozen (cannot have new properties added to it\n   * and its existing properties cannot be modified).\n   *\n   *     var frozenObject = Object.freeze({});\n   *     assert.frozen(frozenObject);\n   *\n   * @name isFrozen\n   * @alias frozen\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isFrozen = function (obj, msg) {\n    new Assertion(obj, msg, assert.isFrozen, true).to.be.frozen;\n  };\n\n  /**\n   * ### .isNotFrozen(object)\n   *\n   * Asserts that `object` is _not_ frozen.\n   *\n   *     assert.isNotFrozen({});\n   *\n   * @name isNotFrozen\n   * @alias notFrozen\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotFrozen = function (obj, msg) {\n    new Assertion(obj, msg, assert.isNotFrozen, true).to.not.be.frozen;\n  };\n\n  /**\n   * ### .isEmpty(target)\n   *\n   * Asserts that the target does not contain any values.\n   * For arrays and strings, it checks the `length` property.\n   * For `Map` and `Set` instances, it checks the `size` property.\n   * For non-function objects, it gets the count of own\n   * enumerable string keys.\n   *\n   *     assert.isEmpty([]);\n   *     assert.isEmpty('');\n   *     assert.isEmpty(new Map);\n   *     assert.isEmpty({});\n   *\n   * @name isEmpty\n   * @alias empty\n   * @param {Object|Array|String|Map|Set} target\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isEmpty = function(val, msg) {\n    new Assertion(val, msg, assert.isEmpty, true).to.be.empty;\n  };\n\n  /**\n   * ### .isNotEmpty(target)\n   *\n   * Asserts that the target contains values.\n   * For arrays and strings, it checks the `length` property.\n   * For `Map` and `Set` instances, it checks the `size` property.\n   * For non-function objects, it gets the count of own\n   * enumerable string keys.\n   *\n   *     assert.isNotEmpty([1, 2]);\n   *     assert.isNotEmpty('34');\n   *     assert.isNotEmpty(new Set([5, 6]));\n   *     assert.isNotEmpty({ key: 7 });\n   *\n   * @name isNotEmpty\n   * @alias notEmpty\n   * @param {Object|Array|String|Map|Set} target\n   * @param {String} message _optional_\n   * @namespace Assert\n   * @api public\n   */\n\n  assert.isNotEmpty = function(val, msg) {\n    new Assertion(val, msg, assert.isNotEmpty, true).to.not.be.empty;\n  };\n\n  /*!\n   * Aliases.\n   */\n\n  (function alias(name, as){\n    assert[as] = assert[name];\n    return alias;\n  })\n  ('isOk', 'ok')\n  ('isNotOk', 'notOk')\n  ('throws', 'throw')\n  ('throws', 'Throw')\n  ('isExtensible', 'extensible')\n  ('isNotExtensible', 'notExtensible')\n  ('isSealed', 'sealed')\n  ('isNotSealed', 'notSealed')\n  ('isFrozen', 'frozen')\n  ('isNotFrozen', 'notFrozen')\n  ('isEmpty', 'empty')\n  ('isNotEmpty', 'notEmpty');\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/interface/assert.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/interface/expect.js":
/*!***************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/interface/expect.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  chai.expect = function (val, message) {\n    return new chai.Assertion(val, message);\n  };\n\n  /**\n   * ### .fail([message])\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure.\n   *\n   *     expect.fail();\n   *     expect.fail(\"custom error message\");\n   *     expect.fail(1, 2);\n   *     expect.fail(1, 2, \"custom error message\");\n   *     expect.fail(1, 2, \"custom error message\", \">\");\n   *     expect.fail(1, 2, undefined, \">\");\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @namespace BDD\n   * @api public\n   */\n\n  chai.expect.fail = function (actual, expected, message, operator) {\n    if (arguments.length < 2) {\n        message = actual;\n        actual = undefined;\n    }\n\n    message = message || 'expect.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, chai.expect.fail);\n  };\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/interface/expect.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/interface/should.js":
/*!***************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/interface/should.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  var Assertion = chai.Assertion;\n\n  function loadShould () {\n    // explicitly define this method as function as to have it's name to include as `ssfi`\n    function shouldGetter() {\n      if (this instanceof String\n          || this instanceof Number\n          || this instanceof Boolean\n          || typeof Symbol === 'function' && this instanceof Symbol) {\n        return new Assertion(this.valueOf(), null, shouldGetter);\n      }\n      return new Assertion(this, null, shouldGetter);\n    }\n    function shouldSetter(value) {\n      // See https://github.com/chaijs/chai/issues/86: this makes\n      // `whatever.should = someValue` actually set `someValue`, which is\n      // especially useful for `global.should = require('chai').should()`.\n      //\n      // Note that we have to use [[DefineProperty]] instead of [[Put]]\n      // since otherwise we would trigger this very setter!\n      Object.defineProperty(this, 'should', {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    }\n    // modify Object.prototype to have `should`\n    Object.defineProperty(Object.prototype, 'should', {\n      set: shouldSetter\n      , get: shouldGetter\n      , configurable: true\n    });\n\n    var should = {};\n\n    /**\n     * ### .fail([message])\n     * ### .fail(actual, expected, [message], [operator])\n     *\n     * Throw a failure.\n     *\n     *     should.fail();\n     *     should.fail(\"custom error message\");\n     *     should.fail(1, 2);\n     *     should.fail(1, 2, \"custom error message\");\n     *     should.fail(1, 2, \"custom error message\", \">\");\n     *     should.fail(1, 2, undefined, \">\");\n     *\n     *\n     * @name fail\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @param {String} operator\n     * @namespace BDD\n     * @api public\n     */\n\n    should.fail = function (actual, expected, message, operator) {\n      if (arguments.length < 2) {\n          message = actual;\n          actual = undefined;\n      }\n\n      message = message || 'should.fail()';\n      throw new chai.AssertionError(message, {\n          actual: actual\n        , expected: expected\n        , operator: operator\n      }, should.fail);\n    };\n\n    /**\n     * ### .equal(actual, expected, [message])\n     *\n     * Asserts non-strict equality (`==`) of `actual` and `expected`.\n     *\n     *     should.equal(3, '3', '== coerces values to strings');\n     *\n     * @name equal\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @namespace Should\n     * @api public\n     */\n\n    should.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.equal(val2);\n    };\n\n    /**\n     * ### .throw(function, [constructor/string/regexp], [string/regexp], [message])\n     *\n     * Asserts that `function` will throw an error that is an instance of\n     * `constructor`, or alternately that it will throw an error with message\n     * matching `regexp`.\n     *\n     *     should.throw(fn, 'function throws a reference error');\n     *     should.throw(fn, /function throws a reference error/);\n     *     should.throw(fn, ReferenceError);\n     *     should.throw(fn, ReferenceError, 'function throws a reference error');\n     *     should.throw(fn, ReferenceError, /function throws a reference error/);\n     *\n     * @name throw\n     * @alias Throw\n     * @param {Function} function\n     * @param {ErrorConstructor} constructor\n     * @param {RegExp} regexp\n     * @param {String} message\n     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n     * @namespace Should\n     * @api public\n     */\n\n    should.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.Throw(errt, errs);\n    };\n\n    /**\n     * ### .exist\n     *\n     * Asserts that the target is neither `null` nor `undefined`.\n     *\n     *     var foo = 'hi';\n     *\n     *     should.exist(foo, 'foo exists');\n     *\n     * @name exist\n     * @namespace Should\n     * @api public\n     */\n\n    should.exist = function (val, msg) {\n      new Assertion(val, msg).to.exist;\n    }\n\n    // negation\n    should.not = {}\n\n    /**\n     * ### .not.equal(actual, expected, [message])\n     *\n     * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n     *\n     *     should.not.equal(3, 4, 'these numbers are not equal');\n     *\n     * @name not.equal\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @namespace Should\n     * @api public\n     */\n\n    should.not.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.not.equal(val2);\n    };\n\n    /**\n     * ### .throw(function, [constructor/regexp], [message])\n     *\n     * Asserts that `function` will _not_ throw an error that is an instance of\n     * `constructor`, or alternately that it will not throw an error with message\n     * matching `regexp`.\n     *\n     *     should.not.throw(fn, Error, 'function does not throw');\n     *\n     * @name not.throw\n     * @alias not.Throw\n     * @param {Function} function\n     * @param {ErrorConstructor} constructor\n     * @param {RegExp} regexp\n     * @param {String} message\n     * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n     * @namespace Should\n     * @api public\n     */\n\n    should.not.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.not.Throw(errt, errs);\n    };\n\n    /**\n     * ### .not.exist\n     *\n     * Asserts that the target is neither `null` nor `undefined`.\n     *\n     *     var bar = null;\n     *\n     *     should.not.exist(bar, 'bar does not exist');\n     *\n     * @name not.exist\n     * @namespace Should\n     * @api public\n     */\n\n    should.not.exist = function (val, msg) {\n      new Assertion(val, msg).to.not.exist;\n    }\n\n    should['throw'] = should['Throw'];\n    should.not['throw'] = should.not['Throw'];\n\n    return should;\n  };\n\n  chai.should = loadShould;\n  chai.Should = loadShould;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/interface/should.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/addChainableMethod.js":
/*!***********************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/addChainableMethod.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - addChainingMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \"../../node_modules/chai/lib/chai/utils/addLengthGuard.js\");\nvar chai = __webpack_require__(/*! ../../chai */ \"../../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar proxify = __webpack_require__(/*! ./proxify */ \"../../node_modules/chai/lib/chai/utils/proxify.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/*!\n * Module variables\n */\n\n// Check whether `Object.setPrototypeOf` is supported\nvar canSetPrototype = typeof Object.setPrototypeOf === 'function';\n\n// Without `Object.setPrototypeOf` support, this module will need to add properties to a function.\n// However, some of functions' own props are not configurable and should be skipped.\nvar testFn = function() {};\nvar excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {\n  var propDesc = Object.getOwnPropertyDescriptor(testFn, name);\n\n  // Note: PhantomJS 1.x includes `callee` as one of `testFn`'s own properties,\n  // but then returns `undefined` as the property descriptor for `callee`. As a\n  // workaround, we perform an otherwise unnecessary type-check for `propDesc`,\n  // and then filter it out if it's not an object as it should be.\n  if (typeof propDesc !== 'object')\n    return true;\n\n  return !propDesc.configurable;\n});\n\n// Cache `Function` properties\nvar call  = Function.prototype.call,\n    apply = Function.prototype.apply;\n\n/**\n * ### .addChainableMethod(ctx, name, method, chainingBehavior)\n *\n * Adds a method to an object, such that the method can also be chained.\n *\n *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n *\n * The result can then be used as both a method assertion, executing both `method` and\n * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n *\n *     expect(fooStr).to.be.foo('bar');\n *     expect(fooStr).to.be.foo.equal('foo');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for `name`, when called\n * @param {Function} chainingBehavior function to be called every time the property is accessed\n * @namespace Utils\n * @name addChainableMethod\n * @api public\n */\n\nmodule.exports = function addChainableMethod(ctx, name, method, chainingBehavior) {\n  if (typeof chainingBehavior !== 'function') {\n    chainingBehavior = function () { };\n  }\n\n  var chainableBehavior = {\n      method: method\n    , chainingBehavior: chainingBehavior\n  };\n\n  // save the methods so we can overwrite them later, if we need to.\n  if (!ctx.__methods) {\n    ctx.__methods = {};\n  }\n  ctx.__methods[name] = chainableBehavior;\n\n  Object.defineProperty(ctx, name,\n    { get: function chainableMethodGetter() {\n        chainableBehavior.chainingBehavior.call(this);\n\n        var chainableMethodWrapper = function () {\n          // Setting the `ssfi` flag to `chainableMethodWrapper` causes this\n          // function to be the starting point for removing implementation\n          // frames from the stack trace of a failed assertion.\n          //\n          // However, we only want to use this function as the starting point if\n          // the `lockSsfi` flag isn't set.\n          //\n          // If the `lockSsfi` flag is set, then this assertion is being\n          // invoked from inside of another assertion. In this case, the `ssfi`\n          // flag has already been set by the outer assertion.\n          //\n          // Note that overwriting a chainable method merely replaces the saved\n          // methods in `ctx.__methods` instead of completely replacing the\n          // overwritten assertion. Therefore, an overwriting assertion won't\n          // set the `ssfi` or `lockSsfi` flags.\n          if (!flag(this, 'lockSsfi')) {\n            flag(this, 'ssfi', chainableMethodWrapper);\n          }\n\n          var result = chainableBehavior.method.apply(this, arguments);\n          if (result !== undefined) {\n            return result;\n          }\n\n          var newAssertion = new chai.Assertion();\n          transferFlags(this, newAssertion);\n          return newAssertion;\n        };\n\n        addLengthGuard(chainableMethodWrapper, name, true);\n\n        // Use `Object.setPrototypeOf` if available\n        if (canSetPrototype) {\n          // Inherit all properties from the object by replacing the `Function` prototype\n          var prototype = Object.create(this);\n          // Restore the `call` and `apply` methods from `Function`\n          prototype.call = call;\n          prototype.apply = apply;\n          Object.setPrototypeOf(chainableMethodWrapper, prototype);\n        }\n        // Otherwise, redefine all properties (slow!)\n        else {\n          var asserterNames = Object.getOwnPropertyNames(ctx);\n          asserterNames.forEach(function (asserterName) {\n            if (excludeNames.indexOf(asserterName) !== -1) {\n              return;\n            }\n\n            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n            Object.defineProperty(chainableMethodWrapper, asserterName, pd);\n          });\n        }\n\n        transferFlags(this, chainableMethodWrapper);\n        return proxify(chainableMethodWrapper);\n      }\n    , configurable: true\n  });\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/addChainableMethod.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/addLengthGuard.js":
/*!*******************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/addLengthGuard.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var fnLengthDesc = Object.getOwnPropertyDescriptor(function () {}, 'length');\n\n/*!\n * Chai - addLengthGuard utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .addLengthGuard(fn, assertionName, isChainable)\n *\n * Define `length` as a getter on the given uninvoked method assertion. The\n * getter acts as a guard against chaining `length` directly off of an uninvoked\n * method assertion, which is a problem because it references `function`'s\n * built-in `length` property instead of Chai's `length` assertion. When the\n * getter catches the user making this mistake, it throws an error with a\n * helpful message.\n *\n * There are two ways in which this mistake can be made. The first way is by\n * chaining the `length` assertion directly off of an uninvoked chainable\n * method. In this case, Chai suggests that the user use `lengthOf` instead. The\n * second way is by chaining the `length` assertion directly off of an uninvoked\n * non-chainable method. Non-chainable methods must be invoked prior to\n * chaining. In this case, Chai suggests that the user consult the docs for the\n * given assertion.\n *\n * If the `length` property of functions is unconfigurable, then return `fn`\n * without modification.\n *\n * Note that in ES6, the function's `length` property is configurable, so once\n * support for legacy environments is dropped, Chai's `length` property can\n * replace the built-in function's `length` property, and this length guard will\n * no longer be necessary. In the mean time, maintaining consistency across all\n * environments is the priority.\n *\n * @param {Function} fn\n * @param {String} assertionName\n * @param {Boolean} isChainable\n * @namespace Utils\n * @name addLengthGuard\n */\n\nmodule.exports = function addLengthGuard (fn, assertionName, isChainable) {\n  if (!fnLengthDesc.configurable) return fn;\n\n  Object.defineProperty(fn, 'length', {\n    get: function () {\n      if (isChainable) {\n        throw Error('Invalid Chai property: ' + assertionName + '.length. Due' +\n          ' to a compatibility issue, \"length\" cannot directly follow \"' +\n          assertionName + '\". Use \"' + assertionName + '.lengthOf\" instead.');\n      }\n\n      throw Error('Invalid Chai property: ' + assertionName + '.length. See' +\n        ' docs for proper usage of \"' + assertionName + '\".');\n    }\n  });\n\n  return fn;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/addLengthGuard.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/addMethod.js":
/*!**************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/addMethod.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - addMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \"../../node_modules/chai/lib/chai/utils/addLengthGuard.js\");\nvar chai = __webpack_require__(/*! ../../chai */ \"../../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar proxify = __webpack_require__(/*! ./proxify */ \"../../node_modules/chai/lib/chai/utils/proxify.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .addMethod(ctx, name, method)\n *\n * Adds a method to the prototype of an object.\n *\n *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(fooStr).to.be.foo('bar');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for name\n * @namespace Utils\n * @name addMethod\n * @api public\n */\n\nmodule.exports = function addMethod(ctx, name, method) {\n  var methodWrapper = function () {\n    // Setting the `ssfi` flag to `methodWrapper` causes this function to be the\n    // starting point for removing implementation frames from the stack trace of\n    // a failed assertion.\n    //\n    // However, we only want to use this function as the starting point if the\n    // `lockSsfi` flag isn't set.\n    //\n    // If the `lockSsfi` flag is set, then either this assertion has been\n    // overwritten by another assertion, or this assertion is being invoked from\n    // inside of another assertion. In the first case, the `ssfi` flag has\n    // already been set by the overwriting assertion. In the second case, the\n    // `ssfi` flag has already been set by the outer assertion.\n    if (!flag(this, 'lockSsfi')) {\n      flag(this, 'ssfi', methodWrapper);\n    }\n\n    var result = method.apply(this, arguments);\n    if (result !== undefined)\n      return result;\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n\n  addLengthGuard(methodWrapper, name, false);\n  ctx[name] = proxify(methodWrapper, name);\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/addMethod.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/addProperty.js":
/*!****************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/addProperty.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - addProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar chai = __webpack_require__(/*! ../../chai */ \"../../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \"../../node_modules/chai/lib/chai/utils/isProxyEnabled.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .addProperty(ctx, name, getter)\n *\n * Adds a property to the prototype of an object.\n *\n *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.instanceof(Foo);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.foo;\n *\n * @param {Object} ctx object to which the property is added\n * @param {String} name of property to add\n * @param {Function} getter function to be used for name\n * @namespace Utils\n * @name addProperty\n * @api public\n */\n\nmodule.exports = function addProperty(ctx, name, getter) {\n  getter = getter === undefined ? function () {} : getter;\n\n  Object.defineProperty(ctx, name,\n    { get: function propertyGetter() {\n        // Setting the `ssfi` flag to `propertyGetter` causes this function to\n        // be the starting point for removing implementation frames from the\n        // stack trace of a failed assertion.\n        //\n        // However, we only want to use this function as the starting point if\n        // the `lockSsfi` flag isn't set and proxy protection is disabled.\n        //\n        // If the `lockSsfi` flag is set, then either this assertion has been\n        // overwritten by another assertion, or this assertion is being invoked\n        // from inside of another assertion. In the first case, the `ssfi` flag\n        // has already been set by the overwriting assertion. In the second\n        // case, the `ssfi` flag has already been set by the outer assertion.\n        //\n        // If proxy protection is enabled, then the `ssfi` flag has already been\n        // set by the proxy getter.\n        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {\n          flag(this, 'ssfi', propertyGetter);\n        }\n\n        var result = getter.call(this);\n        if (result !== undefined)\n          return result;\n\n        var newAssertion = new chai.Assertion();\n        transferFlags(this, newAssertion);\n        return newAssertion;\n      }\n    , configurable: true\n  });\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/addProperty.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/compareByInspect.js":
/*!*********************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/compareByInspect.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - compareByInspect utility\n * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar inspect = __webpack_require__(/*! ./inspect */ \"../../node_modules/chai/lib/chai/utils/inspect.js\");\n\n/**\n * ### .compareByInspect(mixed, mixed)\n *\n * To be used as a compareFunction with Array.prototype.sort. Compares elements\n * using inspect instead of default behavior of using toString so that Symbols\n * and objects with irregular/missing toString can still be sorted without a\n * TypeError.\n *\n * @param {Mixed} first element to compare\n * @param {Mixed} second element to compare\n * @returns {Number} -1 if 'a' should come before 'b'; otherwise 1\n * @name compareByInspect\n * @namespace Utils\n * @api public\n */\n\nmodule.exports = function compareByInspect(a, b) {\n  return inspect(a) < inspect(b) ? -1 : 1;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/compareByInspect.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/expectTypes.js":
/*!****************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/expectTypes.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - expectTypes utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .expectTypes(obj, types)\n *\n * Ensures that the object being tested against is of a valid type.\n *\n *     utils.expectTypes(this, ['array', 'object', 'string']);\n *\n * @param {Mixed} obj constructed Assertion\n * @param {Array} type A list of allowed types for this assertion\n * @namespace Utils\n * @name expectTypes\n * @api public\n */\n\nvar AssertionError = __webpack_require__(/*! assertion-error */ \"../../node_modules/assertion-error/index.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar type = __webpack_require__(/*! type-detect */ \"../../node_modules/type-detect/type-detect.js\");\n\nmodule.exports = function expectTypes(obj, types) {\n  var flagMsg = flag(obj, 'message');\n  var ssfi = flag(obj, 'ssfi');\n\n  flagMsg = flagMsg ? flagMsg + ': ' : '';\n\n  obj = flag(obj, 'object');\n  types = types.map(function (t) { return t.toLowerCase(); });\n  types.sort();\n\n  // Transforms ['lorem', 'ipsum'] into 'a lorem, or an ipsum'\n  var str = types.map(function (t, index) {\n    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';\n    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';\n    return or + art + ' ' + t;\n  }).join(', ');\n\n  var objType = type(obj).toLowerCase();\n\n  if (!types.some(function (expected) { return objType === expected; })) {\n    throw new AssertionError(\n      flagMsg + 'object tested must be ' + str + ', but ' + objType + ' given',\n      undefined,\n      ssfi\n    );\n  }\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/expectTypes.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/flag.js":
/*!*********************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/flag.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .flag(object, key, [value])\n *\n * Get or set a flag value on an object. If a\n * value is provided it will be set, else it will\n * return the currently set value or `undefined` if\n * the value is not set.\n *\n *     utils.flag(this, 'foo', 'bar'); // setter\n *     utils.flag(this, 'foo'); // getter, returns `bar`\n *\n * @param {Object} object constructed Assertion\n * @param {String} key\n * @param {Mixed} value (optional)\n * @namespace Utils\n * @name flag\n * @api private\n */\n\nmodule.exports = function flag(obj, key, value) {\n  var flags = obj.__flags || (obj.__flags = Object.create(null));\n  if (arguments.length === 3) {\n    flags[key] = value;\n  } else {\n    return flags[key];\n  }\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/flag.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/getActual.js":
/*!**************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/getActual.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - getActual utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getActual(object, [actual])\n *\n * Returns the `actual` value for an Assertion.\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @namespace Utils\n * @name getActual\n */\n\nmodule.exports = function getActual(obj, args) {\n  return args.length > 4 ? args[4] : obj._obj;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/getActual.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/getEnumerableProperties.js":
/*!****************************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/getEnumerableProperties.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - getEnumerableProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getEnumerableProperties(object)\n *\n * This allows the retrieval of enumerable property names of an object,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @namespace Utils\n * @name getEnumerableProperties\n * @api public\n */\n\nmodule.exports = function getEnumerableProperties(object) {\n  var result = [];\n  for (var name in object) {\n    result.push(name);\n  }\n  return result;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/getEnumerableProperties.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/getMessage.js":
/*!***************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/getMessage.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - message composition utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\")\n  , getActual = __webpack_require__(/*! ./getActual */ \"../../node_modules/chai/lib/chai/utils/getActual.js\")\n  , objDisplay = __webpack_require__(/*! ./objDisplay */ \"../../node_modules/chai/lib/chai/utils/objDisplay.js\");\n\n/**\n * ### .getMessage(object, message, negateMessage)\n *\n * Construct the error message based on flags\n * and template tags. Template tags will return\n * a stringified inspection of the object referenced.\n *\n * Message template tags:\n * - `#{this}` current asserted object\n * - `#{act}` actual value\n * - `#{exp}` expected value\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @namespace Utils\n * @name getMessage\n * @api public\n */\n\nmodule.exports = function getMessage(obj, args) {\n  var negate = flag(obj, 'negate')\n    , val = flag(obj, 'object')\n    , expected = args[3]\n    , actual = getActual(obj, args)\n    , msg = negate ? args[2] : args[1]\n    , flagMsg = flag(obj, 'message');\n\n  if(typeof msg === \"function\") msg = msg();\n  msg = msg || '';\n  msg = msg\n    .replace(/#\\{this\\}/g, function () { return objDisplay(val); })\n    .replace(/#\\{act\\}/g, function () { return objDisplay(actual); })\n    .replace(/#\\{exp\\}/g, function () { return objDisplay(expected); });\n\n  return flagMsg ? flagMsg + ': ' + msg : msg;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/getMessage.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js":
/*!*******************************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - getOwnEnumerableProperties utility\n * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar getOwnEnumerablePropertySymbols = __webpack_require__(/*! ./getOwnEnumerablePropertySymbols */ \"../../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js\");\n\n/**\n * ### .getOwnEnumerableProperties(object)\n *\n * This allows the retrieval of directly-owned enumerable property names and\n * symbols of an object. This function is necessary because Object.keys only\n * returns enumerable property names, not enumerable property symbols.\n *\n * @param {Object} object\n * @returns {Array}\n * @namespace Utils\n * @name getOwnEnumerableProperties\n * @api public\n */\n\nmodule.exports = function getOwnEnumerableProperties(obj) {\n  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js":
/*!************************************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - getOwnEnumerablePropertySymbols utility\n * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getOwnEnumerablePropertySymbols(object)\n *\n * This allows the retrieval of directly-owned enumerable property symbols of an\n * object. This function is necessary because Object.getOwnPropertySymbols\n * returns both enumerable and non-enumerable property symbols.\n *\n * @param {Object} object\n * @returns {Array}\n * @namespace Utils\n * @name getOwnEnumerablePropertySymbols\n * @api public\n */\n\nmodule.exports = function getOwnEnumerablePropertySymbols(obj) {\n  if (typeof Object.getOwnPropertySymbols !== 'function') return [];\n\n  return Object.getOwnPropertySymbols(obj).filter(function (sym) {\n    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;\n  });\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/getProperties.js":
/*!******************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/getProperties.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - getProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getProperties(object)\n *\n * This allows the retrieval of property names of an object, enumerable or not,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @namespace Utils\n * @name getProperties\n * @api public\n */\n\nmodule.exports = function getProperties(object) {\n  var result = Object.getOwnPropertyNames(object);\n\n  function addProperty(property) {\n    if (result.indexOf(property) === -1) {\n      result.push(property);\n    }\n  }\n\n  var proto = Object.getPrototypeOf(object);\n  while (proto !== null) {\n    Object.getOwnPropertyNames(proto).forEach(addProperty);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return result;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/getProperties.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/index.js":
/*!**********************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/index.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * chai\n * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Dependencies that are used for multiple exports are required here only once\n */\n\nvar pathval = __webpack_require__(/*! pathval */ \"../../node_modules/pathval/index.js\");\n\n/*!\n * test utility\n */\n\nexports.test = __webpack_require__(/*! ./test */ \"../../node_modules/chai/lib/chai/utils/test.js\");\n\n/*!\n * type utility\n */\n\nexports.type = __webpack_require__(/*! type-detect */ \"../../node_modules/type-detect/type-detect.js\");\n\n/*!\n * expectTypes utility\n */\nexports.expectTypes = __webpack_require__(/*! ./expectTypes */ \"../../node_modules/chai/lib/chai/utils/expectTypes.js\");\n\n/*!\n * message utility\n */\n\nexports.getMessage = __webpack_require__(/*! ./getMessage */ \"../../node_modules/chai/lib/chai/utils/getMessage.js\");\n\n/*!\n * actual utility\n */\n\nexports.getActual = __webpack_require__(/*! ./getActual */ \"../../node_modules/chai/lib/chai/utils/getActual.js\");\n\n/*!\n * Inspect util\n */\n\nexports.inspect = __webpack_require__(/*! ./inspect */ \"../../node_modules/chai/lib/chai/utils/inspect.js\");\n\n/*!\n * Object Display util\n */\n\nexports.objDisplay = __webpack_require__(/*! ./objDisplay */ \"../../node_modules/chai/lib/chai/utils/objDisplay.js\");\n\n/*!\n * Flag utility\n */\n\nexports.flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\n\n/*!\n * Flag transferring utility\n */\n\nexports.transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/*!\n * Deep equal utility\n */\n\nexports.eql = __webpack_require__(/*! deep-eql */ \"../../node_modules/deep-eql/index.js\");\n\n/*!\n * Deep path info\n */\n\nexports.getPathInfo = pathval.getPathInfo;\n\n/*!\n * Check if a property exists\n */\n\nexports.hasProperty = pathval.hasProperty;\n\n/*!\n * Function name\n */\n\nexports.getName = __webpack_require__(/*! get-func-name */ \"../../node_modules/get-func-name/index.js\");\n\n/*!\n * add Property\n */\n\nexports.addProperty = __webpack_require__(/*! ./addProperty */ \"../../node_modules/chai/lib/chai/utils/addProperty.js\");\n\n/*!\n * add Method\n */\n\nexports.addMethod = __webpack_require__(/*! ./addMethod */ \"../../node_modules/chai/lib/chai/utils/addMethod.js\");\n\n/*!\n * overwrite Property\n */\n\nexports.overwriteProperty = __webpack_require__(/*! ./overwriteProperty */ \"../../node_modules/chai/lib/chai/utils/overwriteProperty.js\");\n\n/*!\n * overwrite Method\n */\n\nexports.overwriteMethod = __webpack_require__(/*! ./overwriteMethod */ \"../../node_modules/chai/lib/chai/utils/overwriteMethod.js\");\n\n/*!\n * Add a chainable method\n */\n\nexports.addChainableMethod = __webpack_require__(/*! ./addChainableMethod */ \"../../node_modules/chai/lib/chai/utils/addChainableMethod.js\");\n\n/*!\n * Overwrite chainable method\n */\n\nexports.overwriteChainableMethod = __webpack_require__(/*! ./overwriteChainableMethod */ \"../../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js\");\n\n/*!\n * Compare by inspect method\n */\n\nexports.compareByInspect = __webpack_require__(/*! ./compareByInspect */ \"../../node_modules/chai/lib/chai/utils/compareByInspect.js\");\n\n/*!\n * Get own enumerable property symbols method\n */\n\nexports.getOwnEnumerablePropertySymbols = __webpack_require__(/*! ./getOwnEnumerablePropertySymbols */ \"../../node_modules/chai/lib/chai/utils/getOwnEnumerablePropertySymbols.js\");\n\n/*!\n * Get own enumerable properties method\n */\n\nexports.getOwnEnumerableProperties = __webpack_require__(/*! ./getOwnEnumerableProperties */ \"../../node_modules/chai/lib/chai/utils/getOwnEnumerableProperties.js\");\n\n/*!\n * Checks error against a given set of criteria\n */\n\nexports.checkError = __webpack_require__(/*! check-error */ \"../../node_modules/check-error/index.js\");\n\n/*!\n * Proxify util\n */\n\nexports.proxify = __webpack_require__(/*! ./proxify */ \"../../node_modules/chai/lib/chai/utils/proxify.js\");\n\n/*!\n * addLengthGuard util\n */\n\nexports.addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \"../../node_modules/chai/lib/chai/utils/addLengthGuard.js\");\n\n/*!\n * isProxyEnabled helper\n */\n\nexports.isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \"../../node_modules/chai/lib/chai/utils/isProxyEnabled.js\");\n\n/*!\n * isNaN method\n */\n\nexports.isNaN = __webpack_require__(/*! ./isNaN */ \"../../node_modules/chai/lib/chai/utils/isNaN.js\");\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/index.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/inspect.js":
/*!************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/inspect.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This is (almost) directly from Node.js utils\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n\nvar getName = __webpack_require__(/*! get-func-name */ \"../../node_modules/get-func-name/index.js\");\nvar getProperties = __webpack_require__(/*! ./getProperties */ \"../../node_modules/chai/lib/chai/utils/getProperties.js\");\nvar getEnumerableProperties = __webpack_require__(/*! ./getEnumerableProperties */ \"../../node_modules/chai/lib/chai/utils/getEnumerableProperties.js\");\nvar config = __webpack_require__(/*! ../config */ \"../../node_modules/chai/lib/chai/config.js\");\n\nmodule.exports = inspect;\n\n/**\n * ### .inspect(obj, [showHidden], [depth], [colors])\n *\n * Echoes the value of a value. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n *    properties of objects. Default is false.\n * @param {Number} depth Depth in which to descend in object. Default is 2.\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n *    output. Default is false (no coloring).\n * @namespace Utils\n * @name inspect\n */\nfunction inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: function (str) { return str; }\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\n\n// Returns true if object is a DOM element.\nvar isDOMElement = function (object) {\n  if (typeof HTMLElement === 'object') {\n    return object instanceof HTMLElement;\n  } else {\n    return object &&\n      typeof object === 'object' &&\n      'nodeType' in object &&\n      object.nodeType === 1 &&\n      typeof object.nodeName === 'string';\n  }\n};\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (typeof ret !== 'string') {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // If this is a DOM element, try to get the outer HTML.\n  if (isDOMElement(value)) {\n    if ('outerHTML' in value) {\n      return value.outerHTML;\n      // This value does not have an outerHTML attribute,\n      //   it could still be an XML element\n    } else {\n      // Attempt to serialize it\n      try {\n        if (document.xmlVersion) {\n          var xmlSerializer = new XMLSerializer();\n          return xmlSerializer.serializeToString(value);\n        } else {\n          // Firefox 11- do not support outerHTML\n          //   It does, however, support innerHTML\n          //   Use the following to render the element\n          var ns = \"http://www.w3.org/1999/xhtml\";\n          var container = document.createElementNS(ns, '_');\n\n          container.appendChild(value.cloneNode(false));\n          var html = container.innerHTML\n            .replace('><', '>' + value.innerHTML + '<');\n          container.innerHTML = '';\n          return html;\n        }\n      } catch (err) {\n        // This could be a non-native DOM implementation,\n        //   continue with the normal flow:\n        //   printing the element as if it is an object.\n      }\n    }\n  }\n\n  // Look up the keys of the object.\n  var visibleKeys = getEnumerableProperties(value);\n  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\n\n  var name, nameSuffix;\n\n  // Some type of object without properties can be shortcut.\n  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n  // a `stack` plus `description` property; ignore those for consistency.\n  if (keys.length === 0 || (isError(value) && (\n      (keys.length === 1 && keys[0] === 'stack') ||\n      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\n     ))) {\n    if (typeof value === 'function') {\n      name = getName(value);\n      nameSuffix = name ? ': ' + name : '';\n      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = ''\n    , array = false\n    , typedArray = false\n    , braces = ['{', '}'];\n\n  if (isTypedArray(value)) {\n    typedArray = true;\n    braces = ['[', ']'];\n  }\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    name = getName(value);\n    nameSuffix = name ? ': ' + name : '';\n    base = ' [Function' + nameSuffix + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    return formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else if (typedArray) {\n    return formatTypedArray(value);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      if (value === 0 && (1/value) === -Infinity) {\n        return ctx.stylize('-0', 'number');\n      }\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n\n    case 'symbol':\n      return ctx.stylize(value.toString(), 'symbol');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\nfunction formatTypedArray(value) {\n  var str = '[ ';\n\n  for (var i = 0; i < value.length; ++i) {\n    if (str.length >= config.truncateThreshold - 7) {\n      str += '...';\n      break;\n    }\n    str += value[i] + ', ';\n  }\n  str += ' ]';\n\n  // Removing trailing `, ` if the array was not truncated\n  if (str.indexOf(',  ]') !== -1) {\n    str = str.replace(',  ]', ' ]');\n  }\n\n  return str;\n}\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name;\n  var propDescriptor = Object.getOwnPropertyDescriptor(value, key);\n  var str;\n\n  if (propDescriptor) {\n    if (propDescriptor.get) {\n      if (propDescriptor.set) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (propDescriptor.set) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n  }\n  if (visibleKeys.indexOf(key) < 0) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(value[key]) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, value[key], null);\n      } else {\n        str = formatValue(ctx, value[key], recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\nfunction reduceToSingleString(output, base, braces) {\n  var length = output.reduce(function(prev, cur) {\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\nfunction isTypedArray(ar) {\n  // Unfortunately there's no way to check if an object is a TypedArray\n  // We have to check if it's one of these types\n  return (typeof ar === 'object' && /\\w+Array]$/.test(objectToString(ar)));\n}\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n}\n\nfunction isRegExp(re) {\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n}\n\nfunction isDate(d) {\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/inspect.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/isNaN.js":
/*!**********************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/isNaN.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - isNaN utility\n * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>\n * MIT Licensed\n */\n\n/**\n * ### .isNaN(value)\n *\n * Checks if the given value is NaN or not.\n *\n *     utils.isNaN(NaN); // true\n *\n * @param {Value} The value which has to be checked if it is NaN\n * @name isNaN\n * @api private\n */\n\nfunction isNaN(value) {\n  // Refer http://www.ecma-international.org/ecma-262/6.0/#sec-isnan-number\n  // section's NOTE.\n  return value !== value;\n}\n\n// If ECMAScript 6's Number.isNaN is present, prefer that.\nmodule.exports = Number.isNaN || isNaN;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/isNaN.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/isProxyEnabled.js":
/*!*******************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/isProxyEnabled.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var config = __webpack_require__(/*! ../config */ \"../../node_modules/chai/lib/chai/config.js\");\n\n/*!\n * Chai - isProxyEnabled helper\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .isProxyEnabled()\n *\n * Helper function to check if Chai's proxy protection feature is enabled. If\n * proxies are unsupported or disabled via the user's Chai config, then return\n * false. Otherwise, return true.\n *\n * @namespace Utils\n * @name isProxyEnabled\n */\n\nmodule.exports = function isProxyEnabled() {\n  return config.useProxy &&\n    typeof Proxy !== 'undefined' &&\n    typeof Reflect !== 'undefined';\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/isProxyEnabled.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/objDisplay.js":
/*!***************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/objDisplay.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar inspect = __webpack_require__(/*! ./inspect */ \"../../node_modules/chai/lib/chai/utils/inspect.js\");\nvar config = __webpack_require__(/*! ../config */ \"../../node_modules/chai/lib/chai/config.js\");\n\n/**\n * ### .objDisplay(object)\n *\n * Determines if an object or an array matches\n * criteria to be inspected in-line for error\n * messages or should be truncated.\n *\n * @param {Mixed} javascript object to inspect\n * @name objDisplay\n * @namespace Utils\n * @api public\n */\n\nmodule.exports = function objDisplay(obj) {\n  var str = inspect(obj)\n    , type = Object.prototype.toString.call(obj);\n\n  if (config.truncateThreshold && str.length >= config.truncateThreshold) {\n    if (type === '[object Function]') {\n      return !obj.name || obj.name === ''\n        ? '[Function]'\n        : '[Function: ' + obj.name + ']';\n    } else if (type === '[object Array]') {\n      return '[ Array(' + obj.length + ') ]';\n    } else if (type === '[object Object]') {\n      var keys = Object.keys(obj)\n        , kstr = keys.length > 2\n          ? keys.splice(0, 2).join(', ') + ', ...'\n          : keys.join(', ');\n      return '{ Object (' + kstr + ') }';\n    } else {\n      return str;\n    }\n  } else {\n    return str;\n  }\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/objDisplay.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/overwriteChainableMethod.js":
/*!*****************************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/overwriteChainableMethod.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - overwriteChainableMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar chai = __webpack_require__(/*! ../../chai */ \"../../node_modules/chai/lib/chai.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .overwriteChainableMethod(ctx, name, method, chainingBehavior)\n *\n * Overwrites an already existing chainable method\n * and provides access to the previous function or\n * property.  Must return functions to be used for\n * name.\n *\n *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'lengthOf',\n *       function (_super) {\n *       }\n *     , function (_super) {\n *       }\n *     );\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.have.lengthOf(3);\n *     expect(myFoo).to.have.lengthOf.above(3);\n *\n * @param {Object} ctx object whose method / property is to be overwritten\n * @param {String} name of method / property to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @param {Function} chainingBehavior function that returns a function to be used for property\n * @namespace Utils\n * @name overwriteChainableMethod\n * @api public\n */\n\nmodule.exports = function overwriteChainableMethod(ctx, name, method, chainingBehavior) {\n  var chainableBehavior = ctx.__methods[name];\n\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\n  chainableBehavior.chainingBehavior = function overwritingChainableMethodGetter() {\n    var result = chainingBehavior(_chainingBehavior).call(this);\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n\n  var _method = chainableBehavior.method;\n  chainableBehavior.method = function overwritingChainableMethodWrapper() {\n    var result = method(_method).apply(this, arguments);\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/overwriteChainableMethod.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/overwriteMethod.js":
/*!********************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/overwriteMethod.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - overwriteMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar addLengthGuard = __webpack_require__(/*! ./addLengthGuard */ \"../../node_modules/chai/lib/chai/utils/addLengthGuard.js\");\nvar chai = __webpack_require__(/*! ../../chai */ \"../../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar proxify = __webpack_require__(/*! ./proxify */ \"../../node_modules/chai/lib/chai/utils/proxify.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .overwriteMethod(ctx, name, fn)\n *\n * Overwrites an already existing method and provides\n * access to previous function. Must return function\n * to be used for name.\n *\n *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n *       return function (str) {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.value).to.equal(str);\n *         } else {\n *           _super.apply(this, arguments);\n *         }\n *       }\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.equal('bar');\n *\n * @param {Object} ctx object whose method is to be overwritten\n * @param {String} name of method to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @namespace Utils\n * @name overwriteMethod\n * @api public\n */\n\nmodule.exports = function overwriteMethod(ctx, name, method) {\n  var _method = ctx[name]\n    , _super = function () {\n      throw new Error(name + ' is not a function');\n    };\n\n  if (_method && 'function' === typeof _method)\n    _super = _method;\n\n  var overwritingMethodWrapper = function () {\n    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this\n    // function to be the starting point for removing implementation frames from\n    // the stack trace of a failed assertion.\n    //\n    // However, we only want to use this function as the starting point if the\n    // `lockSsfi` flag isn't set.\n    //\n    // If the `lockSsfi` flag is set, then either this assertion has been\n    // overwritten by another assertion, or this assertion is being invoked from\n    // inside of another assertion. In the first case, the `ssfi` flag has\n    // already been set by the overwriting assertion. In the second case, the\n    // `ssfi` flag has already been set by the outer assertion.\n    if (!flag(this, 'lockSsfi')) {\n      flag(this, 'ssfi', overwritingMethodWrapper);\n    }\n\n    // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion\n    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already\n    // set to the correct starting point for this assertion.\n    var origLockSsfi = flag(this, 'lockSsfi');\n    flag(this, 'lockSsfi', true);\n    var result = method(_super).apply(this, arguments);\n    flag(this, 'lockSsfi', origLockSsfi);\n\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  }\n\n  addLengthGuard(overwritingMethodWrapper, name, false);\n  ctx[name] = proxify(overwritingMethodWrapper, name);\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/overwriteMethod.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/overwriteProperty.js":
/*!**********************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/overwriteProperty.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - overwriteProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar chai = __webpack_require__(/*! ../../chai */ \"../../node_modules/chai/lib/chai.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \"../../node_modules/chai/lib/chai/utils/isProxyEnabled.js\");\nvar transferFlags = __webpack_require__(/*! ./transferFlags */ \"../../node_modules/chai/lib/chai/utils/transferFlags.js\");\n\n/**\n * ### .overwriteProperty(ctx, name, fn)\n *\n * Overwrites an already existing property getter and provides\n * access to previous value. Must return function to use as getter.\n *\n *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n *       return function () {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.name).to.equal('bar');\n *         } else {\n *           _super.call(this);\n *         }\n *       }\n *     });\n *\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.ok;\n *\n * @param {Object} ctx object whose property is to be overwritten\n * @param {String} name of property to overwrite\n * @param {Function} getter function that returns a getter function to be used for name\n * @namespace Utils\n * @name overwriteProperty\n * @api public\n */\n\nmodule.exports = function overwriteProperty(ctx, name, getter) {\n  var _get = Object.getOwnPropertyDescriptor(ctx, name)\n    , _super = function () {};\n\n  if (_get && 'function' === typeof _get.get)\n    _super = _get.get\n\n  Object.defineProperty(ctx, name,\n    { get: function overwritingPropertyGetter() {\n        // Setting the `ssfi` flag to `overwritingPropertyGetter` causes this\n        // function to be the starting point for removing implementation frames\n        // from the stack trace of a failed assertion.\n        //\n        // However, we only want to use this function as the starting point if\n        // the `lockSsfi` flag isn't set and proxy protection is disabled.\n        //\n        // If the `lockSsfi` flag is set, then either this assertion has been\n        // overwritten by another assertion, or this assertion is being invoked\n        // from inside of another assertion. In the first case, the `ssfi` flag\n        // has already been set by the overwriting assertion. In the second\n        // case, the `ssfi` flag has already been set by the outer assertion.\n        //\n        // If proxy protection is enabled, then the `ssfi` flag has already been\n        // set by the proxy getter.\n        if (!isProxyEnabled() && !flag(this, 'lockSsfi')) {\n          flag(this, 'ssfi', overwritingPropertyGetter);\n        }\n\n        // Setting the `lockSsfi` flag to `true` prevents the overwritten\n        // assertion from changing the `ssfi` flag. By this point, the `ssfi`\n        // flag is already set to the correct starting point for this assertion.\n        var origLockSsfi = flag(this, 'lockSsfi');\n        flag(this, 'lockSsfi', true);\n        var result = getter(_super).call(this);\n        flag(this, 'lockSsfi', origLockSsfi);\n\n        if (result !== undefined) {\n          return result;\n        }\n\n        var newAssertion = new chai.Assertion();\n        transferFlags(this, newAssertion);\n        return newAssertion;\n      }\n    , configurable: true\n  });\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/overwriteProperty.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/proxify.js":
/*!************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/proxify.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var config = __webpack_require__(/*! ../config */ \"../../node_modules/chai/lib/chai/config.js\");\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\nvar getProperties = __webpack_require__(/*! ./getProperties */ \"../../node_modules/chai/lib/chai/utils/getProperties.js\");\nvar isProxyEnabled = __webpack_require__(/*! ./isProxyEnabled */ \"../../node_modules/chai/lib/chai/utils/isProxyEnabled.js\");\n\n/*!\n * Chai - proxify utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .proxify(object)\n *\n * Return a proxy of given object that throws an error when a non-existent\n * property is read. By default, the root cause is assumed to be a misspelled\n * property, and thus an attempt is made to offer a reasonable suggestion from\n * the list of existing properties. However, if a nonChainableMethodName is\n * provided, then the root cause is instead a failure to invoke a non-chainable\n * method prior to reading the non-existent property.\n *\n * If proxies are unsupported or disabled via the user's Chai config, then\n * return object without modification.\n *\n * @param {Object} obj\n * @param {String} nonChainableMethodName\n * @namespace Utils\n * @name proxify\n */\n\nvar builtins = ['__flags', '__methods', '_obj', 'assert'];\n\nmodule.exports = function proxify(obj, nonChainableMethodName) {\n  if (!isProxyEnabled()) return obj;\n\n  return new Proxy(obj, {\n    get: function proxyGetter(target, property) {\n      // This check is here because we should not throw errors on Symbol properties\n      // such as `Symbol.toStringTag`.\n      // The values for which an error should be thrown can be configured using\n      // the `config.proxyExcludedKeys` setting.\n      if (typeof property === 'string' &&\n          config.proxyExcludedKeys.indexOf(property) === -1 &&\n          !Reflect.has(target, property)) {\n        // Special message for invalid property access of non-chainable methods.\n        if (nonChainableMethodName) {\n          throw Error('Invalid Chai property: ' + nonChainableMethodName + '.' +\n            property + '. See docs for proper usage of \"' +\n            nonChainableMethodName + '\".');\n        }\n\n        // If the property is reasonably close to an existing Chai property,\n        // suggest that property to the user. Only suggest properties with a\n        // distance less than 4.\n        var suggestion = null;\n        var suggestionDistance = 4;\n        getProperties(target).forEach(function(prop) {\n          if (\n            !Object.prototype.hasOwnProperty(prop) &&\n            builtins.indexOf(prop) === -1\n          ) {\n            var dist = stringDistanceCapped(\n              property,\n              prop,\n              suggestionDistance\n            );\n            if (dist < suggestionDistance) {\n              suggestion = prop;\n              suggestionDistance = dist;\n            }\n          }\n        });\n\n        if (suggestion !== null) {\n          throw Error('Invalid Chai property: ' + property +\n            '. Did you mean \"' + suggestion + '\"?');\n        } else {\n          throw Error('Invalid Chai property: ' + property);\n        }\n      }\n\n      // Use this proxy getter as the starting point for removing implementation\n      // frames from the stack trace of a failed assertion. For property\n      // assertions, this prevents the proxy getter from showing up in the stack\n      // trace since it's invoked before the property getter. For method and\n      // chainable method assertions, this flag will end up getting changed to\n      // the method wrapper, which is good since this frame will no longer be in\n      // the stack once the method is invoked. Note that Chai builtin assertion\n      // properties such as `__flags` are skipped since this is only meant to\n      // capture the starting point of an assertion. This step is also skipped\n      // if the `lockSsfi` flag is set, thus indicating that this assertion is\n      // being called from within another assertion. In that case, the `ssfi`\n      // flag is already set to the outer assertion's starting point.\n      if (builtins.indexOf(property) === -1 && !flag(target, 'lockSsfi')) {\n        flag(target, 'ssfi', proxyGetter);\n      }\n\n      return Reflect.get(target, property);\n    }\n  });\n};\n\n/**\n * # stringDistanceCapped(strA, strB, cap)\n * Return the Levenshtein distance between two strings, but no more than cap.\n * @param {string} strA\n * @param {string} strB\n * @param {number} number\n * @return {number} min(string distance between strA and strB, cap)\n * @api private\n */\n\nfunction stringDistanceCapped(strA, strB, cap) {\n  if (Math.abs(strA.length - strB.length) >= cap) {\n    return cap;\n  }\n\n  var memo = [];\n  // `memo` is a two-dimensional array containing distances.\n  // memo[i][j] is the distance between strA.slice(0, i) and\n  // strB.slice(0, j).\n  for (var i = 0; i <= strA.length; i++) {\n    memo[i] = Array(strB.length + 1).fill(0);\n    memo[i][0] = i;\n  }\n  for (var j = 0; j < strB.length; j++) {\n    memo[0][j] = j;\n  }\n\n  for (var i = 1; i <= strA.length; i++) {\n    var ch = strA.charCodeAt(i - 1);\n    for (var j = 1; j <= strB.length; j++) {\n      if (Math.abs(i - j) >= cap) {\n        memo[i][j] = cap;\n        continue;\n      }\n      memo[i][j] = Math.min(\n        memo[i - 1][j] + 1,\n        memo[i][j - 1] + 1,\n        memo[i - 1][j - 1] +\n          (ch === strB.charCodeAt(j - 1) ? 0 : 1)\n      );\n    }\n  }\n\n  return memo[strA.length][strB.length];\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/proxify.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/test.js":
/*!*********************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/test.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Chai - test utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar flag = __webpack_require__(/*! ./flag */ \"../../node_modules/chai/lib/chai/utils/flag.js\");\n\n/**\n * ### .test(object, expression)\n *\n * Test and object for expression.\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @namespace Utils\n * @name test\n */\n\nmodule.exports = function test(obj, args) {\n  var negate = flag(obj, 'negate')\n    , expr = args[0];\n  return negate ? !expr : expr;\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/test.js?");

/***/ }),

/***/ "../../node_modules/chai/lib/chai/utils/transferFlags.js":
/*!******************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/chai/lib/chai/utils/transferFlags.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Chai - transferFlags utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .transferFlags(assertion, object, includeAll = true)\n *\n * Transfer all the flags for `assertion` to `object`. If\n * `includeAll` is set to `false`, then the base Chai\n * assertion flags (namely `object`, `ssfi`, `lockSsfi`,\n * and `message`) will not be transferred.\n *\n *\n *     var newAssertion = new Assertion();\n *     utils.transferFlags(assertion, newAssertion);\n *\n *     var anotherAssertion = new Assertion(myObj);\n *     utils.transferFlags(assertion, anotherAssertion, false);\n *\n * @param {Assertion} assertion the assertion to transfer the flags from\n * @param {Object} object the object to transfer the flags to; usually a new assertion\n * @param {Boolean} includeAll\n * @namespace Utils\n * @name transferFlags\n * @api private\n */\n\nmodule.exports = function transferFlags(assertion, object, includeAll) {\n  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\n  if (!object.__flags) {\n    object.__flags = Object.create(null);\n  }\n\n  includeAll = arguments.length === 3 ? includeAll : true;\n\n  for (var flag in flags) {\n    if (includeAll ||\n        (flag !== 'object' && flag !== 'ssfi' && flag !== 'lockSsfi' && flag != 'message')) {\n      object.__flags[flag] = flags[flag];\n    }\n  }\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/chai/lib/chai/utils/transferFlags.js?");

/***/ }),

/***/ "../../node_modules/check-error/index.js":
/*!**************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/check-error/index.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* !\n * Chai - checkError utility\n * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .checkError\n *\n * Checks that an error conforms to a given set of criteria and/or retrieves information about it.\n *\n * @api public\n */\n\n/**\n * ### .compatibleInstance(thrown, errorLike)\n *\n * Checks if two instances are compatible (strict equal).\n * Returns false if errorLike is not an instance of Error, because instances\n * can only be compatible if they're both error instances.\n *\n * @name compatibleInstance\n * @param {Error} thrown error\n * @param {Error|ErrorConstructor} errorLike object to compare against\n * @namespace Utils\n * @api public\n */\n\nfunction compatibleInstance(thrown, errorLike) {\n  return errorLike instanceof Error && thrown === errorLike;\n}\n\n/**\n * ### .compatibleConstructor(thrown, errorLike)\n *\n * Checks if two constructors are compatible.\n * This function can receive either an error constructor or\n * an error instance as the `errorLike` argument.\n * Constructors are compatible if they're the same or if one is\n * an instance of another.\n *\n * @name compatibleConstructor\n * @param {Error} thrown error\n * @param {Error|ErrorConstructor} errorLike object to compare against\n * @namespace Utils\n * @api public\n */\n\nfunction compatibleConstructor(thrown, errorLike) {\n  if (errorLike instanceof Error) {\n    // If `errorLike` is an instance of any error we compare their constructors\n    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;\n  } else if (errorLike.prototype instanceof Error || errorLike === Error) {\n    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly\n    return thrown.constructor === errorLike || thrown instanceof errorLike;\n  }\n\n  return false;\n}\n\n/**\n * ### .compatibleMessage(thrown, errMatcher)\n *\n * Checks if an error's message is compatible with a matcher (String or RegExp).\n * If the message contains the String or passes the RegExp test,\n * it is considered compatible.\n *\n * @name compatibleMessage\n * @param {Error} thrown error\n * @param {String|RegExp} errMatcher to look for into the message\n * @namespace Utils\n * @api public\n */\n\nfunction compatibleMessage(thrown, errMatcher) {\n  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;\n  if (errMatcher instanceof RegExp) {\n    return errMatcher.test(comparisonString);\n  } else if (typeof errMatcher === 'string') {\n    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers\n  }\n\n  return false;\n}\n\n/**\n * ### .getFunctionName(constructorFn)\n *\n * Returns the name of a function.\n * This also includes a polyfill function if `constructorFn.name` is not defined.\n *\n * @name getFunctionName\n * @param {Function} constructorFn\n * @namespace Utils\n * @api private\n */\n\nvar functionNameMatch = /\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\(\\/]+)/;\nfunction getFunctionName(constructorFn) {\n  var name = '';\n  if (typeof constructorFn.name === 'undefined') {\n    // Here we run a polyfill if constructorFn.name is not defined\n    var match = String(constructorFn).match(functionNameMatch);\n    if (match) {\n      name = match[1];\n    }\n  } else {\n    name = constructorFn.name;\n  }\n\n  return name;\n}\n\n/**\n * ### .getConstructorName(errorLike)\n *\n * Gets the constructor name for an Error instance or constructor itself.\n *\n * @name getConstructorName\n * @param {Error|ErrorConstructor} errorLike\n * @namespace Utils\n * @api public\n */\n\nfunction getConstructorName(errorLike) {\n  var constructorName = errorLike;\n  if (errorLike instanceof Error) {\n    constructorName = getFunctionName(errorLike.constructor);\n  } else if (typeof errorLike === 'function') {\n    // If `err` is not an instance of Error it is an error constructor itself or another function.\n    // If we've got a common function we get its name, otherwise we may need to create a new instance\n    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.\n    constructorName = getFunctionName(errorLike).trim() ||\n        getFunctionName(new errorLike()); // eslint-disable-line new-cap\n  }\n\n  return constructorName;\n}\n\n/**\n * ### .getMessage(errorLike)\n *\n * Gets the error message from an error.\n * If `err` is a String itself, we return it.\n * If the error has no message, we return an empty string.\n *\n * @name getMessage\n * @param {Error|String} errorLike\n * @namespace Utils\n * @api public\n */\n\nfunction getMessage(errorLike) {\n  var msg = '';\n  if (errorLike && errorLike.message) {\n    msg = errorLike.message;\n  } else if (typeof errorLike === 'string') {\n    msg = errorLike;\n  }\n\n  return msg;\n}\n\nmodule.exports = {\n  compatibleInstance: compatibleInstance,\n  compatibleConstructor: compatibleConstructor,\n  compatibleMessage: compatibleMessage,\n  getMessage: getMessage,\n  getConstructorName: getConstructorName,\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/check-error/index.js?");

/***/ }),

/***/ "../../node_modules/deep-eql/index.js":
/*!***********************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/deep-eql/index.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* globals Symbol: false, Uint8Array: false, WeakMap: false */\n/*!\n * deep-eql\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar type = __webpack_require__(/*! type-detect */ \"../../node_modules/type-detect/type-detect.js\");\nfunction FakeMap() {\n  this._key = 'chai/deep-eql__' + Math.random() + Date.now();\n}\n\nFakeMap.prototype = {\n  get: function getMap(key) {\n    return key[this._key];\n  },\n  set: function setMap(key, value) {\n    if (Object.isExtensible(key)) {\n      Object.defineProperty(key, this._key, {\n        value: value,\n        configurable: true,\n      });\n    }\n  },\n};\n\nvar MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;\n/*!\n * Check to see if the MemoizeMap has recorded a result of the two operands\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @returns {Boolean|null} result\n*/\nfunction memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    return null;\n  }\n  var leftHandMap = memoizeMap.get(leftHandOperand);\n  if (leftHandMap) {\n    var result = leftHandMap.get(rightHandOperand);\n    if (typeof result === 'boolean') {\n      return result;\n    }\n  }\n  return null;\n}\n\n/*!\n * Set the result of the equality into the MemoizeMap\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {MemoizeMap} memoizeMap\n * @param {Boolean} result\n*/\nfunction memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {\n  // Technically, WeakMap keys can *only* be objects, not primitives.\n  if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    return;\n  }\n  var leftHandMap = memoizeMap.get(leftHandOperand);\n  if (leftHandMap) {\n    leftHandMap.set(rightHandOperand, result);\n  } else {\n    leftHandMap = new MemoizeMap();\n    leftHandMap.set(rightHandOperand, result);\n    memoizeMap.set(leftHandOperand, leftHandMap);\n  }\n}\n\n/*!\n * Primary Export\n */\n\nmodule.exports = deepEqual;\nmodule.exports.MemoizeMap = MemoizeMap;\n\n/**\n * Assert deeply nested sameValue equality between two objects of any type.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.\n * @return {Boolean} equal match\n */\nfunction deepEqual(leftHandOperand, rightHandOperand, options) {\n  // If we have a comparator, we can't assume anything; so bail to its check first.\n  if (options && options.comparator) {\n    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\n  }\n\n  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\n  if (simpleResult !== null) {\n    return simpleResult;\n  }\n\n  // Deeper comparisons are pushed through to a larger function\n  return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);\n}\n\n/**\n * Many comparisons can be canceled out early via simple equality or primitive checks.\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @return {Boolean|null} equal match\n */\nfunction simpleEqual(leftHandOperand, rightHandOperand) {\n  // Equal references (except for Numbers) can be returned early\n  if (leftHandOperand === rightHandOperand) {\n    // Handle +-0 cases\n    return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;\n  }\n\n  // handle NaN cases\n  if (\n    leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare\n    rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare\n  ) {\n    return true;\n  }\n\n  // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,\n  // strings, and undefined, can be compared by reference.\n  if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {\n    // Easy out b/c it would have passed the first equality check\n    return false;\n  }\n  return null;\n}\n\n/*!\n * The main logic of the `deepEqual` function.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (optional) Additional options\n * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.\n * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of\n    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular\n    references to blow the stack.\n * @return {Boolean} equal match\n*/\nfunction extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {\n  options = options || {};\n  options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();\n  var comparator = options && options.comparator;\n\n  // Check if a memoized result exists.\n  var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);\n  if (memoizeResultLeft !== null) {\n    return memoizeResultLeft;\n  }\n  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);\n  if (memoizeResultRight !== null) {\n    return memoizeResultRight;\n  }\n\n  // If a comparator is present, use it.\n  if (comparator) {\n    var comparatorResult = comparator(leftHandOperand, rightHandOperand);\n    // Comparators may return null, in which case we want to go back to default behavior.\n    if (comparatorResult === false || comparatorResult === true) {\n      memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);\n      return comparatorResult;\n    }\n    // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide\n    // what to do, we need to make sure to return the basic tests first before we move on.\n    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);\n    if (simpleResult !== null) {\n      // Don't memoize this, it takes longer to set/retrieve than to just compare.\n      return simpleResult;\n    }\n  }\n\n  var leftHandType = type(leftHandOperand);\n  if (leftHandType !== type(rightHandOperand)) {\n    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);\n    return false;\n  }\n\n  // Temporarily set the operands in the memoize object to prevent blowing the stack\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);\n\n  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);\n  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);\n  return result;\n}\n\nfunction extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {\n  switch (leftHandType) {\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n    case 'Date':\n      // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values\n      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());\n    case 'Promise':\n    case 'Symbol':\n    case 'function':\n    case 'WeakMap':\n    case 'WeakSet':\n    case 'Error':\n      return leftHandOperand === rightHandOperand;\n    case 'Arguments':\n    case 'Int8Array':\n    case 'Uint8Array':\n    case 'Uint8ClampedArray':\n    case 'Int16Array':\n    case 'Uint16Array':\n    case 'Int32Array':\n    case 'Uint32Array':\n    case 'Float32Array':\n    case 'Float64Array':\n    case 'Array':\n      return iterableEqual(leftHandOperand, rightHandOperand, options);\n    case 'RegExp':\n      return regexpEqual(leftHandOperand, rightHandOperand);\n    case 'Generator':\n      return generatorEqual(leftHandOperand, rightHandOperand, options);\n    case 'DataView':\n      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);\n    case 'ArrayBuffer':\n      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);\n    case 'Set':\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\n    case 'Map':\n      return entriesEqual(leftHandOperand, rightHandOperand, options);\n    default:\n      return objectEqual(leftHandOperand, rightHandOperand, options);\n  }\n}\n\n/*!\n * Compare two Regular Expressions for equality.\n *\n * @param {RegExp} leftHandOperand\n * @param {RegExp} rightHandOperand\n * @return {Boolean} result\n */\n\nfunction regexpEqual(leftHandOperand, rightHandOperand) {\n  return leftHandOperand.toString() === rightHandOperand.toString();\n}\n\n/*!\n * Compare two Sets/Maps for equality. Faster than other equality functions.\n *\n * @param {Set} leftHandOperand\n * @param {Set} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction entriesEqual(leftHandOperand, rightHandOperand, options) {\n  // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach\n  if (leftHandOperand.size !== rightHandOperand.size) {\n    return false;\n  }\n  if (leftHandOperand.size === 0) {\n    return true;\n  }\n  var leftHandItems = [];\n  var rightHandItems = [];\n  leftHandOperand.forEach(function gatherEntries(key, value) {\n    leftHandItems.push([ key, value ]);\n  });\n  rightHandOperand.forEach(function gatherEntries(key, value) {\n    rightHandItems.push([ key, value ]);\n  });\n  return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);\n}\n\n/*!\n * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction iterableEqual(leftHandOperand, rightHandOperand, options) {\n  var length = leftHandOperand.length;\n  if (length !== rightHandOperand.length) {\n    return false;\n  }\n  if (length === 0) {\n    return true;\n  }\n  var index = -1;\n  while (++index < length) {\n    if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*!\n * Simple equality for generator objects such as those returned by generator functions.\n *\n * @param {Iterable} leftHandOperand\n * @param {Iterable} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction generatorEqual(leftHandOperand, rightHandOperand, options) {\n  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);\n}\n\n/*!\n * Determine if the given object has an @@iterator function.\n *\n * @param {Object} target\n * @return {Boolean} `true` if the object has an @@iterator function.\n */\nfunction hasIteratorFunction(target) {\n  return typeof Symbol !== 'undefined' &&\n    typeof target === 'object' &&\n    typeof Symbol.iterator !== 'undefined' &&\n    typeof target[Symbol.iterator] === 'function';\n}\n\n/*!\n * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.\n * This will consume the iterator - which could have side effects depending on the @@iterator implementation.\n *\n * @param {Object} target\n * @returns {Array} an array of entries from the @@iterator function\n */\nfunction getIteratorEntries(target) {\n  if (hasIteratorFunction(target)) {\n    try {\n      return getGeneratorEntries(target[Symbol.iterator]());\n    } catch (iteratorError) {\n      return [];\n    }\n  }\n  return [];\n}\n\n/*!\n * Gets all entries from a Generator. This will consume the generator - which could have side effects.\n *\n * @param {Generator} target\n * @returns {Array} an array of entries from the Generator.\n */\nfunction getGeneratorEntries(generator) {\n  var generatorResult = generator.next();\n  var accumulator = [ generatorResult.value ];\n  while (generatorResult.done === false) {\n    generatorResult = generator.next();\n    accumulator.push(generatorResult.value);\n  }\n  return accumulator;\n}\n\n/*!\n * Gets all own and inherited enumerable keys from a target.\n *\n * @param {Object} target\n * @returns {Array} an array of own and inherited enumerable keys from the target.\n */\nfunction getEnumerableKeys(target) {\n  var keys = [];\n  for (var key in target) {\n    keys.push(key);\n  }\n  return keys;\n}\n\n/*!\n * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of\n * each key. If any value of the given key is not equal, the function will return false (early).\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\nfunction keysEqual(leftHandOperand, rightHandOperand, keys, options) {\n  var length = keys.length;\n  if (length === 0) {\n    return true;\n  }\n  for (var i = 0; i < length; i += 1) {\n    if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*!\n * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`\n * for each enumerable key in the object.\n *\n * @param {Mixed} leftHandOperand\n * @param {Mixed} rightHandOperand\n * @param {Object} [options] (Optional)\n * @return {Boolean} result\n */\n\nfunction objectEqual(leftHandOperand, rightHandOperand, options) {\n  var leftHandKeys = getEnumerableKeys(leftHandOperand);\n  var rightHandKeys = getEnumerableKeys(rightHandOperand);\n  if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {\n    leftHandKeys.sort();\n    rightHandKeys.sort();\n    if (iterableEqual(leftHandKeys, rightHandKeys) === false) {\n      return false;\n    }\n    return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);\n  }\n\n  var leftHandEntries = getIteratorEntries(leftHandOperand);\n  var rightHandEntries = getIteratorEntries(rightHandOperand);\n  if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {\n    leftHandEntries.sort();\n    rightHandEntries.sort();\n    return iterableEqual(leftHandEntries, rightHandEntries, options);\n  }\n\n  if (leftHandKeys.length === 0 &&\n      leftHandEntries.length === 0 &&\n      rightHandKeys.length === 0 &&\n      rightHandEntries.length === 0) {\n    return true;\n  }\n\n  return false;\n}\n\n/*!\n * Returns true if the argument is a primitive.\n *\n * This intentionally returns true for all objects that can be compared by reference,\n * including functions and symbols.\n *\n * @param {Mixed} value\n * @return {Boolean} result\n */\nfunction isPrimitive(value) {\n  return value === null || typeof value !== 'object';\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/deep-eql/index.js?");

/***/ }),

/***/ "../../node_modules/get-func-name/index.js":
/*!****************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/get-func-name/index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* !\n * Chai - getFuncName utility\n * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getFuncName(constructorFn)\n *\n * Returns the name of a function.\n * When a non-function instance is passed, returns `null`.\n * This also includes a polyfill function if `aFunc.name` is not defined.\n *\n * @name getFuncName\n * @param {Function} funct\n * @namespace Utils\n * @api public\n */\n\nvar toString = Function.prototype.toString;\nvar functionNameMatch = /\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\s\\(\\/]+)/;\nfunction getFuncName(aFunc) {\n  if (typeof aFunc !== 'function') {\n    return null;\n  }\n\n  var name = '';\n  if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {\n    // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined\n    var match = toString.call(aFunc).match(functionNameMatch);\n    if (match) {\n      name = match[1];\n    }\n  } else {\n    // If we've got a `name` property we just use it\n    name = aFunc.name;\n  }\n\n  return name;\n}\n\nmodule.exports = getFuncName;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/get-func-name/index.js?");

/***/ }),

/***/ "../../node_modules/isomorphic-fetch/fetch-npm-browserify.js":
/*!**********************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/isomorphic-fetch/fetch-npm-browserify.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\n__webpack_require__(/*! whatwg-fetch */ \"../../node_modules/isomorphic-fetch/node_modules/whatwg-fetch/fetch.js\");\nmodule.exports = self.fetch.bind(self);\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/isomorphic-fetch/fetch-npm-browserify.js?");

/***/ }),

/***/ "../../node_modules/isomorphic-fetch/node_modules/whatwg-fetch/fetch.js":
/*!*********************************************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/isomorphic-fetch/node_modules/whatwg-fetch/fetch.js ***!
  \*********************************************************************************************************************************/
/*! exports provided: Headers, Request, Response, DOMException, fetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Headers\", function() { return Headers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Request\", function() { return Request; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Response\", function() { return Response; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DOMException\", function() { return DOMException; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetch\", function() { return fetch; });\nvar global =\n  (typeof globalThis !== 'undefined' && globalThis) ||\n  (typeof self !== 'undefined' && self) ||\n  (typeof global !== 'undefined' && global)\n\nvar support = {\n  searchParams: 'URLSearchParams' in global,\n  iterable: 'Symbol' in global && 'iterator' in Symbol,\n  blob:\n    'FileReader' in global &&\n    'Blob' in global &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in global,\n  arrayBuffer: 'ArrayBuffer' in global\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n    throw new TypeError('Invalid character in header field name')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nfunction Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsText(blob)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */\n    this.bodyUsed = this.bodyUsed\n    this._bodyInit = body\n    if (!body) {\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        var isConsumed = consumed(this)\n        if (isConsumed) {\n          return isConsumed\n        }\n        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n          return Promise.resolve(\n            this._bodyArrayBuffer.buffer.slice(\n              this._bodyArrayBuffer.byteOffset,\n              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n            )\n          )\n        } else {\n          return Promise.resolve(this._bodyArrayBuffer)\n        }\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n\n  if (this.method === 'GET' || this.method === 'HEAD') {\n    if (options.cache === 'no-store' || options.cache === 'no-cache') {\n      // Search for a '_' parameter in the query string\n      var reParamSearch = /([?&])_=[^&]*/\n      if (reParamSearch.test(this.url)) {\n        // If it already exists then set the value with the current time\n        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())\n      } else {\n        // Otherwise add a new '_' parameter to the end with the current time\n        var reQueryString = /\\?/\n        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()\n      }\n    }\n  }\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n    var parts = line.split(':')\n    var key = parts.shift().trim()\n    if (key) {\n      var value = parts.join(':').trim()\n      headers.append(key, value)\n    }\n  })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = 'statusText' in options ? options.statusText : ''\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 0, statusText: ''})\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nvar DOMException = global.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nfunction fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      setTimeout(function() {\n        resolve(new Response(body, options))\n      }, 0)\n    }\n\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException('Aborted', 'AbortError'))\n      }, 0)\n    }\n\n    function fixUrl(url) {\n      try {\n        return url === '' && global.location.href ? global.location.href : url\n      } catch (e) {\n        return url\n      }\n    }\n\n    xhr.open(request.method, fixUrl(request.url), true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr) {\n      if (support.blob) {\n        xhr.responseType = 'blob'\n      } else if (\n        support.arrayBuffer &&\n        request.headers.get('Content-Type') &&\n        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1\n      ) {\n        xhr.responseType = 'arraybuffer'\n      }\n    }\n\n    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))\n      })\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n    }\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch.polyfill = true\n\nif (!global.fetch) {\n  global.fetch = fetch\n  global.Headers = Headers\n  global.Request = Request\n  global.Response = Response\n}\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/isomorphic-fetch/node_modules/whatwg-fetch/fetch.js?");

/***/ }),

/***/ "../../node_modules/marked/src/InlineLexer.js":
/*!*******************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/marked/src/InlineLexer.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Renderer = __webpack_require__(/*! ./Renderer.js */ \"../../node_modules/marked/src/Renderer.js\");\nconst { defaults } = __webpack_require__(/*! ./defaults.js */ \"../../node_modules/marked/src/defaults.js\");\nconst { inline } = __webpack_require__(/*! ./rules.js */ \"../../node_modules/marked/src/rules.js\");\nconst {\n  findClosingBracket,\n  escape\n} = __webpack_require__(/*! ./helpers.js */ \"../../node_modules/marked/src/helpers.js\");\n\n/**\n * Inline Lexer & Compiler\n */\nmodule.exports = class InlineLexer {\n  constructor(links, options) {\n    this.options = options || defaults;\n    this.links = links;\n    this.rules = inline.normal;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n\n    if (!this.links) {\n      throw new Error('Tokens array requires a `links` property.');\n    }\n\n    if (this.options.pedantic) {\n      this.rules = inline.pedantic;\n    } else if (this.options.gfm) {\n      if (this.options.breaks) {\n        this.rules = inline.breaks;\n      } else {\n        this.rules = inline.gfm;\n      }\n    }\n  }\n\n  /**\n   * Expose Inline Rules\n   */\n  static get rules() {\n    return inline;\n  }\n\n  /**\n   * Static Lexing/Compiling Method\n   */\n  static output(src, links, options) {\n    const inline = new InlineLexer(links, options);\n    return inline.output(src);\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  output(src) {\n    let out = '',\n      link,\n      text,\n      href,\n      title,\n      cap,\n      prevCapZero;\n\n    while (src) {\n      // escape\n      if (cap = this.rules.escape.exec(src)) {\n        src = src.substring(cap[0].length);\n        out += escape(cap[1]);\n        continue;\n      }\n\n      // tag\n      if (cap = this.rules.tag.exec(src)) {\n        if (!this.inLink && /^<a /i.test(cap[0])) {\n          this.inLink = true;\n        } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\n          this.inLink = false;\n        }\n        if (!this.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.inRawBlock = true;\n        } else if (this.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.inRawBlock = false;\n        }\n\n        src = src.substring(cap[0].length);\n        out += this.options.sanitize\n          ? this.options.sanitizer\n            ? this.options.sanitizer(cap[0])\n            : escape(cap[0])\n          : cap[0];\n        continue;\n      }\n\n      // link\n      if (cap = this.rules.link.exec(src)) {\n        const lastParenIndex = findClosingBracket(cap[2], '()');\n        if (lastParenIndex > -1) {\n          const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          const linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n        src = src.substring(cap[0].length);\n        this.inLink = true;\n        href = cap[2];\n        if (this.options.pedantic) {\n          link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n          if (link) {\n            href = link[1];\n            title = link[3];\n          } else {\n            title = '';\n          }\n        } else {\n          title = cap[3] ? cap[3].slice(1, -1) : '';\n        }\n        href = href.trim().replace(/^<([\\s\\S]*)>$/, '$1');\n        out += this.outputLink(cap, {\n          href: InlineLexer.escapes(href),\n          title: InlineLexer.escapes(title)\n        });\n        this.inLink = false;\n        continue;\n      }\n\n      // reflink, nolink\n      if ((cap = this.rules.reflink.exec(src))\n          || (cap = this.rules.nolink.exec(src))) {\n        src = src.substring(cap[0].length);\n        link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n        link = this.links[link.toLowerCase()];\n        if (!link || !link.href) {\n          out += cap[0].charAt(0);\n          src = cap[0].substring(1) + src;\n          continue;\n        }\n        this.inLink = true;\n        out += this.outputLink(cap, link);\n        this.inLink = false;\n        continue;\n      }\n\n      // strong\n      if (cap = this.rules.strong.exec(src)) {\n        src = src.substring(cap[0].length);\n        out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));\n        continue;\n      }\n\n      // em\n      if (cap = this.rules.em.exec(src)) {\n        src = src.substring(cap[0].length);\n        out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));\n        continue;\n      }\n\n      // code\n      if (cap = this.rules.code.exec(src)) {\n        src = src.substring(cap[0].length);\n        out += this.renderer.codespan(escape(cap[2].trim(), true));\n        continue;\n      }\n\n      // br\n      if (cap = this.rules.br.exec(src)) {\n        src = src.substring(cap[0].length);\n        out += this.renderer.br();\n        continue;\n      }\n\n      // del (gfm)\n      if (cap = this.rules.del.exec(src)) {\n        src = src.substring(cap[0].length);\n        out += this.renderer.del(this.output(cap[1]));\n        continue;\n      }\n\n      // autolink\n      if (cap = this.rules.autolink.exec(src)) {\n        src = src.substring(cap[0].length);\n        if (cap[2] === '@') {\n          text = escape(this.mangle(cap[1]));\n          href = 'mailto:' + text;\n        } else {\n          text = escape(cap[1]);\n          href = text;\n        }\n        out += this.renderer.link(href, null, text);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.inLink && (cap = this.rules.url.exec(src))) {\n        if (cap[2] === '@') {\n          text = escape(cap[0]);\n          href = 'mailto:' + text;\n        } else {\n          // do extended autolink path validation\n          do {\n            prevCapZero = cap[0];\n            cap[0] = this.rules._backpedal.exec(cap[0])[0];\n          } while (prevCapZero !== cap[0]);\n          text = escape(cap[0]);\n          if (cap[1] === 'www.') {\n            href = 'http://' + text;\n          } else {\n            href = text;\n          }\n        }\n        src = src.substring(cap[0].length);\n        out += this.renderer.link(href, null, text);\n        continue;\n      }\n\n      // text\n      if (cap = this.rules.text.exec(src)) {\n        src = src.substring(cap[0].length);\n        if (this.inRawBlock) {\n          out += this.renderer.text(this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]);\n        } else {\n          out += this.renderer.text(escape(this.smartypants(cap[0])));\n        }\n        continue;\n      }\n\n      if (src) {\n        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n      }\n    }\n\n    return out;\n  }\n\n  static escapes(text) {\n    return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;\n  }\n\n  /**\n   * Compile Link\n   */\n  outputLink(cap, link) {\n    const href = link.href,\n      title = link.title ? escape(link.title) : null;\n\n    return cap[0].charAt(0) !== '!'\n      ? this.renderer.link(href, title, this.output(cap[1]))\n      : this.renderer.image(href, title, escape(cap[1]));\n  }\n\n  /**\n   * Smartypants Transformations\n   */\n  smartypants(text) {\n    if (!this.options.smartypants) return text;\n    return text\n      // em-dashes\n      .replace(/---/g, '\\u2014')\n      // en-dashes\n      .replace(/--/g, '\\u2013')\n      // opening singles\n      .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n      // closing singles & apostrophes\n      .replace(/'/g, '\\u2019')\n      // opening doubles\n      .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n      // closing doubles\n      .replace(/\"/g, '\\u201d')\n      // ellipses\n      .replace(/\\.{3}/g, '\\u2026');\n  }\n\n  /**\n   * Mangle Links\n   */\n  mangle(text) {\n    if (!this.options.mangle) return text;\n    const l = text.length;\n    let out = '',\n      i = 0,\n      ch;\n\n    for (; i < l; i++) {\n      ch = text.charCodeAt(i);\n      if (Math.random() > 0.5) {\n        ch = 'x' + ch.toString(16);\n      }\n      out += '&#' + ch + ';';\n    }\n\n    return out;\n  }\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/marked/src/InlineLexer.js?");

/***/ }),

/***/ "../../node_modules/marked/src/Lexer.js":
/*!*************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/marked/src/Lexer.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { defaults } = __webpack_require__(/*! ./defaults.js */ \"../../node_modules/marked/src/defaults.js\");\nconst { block } = __webpack_require__(/*! ./rules.js */ \"../../node_modules/marked/src/rules.js\");\nconst {\n  rtrim,\n  splitCells,\n  escape\n} = __webpack_require__(/*! ./helpers.js */ \"../../node_modules/marked/src/helpers.js\");\n\n/**\n * Block Lexer\n */\nmodule.exports = class Lexer {\n  constructor(options) {\n    this.tokens = [];\n    this.tokens.links = Object.create(null);\n    this.options = options || defaults;\n    this.rules = block.normal;\n\n    if (this.options.pedantic) {\n      this.rules = block.pedantic;\n    } else if (this.options.gfm) {\n      this.rules = block.gfm;\n    }\n  }\n\n  /**\n   * Expose Block Rules\n   */\n  static get rules() {\n    return block;\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.lex(src);\n  };\n\n  /**\n   * Preprocessing\n   */\n  lex(src) {\n    src = src\n      .replace(/\\r\\n|\\r/g, '\\n')\n      .replace(/\\t/g, '    ');\n\n    return this.token(src, true);\n  };\n\n  /**\n   * Lexing\n   */\n  token(src, top) {\n    src = src.replace(/^ +$/gm, '');\n    let next,\n      loose,\n      cap,\n      bull,\n      b,\n      item,\n      listStart,\n      listItems,\n      t,\n      space,\n      i,\n      tag,\n      l,\n      isordered,\n      istask,\n      ischecked;\n\n    while (src) {\n      // newline\n      if (cap = this.rules.newline.exec(src)) {\n        src = src.substring(cap[0].length);\n        if (cap[0].length > 1) {\n          this.tokens.push({\n            type: 'space'\n          });\n        }\n      }\n\n      // code\n      if (cap = this.rules.code.exec(src)) {\n        const lastToken = this.tokens[this.tokens.length - 1];\n        src = src.substring(cap[0].length);\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken && lastToken.type === 'paragraph') {\n          lastToken.text += '\\n' + cap[0].trimRight();\n        } else {\n          cap = cap[0].replace(/^ {4}/gm, '');\n          this.tokens.push({\n            type: 'code',\n            codeBlockStyle: 'indented',\n            text: !this.options.pedantic\n              ? rtrim(cap, '\\n')\n              : cap\n          });\n        }\n        continue;\n      }\n\n      // fences\n      if (cap = this.rules.fences.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'code',\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: cap[3] || ''\n        });\n        continue;\n      }\n\n      // heading\n      if (cap = this.rules.heading.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'heading',\n          depth: cap[1].length,\n          text: cap[2]\n        });\n        continue;\n      }\n\n      // table no leading pipe (gfm)\n      if (cap = this.rules.nptable.exec(src)) {\n        item = {\n          type: 'table',\n          header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          src = src.substring(cap[0].length);\n\n          for (i = 0; i < item.align.length; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          for (i = 0; i < item.cells.length; i++) {\n            item.cells[i] = splitCells(item.cells[i], item.header.length);\n          }\n\n          this.tokens.push(item);\n\n          continue;\n        }\n      }\n\n      // hr\n      if (cap = this.rules.hr.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'hr'\n        });\n        continue;\n      }\n\n      // blockquote\n      if (cap = this.rules.blockquote.exec(src)) {\n        src = src.substring(cap[0].length);\n\n        this.tokens.push({\n          type: 'blockquote_start'\n        });\n\n        cap = cap[0].replace(/^ *> ?/gm, '');\n\n        // Pass `top` to keep the current\n        // \"toplevel\" state. This is exactly\n        // how markdown.pl works.\n        this.token(cap, top);\n\n        this.tokens.push({\n          type: 'blockquote_end'\n        });\n\n        continue;\n      }\n\n      // list\n      if (cap = this.rules.list.exec(src)) {\n        src = src.substring(cap[0].length);\n        bull = cap[2];\n        isordered = bull.length > 1;\n\n        listStart = {\n          type: 'list_start',\n          ordered: isordered,\n          start: isordered ? +bull : '',\n          loose: false\n        };\n\n        this.tokens.push(listStart);\n\n        // Get each top-level item.\n        cap = cap[0].match(this.rules.item);\n\n        listItems = [];\n        next = false;\n        l = cap.length;\n        i = 0;\n\n        for (; i < l; i++) {\n          item = cap[i];\n\n          // Remove the list item's bullet\n          // so it is seen as the next token.\n          space = item.length;\n          item = item.replace(/^ *([*+-]|\\d+\\.) */, '');\n\n          // Outdent whatever the\n          // list item contains. Hacky.\n          if (~item.indexOf('\\n ')) {\n            space -= item.length;\n            item = !this.options.pedantic\n              ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n              : item.replace(/^ {1,4}/gm, '');\n          }\n\n          // Determine whether the next list item belongs here.\n          // Backpedal if it does not belong in this list.\n          if (i !== l - 1) {\n            b = block.bullet.exec(cap[i + 1])[0];\n            if (bull.length > 1 ? b.length === 1\n              : (b.length > 1 || (this.options.smartLists && b !== bull))) {\n              src = cap.slice(i + 1).join('\\n') + src;\n              i = l - 1;\n            }\n          }\n\n          // Determine whether item is loose or not.\n          // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n          // for discount behavior.\n          loose = next || /\\n\\n(?!\\s*$)/.test(item);\n          if (i !== l - 1) {\n            next = item.charAt(item.length - 1) === '\\n';\n            if (!loose) loose = next;\n          }\n\n          if (loose) {\n            listStart.loose = true;\n          }\n\n          // Check for task list items\n          istask = /^\\[[ xX]\\] /.test(item);\n          ischecked = undefined;\n          if (istask) {\n            ischecked = item[1] !== ' ';\n            item = item.replace(/^\\[[ xX]\\] +/, '');\n          }\n\n          t = {\n            type: 'list_item_start',\n            task: istask,\n            checked: ischecked,\n            loose: loose\n          };\n\n          listItems.push(t);\n          this.tokens.push(t);\n\n          // Recurse.\n          this.token(item, false);\n\n          this.tokens.push({\n            type: 'list_item_end'\n          });\n        }\n\n        if (listStart.loose) {\n          l = listItems.length;\n          i = 0;\n          for (; i < l; i++) {\n            listItems[i].loose = true;\n          }\n        }\n\n        this.tokens.push({\n          type: 'list_end'\n        });\n\n        continue;\n      }\n\n      // html\n      if (cap = this.rules.html.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: this.options.sanitize\n            ? 'paragraph'\n            : 'html',\n          pre: !this.options.sanitizer\n            && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]\n        });\n        continue;\n      }\n\n      // def\n      if (top && (cap = this.rules.def.exec(src))) {\n        src = src.substring(cap[0].length);\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        if (!this.tokens.links[tag]) {\n          this.tokens.links[tag] = {\n            href: cap[2],\n            title: cap[3]\n          };\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (cap = this.rules.table.exec(src)) {\n        item = {\n          type: 'table',\n          header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          src = src.substring(cap[0].length);\n\n          for (i = 0; i < item.align.length; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          for (i = 0; i < item.cells.length; i++) {\n            item.cells[i] = splitCells(\n              item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''),\n              item.header.length);\n          }\n\n          this.tokens.push(item);\n\n          continue;\n        }\n      }\n\n      // lheading\n      if (cap = this.rules.lheading.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'heading',\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1]\n        });\n        continue;\n      }\n\n      // top-level paragraph\n      if (top && (cap = this.rules.paragraph.exec(src))) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'paragraph',\n          text: cap[1].charAt(cap[1].length - 1) === '\\n'\n            ? cap[1].slice(0, -1)\n            : cap[1]\n        });\n        continue;\n      }\n\n      // text\n      if (cap = this.rules.text.exec(src)) {\n        // Top-level should never reach here.\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'text',\n          text: cap[0]\n        });\n        continue;\n      }\n\n      if (src) {\n        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n      }\n    }\n\n    return this.tokens;\n  };\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/marked/src/Lexer.js?");

/***/ }),

/***/ "../../node_modules/marked/src/Parser.js":
/*!**************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/marked/src/Parser.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Renderer = __webpack_require__(/*! ./Renderer.js */ \"../../node_modules/marked/src/Renderer.js\");\nconst Slugger = __webpack_require__(/*! ./Slugger.js */ \"../../node_modules/marked/src/Slugger.js\");\nconst InlineLexer = __webpack_require__(/*! ./InlineLexer.js */ \"../../node_modules/marked/src/InlineLexer.js\");\nconst TextRenderer = __webpack_require__(/*! ./TextRenderer.js */ \"../../node_modules/marked/src/TextRenderer.js\");\nconst { defaults } = __webpack_require__(/*! ./defaults.js */ \"../../node_modules/marked/src/defaults.js\");\nconst {\n  merge,\n  unescape\n} = __webpack_require__(/*! ./helpers.js */ \"../../node_modules/marked/src/helpers.js\");\n\n/**\n * Parsing & Compiling\n */\nmodule.exports = class Parser {\n  constructor(options) {\n    this.tokens = [];\n    this.token = null;\n    this.options = options || defaults;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.slugger = new Slugger();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parse(tokens);\n  };\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens) {\n    this.inline = new InlineLexer(tokens.links, this.options);\n    // use an InlineLexer with a TextRenderer to extract pure text\n    this.inlineText = new InlineLexer(\n      tokens.links,\n      merge({}, this.options, { renderer: new TextRenderer() })\n    );\n    this.tokens = tokens.reverse();\n\n    let out = '';\n    while (this.next()) {\n      out += this.tok();\n    }\n\n    return out;\n  };\n\n  /**\n   * Next Token\n   */\n  next() {\n    this.token = this.tokens.pop();\n    return this.token;\n  };\n\n  /**\n   * Preview Next Token\n   */\n  peek() {\n    return this.tokens[this.tokens.length - 1] || 0;\n  };\n\n  /**\n   * Parse Text Tokens\n   */\n  parseText() {\n    let body = this.token.text;\n\n    while (this.peek().type === 'text') {\n      body += '\\n' + this.next().text;\n    }\n\n    return this.inline.output(body);\n  };\n\n  /**\n   * Parse Current Token\n   */\n  tok() {\n    let body = '';\n    switch (this.token.type) {\n      case 'space': {\n        return '';\n      }\n      case 'hr': {\n        return this.renderer.hr();\n      }\n      case 'heading': {\n        return this.renderer.heading(\n          this.inline.output(this.token.text),\n          this.token.depth,\n          unescape(this.inlineText.output(this.token.text)),\n          this.slugger);\n      }\n      case 'code': {\n        return this.renderer.code(this.token.text,\n          this.token.lang,\n          this.token.escaped);\n      }\n      case 'table': {\n        let header = '',\n          i,\n          row,\n          cell,\n          j;\n\n        // header\n        cell = '';\n        for (i = 0; i < this.token.header.length; i++) {\n          cell += this.renderer.tablecell(\n            this.inline.output(this.token.header[i]),\n            { header: true, align: this.token.align[i] }\n          );\n        }\n        header += this.renderer.tablerow(cell);\n\n        for (i = 0; i < this.token.cells.length; i++) {\n          row = this.token.cells[i];\n\n          cell = '';\n          for (j = 0; j < row.length; j++) {\n            cell += this.renderer.tablecell(\n              this.inline.output(row[j]),\n              { header: false, align: this.token.align[j] }\n            );\n          }\n\n          body += this.renderer.tablerow(cell);\n        }\n        return this.renderer.table(header, body);\n      }\n      case 'blockquote_start': {\n        body = '';\n\n        while (this.next().type !== 'blockquote_end') {\n          body += this.tok();\n        }\n\n        return this.renderer.blockquote(body);\n      }\n      case 'list_start': {\n        body = '';\n        const ordered = this.token.ordered,\n          start = this.token.start;\n\n        while (this.next().type !== 'list_end') {\n          body += this.tok();\n        }\n\n        return this.renderer.list(body, ordered, start);\n      }\n      case 'list_item_start': {\n        body = '';\n        const loose = this.token.loose;\n        const checked = this.token.checked;\n        const task = this.token.task;\n\n        if (this.token.task) {\n          if (loose) {\n            if (this.peek().type === 'text') {\n              const nextToken = this.peek();\n              nextToken.text = this.renderer.checkbox(checked) + ' ' + nextToken.text;\n            } else {\n              this.tokens.push({\n                type: 'text',\n                text: this.renderer.checkbox(checked)\n              });\n            }\n          } else {\n            body += this.renderer.checkbox(checked);\n          }\n        }\n\n        while (this.next().type !== 'list_item_end') {\n          body += !loose && this.token.type === 'text'\n            ? this.parseText()\n            : this.tok();\n        }\n        return this.renderer.listitem(body, task, checked);\n      }\n      case 'html': {\n        // TODO parse inline content if parameter markdown=1\n        return this.renderer.html(this.token.text);\n      }\n      case 'paragraph': {\n        return this.renderer.paragraph(this.inline.output(this.token.text));\n      }\n      case 'text': {\n        return this.renderer.paragraph(this.parseText());\n      }\n      default: {\n        const errMsg = 'Token with \"' + this.token.type + '\" type was not found.';\n        if (this.options.silent) {\n          console.log(errMsg);\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n  };\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/marked/src/Parser.js?");

/***/ }),

/***/ "../../node_modules/marked/src/Renderer.js":
/*!****************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/marked/src/Renderer.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { defaults } = __webpack_require__(/*! ./defaults.js */ \"../../node_modules/marked/src/defaults.js\");\nconst {\n  cleanUrl,\n  escape\n} = __webpack_require__(/*! ./helpers.js */ \"../../node_modules/marked/src/helpers.js\");\n\n/**\n * Renderer\n */\nmodule.exports = class Renderer {\n  constructor(options) {\n    this.options = options || defaults;\n  }\n\n  code(code, infostring, escaped) {\n    const lang = (infostring || '').match(/\\S*/)[0];\n    if (this.options.highlight) {\n      const out = this.options.highlight(code, lang);\n      if (out != null && out !== code) {\n        escaped = true;\n        code = out;\n      }\n    }\n\n    if (!lang) {\n      return '<pre><code>'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>';\n    }\n\n    return '<pre><code class=\"'\n      + this.options.langPrefix\n      + escape(lang, true)\n      + '\">'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>\\n';\n  };\n\n  blockquote(quote) {\n    return '<blockquote>\\n' + quote + '</blockquote>\\n';\n  };\n\n  html(html) {\n    return html;\n  };\n\n  heading(text, level, raw, slugger) {\n    if (this.options.headerIds) {\n      return '<h'\n        + level\n        + ' id=\"'\n        + this.options.headerPrefix\n        + slugger.slug(raw)\n        + '\">'\n        + text\n        + '</h'\n        + level\n        + '>\\n';\n    }\n    // ignore IDs\n    return '<h' + level + '>' + text + '</h' + level + '>\\n';\n  };\n\n  hr() {\n    return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n  };\n\n  list(body, ordered, start) {\n    const type = ordered ? 'ol' : 'ul',\n      startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n    return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n  };\n\n  listitem(text) {\n    return '<li>' + text + '</li>\\n';\n  };\n\n  checkbox(checked) {\n    return '<input '\n      + (checked ? 'checked=\"\" ' : '')\n      + 'disabled=\"\" type=\"checkbox\"'\n      + (this.options.xhtml ? ' /' : '')\n      + '> ';\n  };\n\n  paragraph(text) {\n    return '<p>' + text + '</p>\\n';\n  };\n\n  table(header, body) {\n    if (body) body = '<tbody>' + body + '</tbody>';\n\n    return '<table>\\n'\n      + '<thead>\\n'\n      + header\n      + '</thead>\\n'\n      + body\n      + '</table>\\n';\n  };\n\n  tablerow(content) {\n    return '<tr>\\n' + content + '</tr>\\n';\n  };\n\n  tablecell(content, flags) {\n    const type = flags.header ? 'th' : 'td';\n    const tag = flags.align\n      ? '<' + type + ' align=\"' + flags.align + '\">'\n      : '<' + type + '>';\n    return tag + content + '</' + type + '>\\n';\n  };\n\n  // span level renderer\n  strong(text) {\n    return '<strong>' + text + '</strong>';\n  };\n\n  em(text) {\n    return '<em>' + text + '</em>';\n  };\n\n  codespan(text) {\n    return '<code>' + text + '</code>';\n  };\n\n  br() {\n    return this.options.xhtml ? '<br/>' : '<br>';\n  };\n\n  del(text) {\n    return '<del>' + text + '</del>';\n  };\n\n  link(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n    let out = '<a href=\"' + escape(href) + '\"';\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n    out += '>' + text + '</a>';\n    return out;\n  };\n\n  image(href, title, text) {\n    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n    if (href === null) {\n      return text;\n    }\n\n    let out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n    out += this.options.xhtml ? '/>' : '>';\n    return out;\n  };\n\n  text(text) {\n    return text;\n  };\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/marked/src/Renderer.js?");

/***/ }),

/***/ "../../node_modules/marked/src/Slugger.js":
/*!***************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/marked/src/Slugger.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Slugger generates header id\n */\nmodule.exports = class Slugger {\n  constructor() {\n    this.seen = {};\n  }\n\n  /**\n   * Convert string to unique id\n   */\n  slug(value) {\n    let slug = value\n      .toLowerCase()\n      .trim()\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '')\n      .replace(/\\s/g, '-');\n\n    if (this.seen.hasOwnProperty(slug)) {\n      const originalSlug = slug;\n      do {\n        this.seen[originalSlug]++;\n        slug = originalSlug + '-' + this.seen[originalSlug];\n      } while (this.seen.hasOwnProperty(slug));\n    }\n    this.seen[slug] = 0;\n\n    return slug;\n  };\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/marked/src/Slugger.js?");

/***/ }),

/***/ "../../node_modules/marked/src/TextRenderer.js":
/*!********************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/marked/src/TextRenderer.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * TextRenderer\n * returns only the textual part of the token\n */\nmodule.exports = class TextRenderer {\n  // no need for block level renderers\n  strong(text) {\n    return text;\n  }\n\n  em(text) {\n    return text;\n  }\n\n  codespan(text) {\n    return text;\n  }\n\n  del(text) {\n    return text;\n  }\n\n  text(text) {\n    return text;\n  }\n\n  link(href, title, text) {\n    return '' + text;\n  }\n\n  image(href, title, text) {\n    return '' + text;\n  }\n\n  br() {\n    return '';\n  }\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/marked/src/TextRenderer.js?");

/***/ }),

/***/ "../../node_modules/marked/src/defaults.js":
/*!****************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/marked/src/defaults.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function getDefaults() {\n  return {\n    baseUrl: null,\n    breaks: false,\n    gfm: true,\n    headerIds: true,\n    headerPrefix: '',\n    highlight: null,\n    langPrefix: 'language-',\n    mangle: true,\n    pedantic: false,\n    renderer: null,\n    sanitize: false,\n    sanitizer: null,\n    silent: false,\n    smartLists: false,\n    smartypants: false,\n    xhtml: false\n  };\n}\n\nfunction changeDefaults(newDefaults) {\n  module.exports.defaults = newDefaults;\n}\n\nmodule.exports = {\n  defaults: getDefaults(),\n  getDefaults,\n  changeDefaults\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/marked/src/defaults.js?");

/***/ }),

/***/ "../../node_modules/marked/src/helpers.js":
/*!***************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/marked/src/helpers.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = /[&<>\"']/g;\nconst escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\nconst escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\nconst escapeReplacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape(html, encode) {\n  if (encode) {\n    if (escapeTest.test(html)) {\n      return html.replace(escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (escapeTestNoEncode.test(html)) {\n      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\nfunction unescape(html) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(unescapeTest, (_, n) => {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nconst caret = /(^|[^\\[])\\^/g;\nfunction edit(regex, opt) {\n  regex = regex.source || regex;\n  opt = opt || '';\n  const obj = {\n    replace: (name, val) => {\n      val = val.source || val;\n      val = val.replace(caret, '$1');\n      regex = regex.replace(name, val);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(regex, opt);\n    }\n  };\n  return obj;\n}\n\nconst nonWordAndColonTest = /[^\\w:]/g;\nconst originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\nfunction cleanUrl(sanitize, base, href) {\n  if (sanitize) {\n    let prot;\n    try {\n      prot = decodeURIComponent(unescape(href))\n        .replace(nonWordAndColonTest, '')\n        .toLowerCase();\n    } catch (e) {\n      return null;\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n      return null;\n    }\n  }\n  if (base && !originIndependentUrl.test(href)) {\n    href = resolveUrl(base, href);\n  }\n  try {\n    href = encodeURI(href).replace(/%25/g, '%');\n  } catch (e) {\n    return null;\n  }\n  return href;\n}\n\nconst baseUrls = {};\nconst justDomain = /^[^:]+:\\/*[^/]*$/;\nconst protocol = /^([^:]+:)[\\s\\S]*$/;\nconst domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\nfunction resolveUrl(base, href) {\n  if (!baseUrls[' ' + base]) {\n    // we can ignore everything in base after the last slash of its path component,\n    // but we might need to add _that_\n    // https://tools.ietf.org/html/rfc3986#section-3\n    if (justDomain.test(base)) {\n      baseUrls[' ' + base] = base + '/';\n    } else {\n      baseUrls[' ' + base] = rtrim(base, '/', true);\n    }\n  }\n  base = baseUrls[' ' + base];\n  const relativeBase = base.indexOf(':') === -1;\n\n  if (href.substring(0, 2) === '//') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(protocol, '$1') + href;\n  } else if (href.charAt(0) === '/') {\n    if (relativeBase) {\n      return href;\n    }\n    return base.replace(domain, '$1') + href;\n  } else {\n    return base + href;\n  }\n}\n\nconst noopTest = { exec: function noopTest() {} };\n\nfunction merge(obj) {\n  let i = 1,\n    target,\n    key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\nfunction splitCells(tableRow, count) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n      let escaped = false,\n        curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(/ \\|/);\n  let i = 0;\n\n  if (cells.length > count) {\n    cells.splice(count);\n  } else {\n    while (cells.length < count) cells.push('');\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n  }\n  return cells;\n}\n\n// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n// /c*$/ is vulnerable to REDOS.\n// invert: Remove suffix of non-c chars instead. Default falsey.\nfunction rtrim(str, c, invert) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.substr(0, l - suffLen);\n}\n\nfunction findClosingBracket(str, b) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n  const l = str.length;\n  let level = 0,\n    i = 0;\n  for (; i < l; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction checkSanitizeDeprecation(opt) {\n  if (opt && opt.sanitize && !opt.silent) {\n    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n  }\n}\n\nmodule.exports = {\n  escape,\n  unescape,\n  edit,\n  cleanUrl,\n  resolveUrl,\n  noopTest,\n  merge,\n  splitCells,\n  rtrim,\n  findClosingBracket,\n  checkSanitizeDeprecation\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/marked/src/helpers.js?");

/***/ }),

/***/ "../../node_modules/marked/src/marked.js":
/*!**************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/marked/src/marked.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Lexer = __webpack_require__(/*! ./Lexer.js */ \"../../node_modules/marked/src/Lexer.js\");\nconst Parser = __webpack_require__(/*! ./Parser.js */ \"../../node_modules/marked/src/Parser.js\");\nconst Renderer = __webpack_require__(/*! ./Renderer.js */ \"../../node_modules/marked/src/Renderer.js\");\nconst TextRenderer = __webpack_require__(/*! ./TextRenderer.js */ \"../../node_modules/marked/src/TextRenderer.js\");\nconst InlineLexer = __webpack_require__(/*! ./InlineLexer.js */ \"../../node_modules/marked/src/InlineLexer.js\");\nconst Slugger = __webpack_require__(/*! ./Slugger.js */ \"../../node_modules/marked/src/Slugger.js\");\nconst {\n  merge,\n  checkSanitizeDeprecation,\n  escape\n} = __webpack_require__(/*! ./helpers.js */ \"../../node_modules/marked/src/helpers.js\");\nconst {\n  getDefaults,\n  changeDefaults,\n  defaults\n} = __webpack_require__(/*! ./defaults.js */ \"../../node_modules/marked/src/defaults.js\");\n\n/**\n * Marked\n */\nfunction marked(src, opt, callback) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked(): input parameter is undefined or null');\n  }\n  if (typeof src !== 'string') {\n    throw new Error('marked(): input parameter is of type '\n      + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  if (callback || typeof opt === 'function') {\n    if (!callback) {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n    const highlight = opt.highlight;\n    let tokens,\n      pending,\n      i = 0;\n\n    try {\n      tokens = Lexer.lex(src, opt);\n    } catch (e) {\n      return callback(e);\n    }\n\n    pending = tokens.length;\n\n    const done = function(err) {\n      if (err) {\n        opt.highlight = highlight;\n        return callback(err);\n      }\n\n      let out;\n\n      try {\n        out = Parser.parse(tokens, opt);\n      } catch (e) {\n        err = e;\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!pending) return done();\n\n    for (; i < tokens.length; i++) {\n      (function(token) {\n        if (token.type !== 'code') {\n          return --pending || done();\n        }\n        return highlight(token.text, token.lang, function(err, code) {\n          if (err) return done(err);\n          if (code == null || code === token.text) {\n            return --pending || done();\n          }\n          token.text = code;\n          token.escaped = true;\n          --pending || done();\n        });\n      })(tokens[i]);\n    }\n\n    return;\n  }\n  try {\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\nmarked.getDefaults = getDefaults;\n\nmarked.defaults = defaults;\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\n\nmarked.Slugger = Slugger;\n\nmarked.parse = marked;\n\nmodule.exports = marked;\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/marked/src/marked.js?");

/***/ }),

/***/ "../../node_modules/marked/src/rules.js":
/*!*************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/marked/src/rules.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {\n  noopTest,\n  edit,\n  merge\n} = __webpack_require__(/*! ./helpers.js */ \"../../node_modules/marked/src/helpers.js\");\n\n/**\n * Block-Level Grammar\n */\nconst block = {\n  newline: /^\\n+/,\n  code: /^( {4}[^\\n]+\\n*)+/,\n  fences: /^ {0,3}(`{3,}|~{3,})([^`~\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?:\\n+|$)|$)/,\n  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n  heading: /^ {0,3}(#{1,6}) +([^\\n]*?)(?: +#+)? *(?:\\n+|$)/,\n  blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n  list: /^( {0,3})(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n  html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?\\\\?>\\\\n*' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?>\\\\n*' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\\\\n*' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (6)\n    + '|<(?!script|pre|style)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) open tag\n    + '|</(?!script|pre|style)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) closing tag\n    + ')',\n  def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n  nptable: noopTest,\n  table: noopTest,\n  lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  // regex template, placeholders will be replaced according to different paragraph\n  // interruption rules of commonmark and the original markdown spec:\n  _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\\n]+)*)/,\n  text: /^[^\\n]+/\n};\n\nblock._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def)\n  .replace('label', block._label)\n  .replace('title', block._title)\n  .getRegex();\n\nblock.bullet = /(?:[*+-]|\\d{1,9}\\.)/;\nblock.item = /^( *)(bull) ?[^\\n]*(?:\\n(?!\\1bull ?)[^\\n]*)*/;\nblock.item = edit(block.item, 'gm')\n  .replace(/bull/g, block.bullet)\n  .getRegex();\n\nblock.list = edit(block.list)\n  .replace(/bull/g, block.bullet)\n  .replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))')\n  .replace('def', '\\\\n+(?=' + block.def.source + ')')\n  .getRegex();\n\nblock._tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'\n  + '|track|ul';\nblock._comment = /<!--(?!-?>)[\\s\\S]*?-->/;\nblock.html = edit(block.html, 'i')\n  .replace('comment', block._comment)\n  .replace('tag', block._tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nblock.paragraph = edit(block._paragraph)\n  .replace('hr', block.hr)\n  .replace('heading', ' {0,3}#{1,6} +')\n  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}|~{3,})[^`\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)')\n  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.blockquote = edit(block.blockquote)\n  .replace('paragraph', block.paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  nptable: /^ *([^|\\n ].*\\|.*)\\n *([-:]+ *\\|[-| :]*)(?:\\n((?:.*[^>\\n ].*(?:\\n|$))*)\\n*|$)/,\n  table: /^ *\\|(.+)\\n *\\|?( *[-:]+[-| :]*)(?:\\n((?: *[^>\\n ].*(?:\\n|$))*)\\n*|$)/\n});\n\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nblock.pedantic = merge({}, block.normal, {\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', block._comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n  heading: /^ *(#{1,6}) *([^\\n]+?) *(?:#+ *)?(?:\\n+|$)/,\n  fences: noopTest, // fences not supported\n  paragraph: edit(block.normal._paragraph)\n    .replace('hr', block.hr)\n    .replace('heading', ' *#{1,6} *[^\\n]')\n    .replace('lheading', block.lheading)\n    .replace('blockquote', ' {0,3}>')\n    .replace('|fences', '')\n    .replace('|list', '')\n    .replace('|html', '')\n    .getRegex()\n});\n\n/**\n * Inline-Level Grammar\n */\nconst inline = {\n  escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n  autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n  url: noopTest,\n  tag: '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>', // CDATA section\n  link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n  reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n  nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n  strong: /^__([^\\s_])__(?!_)|^\\*\\*([^\\s*])\\*\\*(?!\\*)|^__([^\\s][\\s\\S]*?[^\\s])__(?!_)|^\\*\\*([^\\s][\\s\\S]*?[^\\s])\\*\\*(?!\\*)/,\n  em: /^_([^\\s_])_(?!_)|^\\*([^\\s*<\\[])\\*(?!\\*)|^_([^\\s<][\\s\\S]*?[^\\s_])_(?!_|[^\\spunctuation])|^_([^\\s_<][\\s\\S]*?[^\\s])_(?!_|[^\\spunctuation])|^\\*([^\\s<\"][\\s\\S]*?[^\\s\\*])\\*(?!\\*|[^\\spunctuation])|^\\*([^\\s*\"<\\[][\\s\\S]*?[^\\s])\\*(?!\\*)/,\n  code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n  br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n  del: noopTest,\n  text: /^(`+|[^`])(?:[\\s\\S]*?(?:(?=[\\\\<!\\[`*]|\\b_|$)|[^ ](?= {2,}\\n))|(?= {2,}\\n))/\n};\n\n// list of punctuation marks from common mark spec\n// without ` and ] to workaround Rule 17 (inline code blocks/links)\ninline._punctuation = '!\"#$%&\\'()*+,\\\\-./:;<=>?@\\\\[^_{|}~';\ninline.em = edit(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();\n\ninline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink)\n  .replace('scheme', inline._scheme)\n  .replace('email', inline._email)\n  .getRegex();\n\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n\ninline.tag = edit(inline.tag)\n  .replace('comment', block._comment)\n  .replace('attribute', inline._attribute)\n  .getRegex();\n\ninline._label = /(?:\\[[^\\[\\]]*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\ninline._href = /<(?:\\\\[<>]?|[^\\s<>\\\\])*>|[^\\s\\x00-\\x1f]*/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n\ninline.link = edit(inline.link)\n  .replace('label', inline._label)\n  .replace('href', inline._href)\n  .replace('title', inline._title)\n  .getRegex();\n\ninline.reflink = edit(inline.reflink)\n  .replace('label', inline._label)\n  .getRegex();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/,\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', inline._label)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', inline._label)\n    .getRegex()\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: edit(inline.escape).replace('])', '~|])').getRegex(),\n  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n  url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n  _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n  del: /^~+(?=\\S)([\\s\\S]*?\\S)~+/,\n  text: /^(`+|[^`])(?:[\\s\\S]*?(?:(?=[\\\\<!\\[`*~]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))|(?= {2,}\\n|[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))/\n});\n\ninline.gfm.url = edit(inline.gfm.url, 'i')\n  .replace('email', inline.gfm._extended_email)\n  .getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: edit(inline.br).replace('{2,}', '*').getRegex(),\n  text: edit(inline.gfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex()\n});\n\nmodule.exports = {\n  block,\n  inline\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/marked/src/rules.js?");

/***/ }),

/***/ "../../node_modules/path-browserify/index.js":
/*!******************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/path-browserify/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/path-browserify/index.js?");

/***/ }),

/***/ "../../node_modules/pathval/index.js":
/*!**********************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/pathval/index.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* !\n * Chai - pathval utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * @see https://github.com/logicalparadox/filtr\n * MIT Licensed\n */\n\n/**\n * ### .hasProperty(object, name)\n *\n * This allows checking whether an object has own\n * or inherited from prototype chain named property.\n *\n * Basically does the same thing as the `in`\n * operator but works properly with null/undefined values\n * and other primitives.\n *\n *     var obj = {\n *         arr: ['a', 'b', 'c']\n *       , str: 'Hello'\n *     }\n *\n * The following would be the results.\n *\n *     hasProperty(obj, 'str');  // true\n *     hasProperty(obj, 'constructor');  // true\n *     hasProperty(obj, 'bar');  // false\n *\n *     hasProperty(obj.str, 'length'); // true\n *     hasProperty(obj.str, 1);  // true\n *     hasProperty(obj.str, 5);  // false\n *\n *     hasProperty(obj.arr, 'length');  // true\n *     hasProperty(obj.arr, 2);  // true\n *     hasProperty(obj.arr, 3);  // false\n *\n * @param {Object} object\n * @param {String|Symbol} name\n * @returns {Boolean} whether it exists\n * @namespace Utils\n * @name hasProperty\n * @api public\n */\n\nfunction hasProperty(obj, name) {\n  if (typeof obj === 'undefined' || obj === null) {\n    return false;\n  }\n\n  // The `in` operator does not work with primitives.\n  return name in Object(obj);\n}\n\n/* !\n * ## parsePath(path)\n *\n * Helper function used to parse string object\n * paths. Use in conjunction with `internalGetPathValue`.\n *\n *      var parsed = parsePath('myobject.property.subprop');\n *\n * ### Paths:\n *\n * * Can be infinitely deep and nested.\n * * Arrays are also valid using the formal `myobject.document[3].property`.\n * * Literal dots and brackets (not delimiter) must be backslash-escaped.\n *\n * @param {String} path\n * @returns {Object} parsed\n * @api private\n */\n\nfunction parsePath(path) {\n  var str = path.replace(/([^\\\\])\\[/g, '$1.[');\n  var parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n  return parts.map(function mapMatches(value) {\n    var regexp = /^\\[(\\d+)\\]$/;\n    var mArr = regexp.exec(value);\n    var parsed = null;\n    if (mArr) {\n      parsed = { i: parseFloat(mArr[1]) };\n    } else {\n      parsed = { p: value.replace(/\\\\([.\\[\\]])/g, '$1') };\n    }\n\n    return parsed;\n  });\n}\n\n/* !\n * ## internalGetPathValue(obj, parsed[, pathDepth])\n *\n * Helper companion function for `.parsePath` that returns\n * the value located at the parsed address.\n *\n *      var value = getPathValue(obj, parsed);\n *\n * @param {Object} object to search against\n * @param {Object} parsed definition from `parsePath`.\n * @param {Number} depth (nesting level) of the property we want to retrieve\n * @returns {Object|Undefined} value\n * @api private\n */\n\nfunction internalGetPathValue(obj, parsed, pathDepth) {\n  var temporaryValue = obj;\n  var res = null;\n  pathDepth = (typeof pathDepth === 'undefined' ? parsed.length : pathDepth);\n\n  for (var i = 0; i < pathDepth; i++) {\n    var part = parsed[i];\n    if (temporaryValue) {\n      if (typeof part.p === 'undefined') {\n        temporaryValue = temporaryValue[part.i];\n      } else {\n        temporaryValue = temporaryValue[part.p];\n      }\n\n      if (i === (pathDepth - 1)) {\n        res = temporaryValue;\n      }\n    }\n  }\n\n  return res;\n}\n\n/* !\n * ## internalSetPathValue(obj, value, parsed)\n *\n * Companion function for `parsePath` that sets\n * the value located at a parsed address.\n *\n *  internalSetPathValue(obj, 'value', parsed);\n *\n * @param {Object} object to search and define on\n * @param {*} value to use upon set\n * @param {Object} parsed definition from `parsePath`\n * @api private\n */\n\nfunction internalSetPathValue(obj, val, parsed) {\n  var tempObj = obj;\n  var pathDepth = parsed.length;\n  var part = null;\n  // Here we iterate through every part of the path\n  for (var i = 0; i < pathDepth; i++) {\n    var propName = null;\n    var propVal = null;\n    part = parsed[i];\n\n    // If it's the last part of the path, we set the 'propName' value with the property name\n    if (i === (pathDepth - 1)) {\n      propName = typeof part.p === 'undefined' ? part.i : part.p;\n      // Now we set the property with the name held by 'propName' on object with the desired val\n      tempObj[propName] = val;\n    } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {\n      tempObj = tempObj[part.p];\n    } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {\n      tempObj = tempObj[part.i];\n    } else {\n      // If the obj doesn't have the property we create one with that name to define it\n      var next = parsed[i + 1];\n      // Here we set the name of the property which will be defined\n      propName = typeof part.p === 'undefined' ? part.i : part.p;\n      // Here we decide if this property will be an array or a new object\n      propVal = typeof next.p === 'undefined' ? [] : {};\n      tempObj[propName] = propVal;\n      tempObj = tempObj[propName];\n    }\n  }\n}\n\n/**\n * ### .getPathInfo(object, path)\n *\n * This allows the retrieval of property info in an\n * object given a string path.\n *\n * The path info consists of an object with the\n * following properties:\n *\n * * parent - The parent object of the property referenced by `path`\n * * name - The name of the final property, a number if it was an array indexer\n * * value - The value of the property, if it exists, otherwise `undefined`\n * * exists - Whether the property exists or not\n *\n * @param {Object} object\n * @param {String} path\n * @returns {Object} info\n * @namespace Utils\n * @name getPathInfo\n * @api public\n */\n\nfunction getPathInfo(obj, path) {\n  var parsed = parsePath(path);\n  var last = parsed[parsed.length - 1];\n  var info = {\n    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,\n    name: last.p || last.i,\n    value: internalGetPathValue(obj, parsed),\n  };\n  info.exists = hasProperty(info.parent, info.name);\n\n  return info;\n}\n\n/**\n * ### .getPathValue(object, path)\n *\n * This allows the retrieval of values in an\n * object given a string path.\n *\n *     var obj = {\n *         prop1: {\n *             arr: ['a', 'b', 'c']\n *           , str: 'Hello'\n *         }\n *       , prop2: {\n *             arr: [ { nested: 'Universe' } ]\n *           , str: 'Hello again!'\n *         }\n *     }\n *\n * The following would be the results.\n *\n *     getPathValue(obj, 'prop1.str'); // Hello\n *     getPathValue(obj, 'prop1.att[2]'); // b\n *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe\n *\n * @param {Object} object\n * @param {String} path\n * @returns {Object} value or `undefined`\n * @namespace Utils\n * @name getPathValue\n * @api public\n */\n\nfunction getPathValue(obj, path) {\n  var info = getPathInfo(obj, path);\n  return info.value;\n}\n\n/**\n * ### .setPathValue(object, path, value)\n *\n * Define the value in an object at a given string path.\n *\n * ```js\n * var obj = {\n *     prop1: {\n *         arr: ['a', 'b', 'c']\n *       , str: 'Hello'\n *     }\n *   , prop2: {\n *         arr: [ { nested: 'Universe' } ]\n *       , str: 'Hello again!'\n *     }\n * };\n * ```\n *\n * The following would be acceptable.\n *\n * ```js\n * var properties = require('tea-properties');\n * properties.set(obj, 'prop1.str', 'Hello Universe!');\n * properties.set(obj, 'prop1.arr[2]', 'B');\n * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });\n * ```\n *\n * @param {Object} object\n * @param {String} path\n * @param {Mixed} value\n * @api private\n */\n\nfunction setPathValue(obj, path, val) {\n  var parsed = parsePath(path);\n  internalSetPathValue(obj, val, parsed);\n  return obj;\n}\n\nmodule.exports = {\n  hasProperty: hasProperty,\n  getPathInfo: getPathInfo,\n  getPathValue: getPathValue,\n  setPathValue: setPathValue,\n};\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/pathval/index.js?");

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/process/browser.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/process/browser.js?");

/***/ }),

/***/ "../../node_modules/type-detect/type-detect.js":
/*!********************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/type-detect/type-detect.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n\t true ? module.exports = factory() :\n\tundefined;\n}(this, (function () { 'use strict';\n\n/* !\n * type-detect\n * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\nvar promiseExists = typeof Promise === 'function';\n\n/* eslint-disable no-undef */\nvar globalObject = typeof self === 'object' ? self : global; // eslint-disable-line id-blacklist\n\nvar symbolExists = typeof Symbol !== 'undefined';\nvar mapExists = typeof Map !== 'undefined';\nvar setExists = typeof Set !== 'undefined';\nvar weakMapExists = typeof WeakMap !== 'undefined';\nvar weakSetExists = typeof WeakSet !== 'undefined';\nvar dataViewExists = typeof DataView !== 'undefined';\nvar symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';\nvar symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';\nvar setEntriesExists = setExists && typeof Set.prototype.entries === 'function';\nvar mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';\nvar setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());\nvar mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());\nvar arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';\nvar arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());\nvar stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';\nvar stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());\nvar toStringLeftSliceLength = 8;\nvar toStringRightSliceLength = -1;\n/**\n * ### typeOf (obj)\n *\n * Uses `Object.prototype.toString` to determine the type of an object,\n * normalising behaviour across engine versions & well optimised.\n *\n * @param {Mixed} object\n * @return {String} object type\n * @api public\n */\nfunction typeDetect(obj) {\n  /* ! Speed optimisation\n   * Pre:\n   *   string literal     x 3,039,035 ops/sec ±1.62% (78 runs sampled)\n   *   boolean literal    x 1,424,138 ops/sec ±4.54% (75 runs sampled)\n   *   number literal     x 1,653,153 ops/sec ±1.91% (82 runs sampled)\n   *   undefined          x 9,978,660 ops/sec ±1.92% (75 runs sampled)\n   *   function           x 2,556,769 ops/sec ±1.73% (77 runs sampled)\n   * Post:\n   *   string literal     x 38,564,796 ops/sec ±1.15% (79 runs sampled)\n   *   boolean literal    x 31,148,940 ops/sec ±1.10% (79 runs sampled)\n   *   number literal     x 32,679,330 ops/sec ±1.90% (78 runs sampled)\n   *   undefined          x 32,363,368 ops/sec ±1.07% (82 runs sampled)\n   *   function           x 31,296,870 ops/sec ±0.96% (83 runs sampled)\n   */\n  var typeofObj = typeof obj;\n  if (typeofObj !== 'object') {\n    return typeofObj;\n  }\n\n  /* ! Speed optimisation\n   * Pre:\n   *   null               x 28,645,765 ops/sec ±1.17% (82 runs sampled)\n   * Post:\n   *   null               x 36,428,962 ops/sec ±1.37% (84 runs sampled)\n   */\n  if (obj === null) {\n    return 'null';\n  }\n\n  /* ! Spec Conformance\n   * Test: `Object.prototype.toString.call(window)``\n   *  - Node === \"[object global]\"\n   *  - Chrome === \"[object global]\"\n   *  - Firefox === \"[object Window]\"\n   *  - PhantomJS === \"[object Window]\"\n   *  - Safari === \"[object Window]\"\n   *  - IE 11 === \"[object Window]\"\n   *  - IE Edge === \"[object Window]\"\n   * Test: `Object.prototype.toString.call(this)``\n   *  - Chrome Worker === \"[object global]\"\n   *  - Firefox Worker === \"[object DedicatedWorkerGlobalScope]\"\n   *  - Safari Worker === \"[object DedicatedWorkerGlobalScope]\"\n   *  - IE 11 Worker === \"[object WorkerGlobalScope]\"\n   *  - IE Edge Worker === \"[object WorkerGlobalScope]\"\n   */\n  if (obj === globalObject) {\n    return 'global';\n  }\n\n  /* ! Speed optimisation\n   * Pre:\n   *   array literal      x 2,888,352 ops/sec ±0.67% (82 runs sampled)\n   * Post:\n   *   array literal      x 22,479,650 ops/sec ±0.96% (81 runs sampled)\n   */\n  if (\n    Array.isArray(obj) &&\n    (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))\n  ) {\n    return 'Array';\n  }\n\n  // Not caching existence of `window` and related properties due to potential\n  // for `window` to be unset before tests in quasi-browser environments.\n  if (typeof window === 'object' && window !== null) {\n    /* ! Spec Conformance\n     * (https://html.spec.whatwg.org/multipage/browsers.html#location)\n     * WhatWG HTML$7.7.3 - The `Location` interface\n     * Test: `Object.prototype.toString.call(window.location)``\n     *  - IE <=11 === \"[object Object]\"\n     *  - IE Edge <=13 === \"[object Object]\"\n     */\n    if (typeof window.location === 'object' && obj === window.location) {\n      return 'Location';\n    }\n\n    /* ! Spec Conformance\n     * (https://html.spec.whatwg.org/#document)\n     * WhatWG HTML$3.1.1 - The `Document` object\n     * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n     *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-26809268)\n     *       which suggests that browsers should use HTMLTableCellElement for\n     *       both TD and TH elements. WhatWG separates these.\n     *       WhatWG HTML states:\n     *         > For historical reasons, Window objects must also have a\n     *         > writable, configurable, non-enumerable property named\n     *         > HTMLDocument whose value is the Document interface object.\n     * Test: `Object.prototype.toString.call(document)``\n     *  - Chrome === \"[object HTMLDocument]\"\n     *  - Firefox === \"[object HTMLDocument]\"\n     *  - Safari === \"[object HTMLDocument]\"\n     *  - IE <=10 === \"[object Document]\"\n     *  - IE 11 === \"[object HTMLDocument]\"\n     *  - IE Edge <=13 === \"[object HTMLDocument]\"\n     */\n    if (typeof window.document === 'object' && obj === window.document) {\n      return 'Document';\n    }\n\n    if (typeof window.navigator === 'object') {\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/multipage/webappapis.html#mimetypearray)\n       * WhatWG HTML$8.6.1.5 - Plugins - Interface MimeTypeArray\n       * Test: `Object.prototype.toString.call(navigator.mimeTypes)``\n       *  - IE <=10 === \"[object MSMimeTypesCollection]\"\n       */\n      if (typeof window.navigator.mimeTypes === 'object' &&\n          obj === window.navigator.mimeTypes) {\n        return 'MimeTypeArray';\n      }\n\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\n       * WhatWG HTML$8.6.1.5 - Plugins - Interface PluginArray\n       * Test: `Object.prototype.toString.call(navigator.plugins)``\n       *  - IE <=10 === \"[object MSPluginsCollection]\"\n       */\n      if (typeof window.navigator.plugins === 'object' &&\n          obj === window.navigator.plugins) {\n        return 'PluginArray';\n      }\n    }\n\n    if ((typeof window.HTMLElement === 'function' ||\n        typeof window.HTMLElement === 'object') &&\n        obj instanceof window.HTMLElement) {\n      /* ! Spec Conformance\n      * (https://html.spec.whatwg.org/multipage/webappapis.html#pluginarray)\n      * WhatWG HTML$4.4.4 - The `blockquote` element - Interface `HTMLQuoteElement`\n      * Test: `Object.prototype.toString.call(document.createElement('blockquote'))``\n      *  - IE <=10 === \"[object HTMLBlockElement]\"\n      */\n      if (obj.tagName === 'BLOCKQUOTE') {\n        return 'HTMLQuoteElement';\n      }\n\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/#htmltabledatacellelement)\n       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableDataCellElement`\n       * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n       *       which suggests that browsers should use HTMLTableCellElement for\n       *       both TD and TH elements. WhatWG separates these.\n       * Test: Object.prototype.toString.call(document.createElement('td'))\n       *  - Chrome === \"[object HTMLTableCellElement]\"\n       *  - Firefox === \"[object HTMLTableCellElement]\"\n       *  - Safari === \"[object HTMLTableCellElement]\"\n       */\n      if (obj.tagName === 'TD') {\n        return 'HTMLTableDataCellElement';\n      }\n\n      /* ! Spec Conformance\n       * (https://html.spec.whatwg.org/#htmltableheadercellelement)\n       * WhatWG HTML$4.9.9 - The `td` element - Interface `HTMLTableHeaderCellElement`\n       * Note: Most browsers currently adher to the W3C DOM Level 2 spec\n       *       (https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-82915075)\n       *       which suggests that browsers should use HTMLTableCellElement for\n       *       both TD and TH elements. WhatWG separates these.\n       * Test: Object.prototype.toString.call(document.createElement('th'))\n       *  - Chrome === \"[object HTMLTableCellElement]\"\n       *  - Firefox === \"[object HTMLTableCellElement]\"\n       *  - Safari === \"[object HTMLTableCellElement]\"\n       */\n      if (obj.tagName === 'TH') {\n        return 'HTMLTableHeaderCellElement';\n      }\n    }\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   Float64Array       x 625,644 ops/sec ±1.58% (80 runs sampled)\n  *   Float32Array       x 1,279,852 ops/sec ±2.91% (77 runs sampled)\n  *   Uint32Array        x 1,178,185 ops/sec ±1.95% (83 runs sampled)\n  *   Uint16Array        x 1,008,380 ops/sec ±2.25% (80 runs sampled)\n  *   Uint8Array         x 1,128,040 ops/sec ±2.11% (81 runs sampled)\n  *   Int32Array         x 1,170,119 ops/sec ±2.88% (80 runs sampled)\n  *   Int16Array         x 1,176,348 ops/sec ±5.79% (86 runs sampled)\n  *   Int8Array          x 1,058,707 ops/sec ±4.94% (77 runs sampled)\n  *   Uint8ClampedArray  x 1,110,633 ops/sec ±4.20% (80 runs sampled)\n  * Post:\n  *   Float64Array       x 7,105,671 ops/sec ±13.47% (64 runs sampled)\n  *   Float32Array       x 5,887,912 ops/sec ±1.46% (82 runs sampled)\n  *   Uint32Array        x 6,491,661 ops/sec ±1.76% (79 runs sampled)\n  *   Uint16Array        x 6,559,795 ops/sec ±1.67% (82 runs sampled)\n  *   Uint8Array         x 6,463,966 ops/sec ±1.43% (85 runs sampled)\n  *   Int32Array         x 5,641,841 ops/sec ±3.49% (81 runs sampled)\n  *   Int16Array         x 6,583,511 ops/sec ±1.98% (80 runs sampled)\n  *   Int8Array          x 6,606,078 ops/sec ±1.74% (81 runs sampled)\n  *   Uint8ClampedArray  x 6,602,224 ops/sec ±1.77% (83 runs sampled)\n  */\n  var stringTag = (symbolToStringTagExists && obj[Symbol.toStringTag]);\n  if (typeof stringTag === 'string') {\n    return stringTag;\n  }\n\n  var objPrototype = Object.getPrototypeOf(obj);\n  /* ! Speed optimisation\n  * Pre:\n  *   regex literal      x 1,772,385 ops/sec ±1.85% (77 runs sampled)\n  *   regex constructor  x 2,143,634 ops/sec ±2.46% (78 runs sampled)\n  * Post:\n  *   regex literal      x 3,928,009 ops/sec ±0.65% (78 runs sampled)\n  *   regex constructor  x 3,931,108 ops/sec ±0.58% (84 runs sampled)\n  */\n  if (objPrototype === RegExp.prototype) {\n    return 'RegExp';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   date               x 2,130,074 ops/sec ±4.42% (68 runs sampled)\n  * Post:\n  *   date               x 3,953,779 ops/sec ±1.35% (77 runs sampled)\n  */\n  if (objPrototype === Date.prototype) {\n    return 'Date';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise.prototype-@@tostringtag)\n   * ES6$25.4.5.4 - Promise.prototype[@@toStringTag] should be \"Promise\":\n   * Test: `Object.prototype.toString.call(Promise.resolve())``\n   *  - Chrome <=47 === \"[object Object]\"\n   *  - Edge <=20 === \"[object Object]\"\n   *  - Firefox 29-Latest === \"[object Promise]\"\n   *  - Safari 7.1-Latest === \"[object Promise]\"\n   */\n  if (promiseExists && objPrototype === Promise.prototype) {\n    return 'Promise';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   set                x 2,222,186 ops/sec ±1.31% (82 runs sampled)\n  * Post:\n  *   set                x 4,545,879 ops/sec ±1.13% (83 runs sampled)\n  */\n  if (setExists && objPrototype === Set.prototype) {\n    return 'Set';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   map                x 2,396,842 ops/sec ±1.59% (81 runs sampled)\n  * Post:\n  *   map                x 4,183,945 ops/sec ±6.59% (82 runs sampled)\n  */\n  if (mapExists && objPrototype === Map.prototype) {\n    return 'Map';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   weakset            x 1,323,220 ops/sec ±2.17% (76 runs sampled)\n  * Post:\n  *   weakset            x 4,237,510 ops/sec ±2.01% (77 runs sampled)\n  */\n  if (weakSetExists && objPrototype === WeakSet.prototype) {\n    return 'WeakSet';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   weakmap            x 1,500,260 ops/sec ±2.02% (78 runs sampled)\n  * Post:\n  *   weakmap            x 3,881,384 ops/sec ±1.45% (82 runs sampled)\n  */\n  if (weakMapExists && objPrototype === WeakMap.prototype) {\n    return 'WeakMap';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-dataview.prototype-@@tostringtag)\n   * ES6$24.2.4.21 - DataView.prototype[@@toStringTag] should be \"DataView\":\n   * Test: `Object.prototype.toString.call(new DataView(new ArrayBuffer(1)))``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (dataViewExists && objPrototype === DataView.prototype) {\n    return 'DataView';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%mapiteratorprototype%-@@tostringtag)\n   * ES6$23.1.5.2.2 - %MapIteratorPrototype%[@@toStringTag] should be \"Map Iterator\":\n   * Test: `Object.prototype.toString.call(new Map().entries())``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (mapExists && objPrototype === mapIteratorPrototype) {\n    return 'Map Iterator';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%setiteratorprototype%-@@tostringtag)\n   * ES6$23.2.5.2.2 - %SetIteratorPrototype%[@@toStringTag] should be \"Set Iterator\":\n   * Test: `Object.prototype.toString.call(new Set().entries())``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (setExists && objPrototype === setIteratorPrototype) {\n    return 'Set Iterator';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%arrayiteratorprototype%-@@tostringtag)\n   * ES6$22.1.5.2.2 - %ArrayIteratorPrototype%[@@toStringTag] should be \"Array Iterator\":\n   * Test: `Object.prototype.toString.call([][Symbol.iterator]())``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {\n    return 'Array Iterator';\n  }\n\n  /* ! Spec Conformance\n   * (http://www.ecma-international.org/ecma-262/6.0/index.html#sec-%stringiteratorprototype%-@@tostringtag)\n   * ES6$21.1.5.2.2 - %StringIteratorPrototype%[@@toStringTag] should be \"String Iterator\":\n   * Test: `Object.prototype.toString.call(''[Symbol.iterator]())``\n   *  - Edge <=13 === \"[object Object]\"\n   */\n  if (stringIteratorExists && objPrototype === stringIteratorPrototype) {\n    return 'String Iterator';\n  }\n\n  /* ! Speed optimisation\n  * Pre:\n  *   object from null   x 2,424,320 ops/sec ±1.67% (76 runs sampled)\n  * Post:\n  *   object from null   x 5,838,000 ops/sec ±0.99% (84 runs sampled)\n  */\n  if (objPrototype === null) {\n    return 'Object';\n  }\n\n  return Object\n    .prototype\n    .toString\n    .call(obj)\n    .slice(toStringLeftSliceLength, toStringRightSliceLength);\n}\n\nreturn typeDetect;\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/type-detect/type-detect.js?");

/***/ }),

/***/ "../../node_modules/uri-js/dist/es5/uri.all.js":
/*!********************************************************************************************************!*\
  !*** /home/marcello/mdb/[ ] Progetti/[ ] OnLabs.org/[ ] olojs/node_modules/uri-js/dist/es5/uri.all.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/** @license URI.js v4.4.0 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n\t true ? factory(exports) :\n\tundefined;\n}(this, (function (exports) { 'use strict';\n\nfunction merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n        sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1; x < xl; ++x) {\n            sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join('');\n    } else {\n        return sets[0];\n    }\n}\nfunction subexp(str) {\n    return \"(?:\" + str + \")\";\n}\nfunction typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n}\nfunction toUpperCase(str) {\n    return str.toUpperCase();\n}\nfunction toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n}\nfunction assign(target, source) {\n    var obj = target;\n    if (source) {\n        for (var key in source) {\n            obj[key] = source[key];\n        }\n    }\n    return obj;\n}\n\nfunction buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n        CR$ = \"[\\\\x0D]\",\n        DIGIT$$ = \"[0-9]\",\n        DQUOTE$$ = \"[\\\\x22]\",\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n        //case-insensitive\n    LF$$ = \"[\\\\x0A]\",\n        SP$$ = \"[\\\\x20]\",\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n        //                           6( h16 \":\" ) ls32\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n        //                      \"::\" 5( h16 \":\" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n        //[ *6( h16 \":\" ) h16 ] \"::\"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + \"*\"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n}\nvar URI_PROTOCOL = buildExps(false);\n\nvar IRI_PROTOCOL = buildExps(true);\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/** Highest positive signed 32-bit float value */\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nvar errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error$1(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tvar result = [];\n\tvar length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tvar parts = string.split('@');\n\tvar result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tvar labels = string.split('.');\n\tvar encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t// Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nvar ucs2encode = function ucs2encode(array) {\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n};\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nvar basicToDigit = function basicToDigit(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nvar digitToBasic = function digitToBasic(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nvar adapt = function adapt(delta, numPoints, firstTime) {\n\tvar k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nvar decode = function decode(input) {\n\t// Don't use UCS-2.\n\tvar output = [];\n\tvar inputLength = input.length;\n\tvar i = 0;\n\tvar n = initialN;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tvar basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror$1('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tvar oldi = i;\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror$1('invalid-input');\n\t\t\t}\n\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\t\t}\n\n\t\tvar out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\t}\n\n\treturn String.fromCodePoint.apply(String, output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nvar encode = function encode(input) {\n\tvar output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tvar inputLength = input.length;\n\n\t// Initialize the state.\n\tvar n = initialN;\n\tvar delta = 0;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points.\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar basicLength = output.length;\n\tvar handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tvar m = maxInt;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow.\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\tvar q = delta;\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nvar toUnicode = function toUnicode(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nvar toASCII = function toASCII(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nvar punycode = {\n\t/**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */\n\t'version': '2.1.0',\n\t/**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nvar SCHEMES = {};\nfunction pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n}\nfunction pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        } else if (c >= 194 && c < 224) {\n            if (il - i >= 6) {\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n            } else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        } else if (c >= 224) {\n            if (il - i >= 9) {\n                var _c = parseInt(str.substr(i + 4, 2), 16);\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n            } else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        } else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\nfunction _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n            last = _address$toLowerCase$2[0],\n            first = _address$toLowerCase$2[1];\n\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function (acc, field, index) {\n            if (!field || field === \"0\") {\n                var lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                } else {\n                    acc.push({ index: index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\n            return b.length - a.length;\n        })[0];\n        var newHost = void 0;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            var newFirst = fields.slice(0, longestZeroFields.index);\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        } else {\n            newHost = fields.join(\":\");\n        }\n        if (zone) {\n            newHost += \"%\" + zone;\n        }\n        return newHost;\n    } else {\n        return host;\n    }\n}\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nfunction parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        } else {\n            //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = \"same-document\";\n        } else if (components.scheme === undefined) {\n            components.reference = \"relative\";\n        } else if (components.fragment === undefined) {\n            components.reference = \"absolute\";\n        } else {\n            components.reference = \"uri\";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //check if scheme can't handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    } else {\n        components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n}\n\nfunction _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n    }\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n        uriTokens.push(\":\");\n        uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\nvar RDS1 = /^\\.\\.?\\//;\nvar RDS2 = /^\\/\\.(\\/|$)/;\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nfunction removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, \"\");\n        } else if (input.match(RDS2)) {\n            input = input.replace(RDS2, \"/\");\n        } else if (input.match(RDS3)) {\n            input = input.replace(RDS3, \"/\");\n            output.pop();\n        } else if (input === \".\" || input === \"..\") {\n            input = \"\";\n        } else {\n            var im = input.match(RDS5);\n            if (im) {\n                var s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            } else {\n                throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n    }\n    return output.join(\"\");\n}\n\nfunction serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\n        //TODO: normalize IPv6 address as per RFC 5952\n\n        //if host component is a domain name\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n            uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n            uriTokens.push(\"/\");\n        }\n    }\n    if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n}\n\nfunction resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n\n    var target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n    } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                } else {\n                    target.query = base.query;\n                }\n            } else {\n                if (relative.path.charAt(0) === \"/\") {\n                    target.path = removeDotSegments(relative.path);\n                } else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = \"/\" + relative.path;\n                    } else if (!base.path) {\n                        target.path = relative.path;\n                    } else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n\nfunction resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({ scheme: 'null' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n\nfunction normalize(uri, options) {\n    if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n\nfunction equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n\nfunction escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n\nfunction unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n\nvar handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        //report missing host\n        if (!components.host) {\n            components.error = components.error || \"HTTP URIs must have a host.\";\n        }\n        return components;\n    },\n    serialize: function serialize(components, options) {\n        var secure = String(components.scheme).toLowerCase() === \"https\";\n        //normalize the default port\n        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n            components.port = undefined;\n        }\n        //normalize the empty path\n        if (!components.path) {\n            components.path = \"/\";\n        }\n        //NOTE: We do not parse query strings for HTTP URIs\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n        //and not the HTTP spec.\n        return components;\n    }\n};\n\nvar handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n};\n\nfunction isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n//RFC 6455\nvar handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        var wsComponents = components;\n        //indicate if the secure flag is set\n        wsComponents.secure = isSecure(wsComponents);\n        //construct resouce name\n        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n        wsComponents.path = undefined;\n        wsComponents.query = undefined;\n        return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n        //normalize the default port\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n            wsComponents.port = undefined;\n        }\n        //ensure scheme matches secure flag\n        if (typeof wsComponents.secure === 'boolean') {\n            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n            wsComponents.secure = undefined;\n        }\n        //reconstruct path from resource name\n        if (wsComponents.resourceName) {\n            var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n                path = _wsComponents$resourc2[0],\n                query = _wsComponents$resourc2[1];\n\n            wsComponents.path = path && path !== '/' ? path : undefined;\n            wsComponents.query = query;\n            wsComponents.resourceName = undefined;\n        }\n        //forbid fragment component\n        wsComponents.fragment = undefined;\n        return wsComponents;\n    }\n};\n\nvar handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n};\n\nvar O = {};\nvar isIRI = true;\n//RFC 3986\nvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\nvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nvar NOT_HFVALUE = NOT_HFNAME;\nfunction decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n}\nvar handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            var unknownHeaders = false;\n            var headers = {};\n            var hfields = mailtoComponents.query.split(\"&\");\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                var hfield = hfields[x].split(\"=\");\n                switch (hfield[0]) {\n                    case \"to\":\n                        var toAddrs = hfield[1].split(\",\");\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                            to.push(toAddrs[_x]);\n                        }\n                        break;\n                    case \"subject\":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case \"body\":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders) mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n            var addr = to[_x2].split(\"@\");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            } else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[_x2] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n            for (var x = 0, xl = to.length; x < xl; ++x) {\n                var toAddr = String(to[x]);\n                var atIdx = toAddr.lastIndexOf(\"@\");\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                var domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                } catch (e) {\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n                to[x] = localPart + \"@\" + domain;\n            }\n            components.path = to.join(\",\");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join(\"&\");\n        }\n        return components;\n    }\n};\n\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n//RFC 2141\nvar handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = matches[1].toLowerCase();\n            var nss = matches[2];\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            urnComponents.nid = nid;\n            urnComponents.nss = nss;\n            urnComponents.path = undefined;\n            if (schemeHandler) {\n                urnComponents = schemeHandler.parse(urnComponents, options);\n            }\n        } else {\n            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n        }\n        return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n            urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\n        return uriComponents;\n    }\n};\n\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n//RFC 4122\nvar handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n        }\n        return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        //normalize UUID\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n        return urnComponents;\n    }\n};\n\nSCHEMES[handler.scheme] = handler;\nSCHEMES[handler$1.scheme] = handler$1;\nSCHEMES[handler$2.scheme] = handler$2;\nSCHEMES[handler$3.scheme] = handler$3;\nSCHEMES[handler$4.scheme] = handler$4;\nSCHEMES[handler$5.scheme] = handler$5;\nSCHEMES[handler$6.scheme] = handler$6;\n\nexports.SCHEMES = SCHEMES;\nexports.pctEncChar = pctEncChar;\nexports.pctDecChars = pctDecChars;\nexports.parse = parse;\nexports.removeDotSegments = removeDotSegments;\nexports.serialize = serialize;\nexports.resolveComponents = resolveComponents;\nexports.resolve = resolve;\nexports.normalize = normalize;\nexports.equal = equal;\nexports.escapeComponent = escapeComponent;\nexports.unescapeComponent = unescapeComponent;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=uri.all.js.map\n\n\n//# sourceURL=webpack:////home/marcello/mdb/%5B_%5D_Progetti/%5B_%5D_OnLabs.org/%5B_%5D_olojs/node_modules/uri-js/dist/es5/uri.all.js?");

/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "../browser.js":
/*!************!*\
  !*** ..js ***!
  \************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nconst olojs = __webpack_require__(/*! ../browser */ \"../../browser.js\");\n\n\ndescribe(\"olojs\", () => {\n    \n    it(\"should export the `expression` module\", () => {\n        expect(olojs.expression).to.equal(__webpack_require__(/*! ../lib/expression */ \"../../lib/expression.js\"));\n    });\n\n    it(\"should export the `document` module\", () => {\n        expect(olojs.document).to.equal(__webpack_require__(/*! ../lib/document */ \"../../lib/document.js\"));\n    });\n    \n    it(\"should export the `stores/empty` module\", () => {\n        expect(olojs.stores.Empty).to.equal(__webpack_require__(/*! ../lib/stores/empty */ \"../../lib/stores/empty.js\"));\n    });\n\n    it(\"should export the `stores/memory` module\", () => {\n        expect(olojs.stores.Memory).to.equal(__webpack_require__(/*! ../lib/stores/memory */ \"../../lib/stores/memory.js\"));\n    });\n\n    it(\"should export the `stores/http` module exports\", () => {\n        expect(olojs.stores.HTTP).to.equal(__webpack_require__(/*! ../lib/stores/http */ \"../../lib/stores/http.js\"));\n    });\n\n    it(\"should export the `stores/router` module exports\", () => {\n        expect(olojs.stores.Router).to.equal(__webpack_require__(/*! ../lib/stores/router */ \"../../lib/stores/router.js\"));\n    });\n\n    it(\"should export the `environment` module\", () => {\n        expect(olojs.Environment).to.equal(__webpack_require__(/*! ../lib/environment */ \"../../lib/environment.js\"));\n    });\n    \n    __webpack_require__(/*! ./expression */ \"../expression.js\");\n    //require(\"./stdlib\");    \n    __webpack_require__(/*! ./document */ \"../document.js\");\n    \n    describe(\"stores\", () => {\n        __webpack_require__(/*! ./empty-store */ \"../empty-store.js\");\n        __webpack_require__(/*! ./memory-store */ \"../memory-store.js\");\n        //require(\"./http-store\");\n        __webpack_require__(/*! ./router-store */ \"../router-store.js\");\n    });\n    \n    __webpack_require__(/*! ./environment */ \"../environment.js\");\n});\n\n\n//# sourceURL=webpack:///..js?");

/***/ }),

/***/ "../document.js":
/*!**********************!*\
  !*** ../document.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar expression = __webpack_require__(/*! ../lib/expression */ \"../../lib/expression.js\");\n\nvar document = __webpack_require__(/*! ../lib/document */ \"../../lib/document.js\");\n\n\ndescribe(\"document\", () => {\n    \n    describe(\"evaluateDocument = document.parse(source)\", () => {\n        \n        it(\"should be a function\", () => {\n            var source = `<%a=10%><%b=a+10%>a + b = <%a+b%>`;\n            var evaluate = document.parse(source);\n            expect(evaluate).to.be.a(\"function\");            \n        });\n        \n        describe(\"docns = await evaluateDocument(context)\", () => {\n            \n            it(\"should be an object\", async () => {\n                var evaluate = document.parse(\"document source ...\");\n                var context = expression.createContext();\n                var docNS = await evaluate(context);\n                expect(docNS).to.be.an(\"object\");                \n            });\n            \n            it(\"should contain all the names defined in the swan expressions\", async () => {\n                var source = `<%a=10%><%b=a+10%>a + b = <%a+b%>`;\n                var evaluate = document.parse(source);\n                var context = expression.createContext({});\n                var docNS = await evaluate(context);\n                expect(docNS).to.deep.equal({a:10, b:20, __str__:\"a + b = 30\"});                \n            });\n            \n            it(\"should stringify to a text obtained replacing the swan expressions with their return value\", async () => {\n                var source = `<%a=10%><%b=a+10%>a + b = <%a+b%>`;\n                var evaluate = document.parse(source);\n                var context = expression.createContext();\n                var docNS = await evaluate(context);\n                expect(expression.stringify(docNS)).to.equal(\"a + b = 30\");                \n            });\n\n            it(\"should return context.$renderError when an expression throws an error\", async () => {\n                var source = `<% 1 + [] %><% a=10 %>`;\n                var evaluate = document.parse(source);\n                expect(evaluate).to.be.a(\"function\");\n                var context = expression.createContext({\n                    $renderError: error => \"<ERR!>\"\n                }).$extend({});\n                var docNS = await evaluate(context);\n                expect(docNS).to.deep.equal({a:10, __str__:\"<ERR!>\"})\n            });            \n        });        \n    });\n    \n    describe(\"rendered_doc = await document.render(doc_namespace)\", () => {\n        \n        it(\"should stringify the document namespace\", async () => {\n            var source = `<%a=10%><%b=a+10%>a + b = <%a+b%>`;\n            var evaluate = document.parse(source);\n            var context = expression.createContext({});\n            var doc_namespace = await evaluate(context);\n            var doc_rendering = await document.render(doc_namespace);\n            expect(doc_rendering).to.equal(\"a + b = 30\");\n        });\n        \n        it(\"should decorate the stringified docns via context.__render__(str) if it exists\", async () => {\n            var source = `<%a=10%><%b=a+10%>a + b = <%a+b%>`;\n            var evaluate = document.parse(source);\n            var context = expression.createContext({});\n            context.__render__ = text => text + \"!\";\n            var doc_namespace = await evaluate(context);\n            var doc_rendering = await document.render(doc_namespace);\n            expect(doc_rendering).to.equal(\"a + b = 30!\");\n        });        \n    });\n    \n    describe(\"context = document.createContext(namespace)\", () => {\n        \n        it(\"should be an expression context\", () => {\n            var expContext = Object.getPrototypeOf(expression.createContext());\n            var docContext = document.createContext();\n            expect(expContext.isPrototypeOf(docContext)).to.equal(true);\n        });\n        \n        it(\"should contain a $renderError function\", () => {\n            var docContext = document.createContext();\n            expect(docContext.$renderError).to.be.a(\"function\");            \n        });\n\n        it(\"should contain the passed namespace properties as own properties\", () => {\n            var namespace = {a:1,b:2};\n            var docContext = document.createContext(namespace);\n            var ownProps = Object.assign({}, docContext);\n            expect(ownProps).to.deep.equal(namespace);\n        });\n    });\n});\n\n\n//# sourceURL=webpack:///../document.js?");

/***/ }),

/***/ "../empty-store.js":
/*!*************************!*\
  !*** ../empty-store.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar EmptyStore = __webpack_require__(/*! ../lib/stores/empty */ \"../../lib/stores/empty.js\");\nvar errors = __webpack_require__(/*! ../lib/stores/store-errors */ \"../../lib/stores/store-errors.js\");\n\n\ndescribe(\"EmptyStore\", () => {\n    \n    describe(\"source = nullStore.get(path)\", () => {\n        \n        describe(`when a document path is passed`, () => {\n            it(\"should always return an empty string\", async () => {\n                var nullStore = new EmptyStore();\n                expect(await nullStore.get(\"/pathh/to/doc1\")).to.equal(\"\");\n                expect(await nullStore.get(\"/pathh/to/doc2\")).to.equal(\"\");\n                expect(await nullStore.get(\"/pathh/to/../to/doc3/../doc4\")).to.equal(\"\");\n            });\n        });\n\n        describe(`when a directory path is passed`, () => {            \n            it(\"should always return an empty string\", async () => {\n                var nullStore = new EmptyStore();\n                expect(await nullStore.get(\"/pathh/to/dir1/\")).to.equal(\"\");\n                expect(await nullStore.get(\"/pathh/to/dir2/\")).to.equal(\"\");\n                expect(await nullStore.get(\"/pathh/to/../to/doc3/../dir4/\")).to.equal(\"\");\n            });\n        });\n    });        \n\n    describe(\"nullStore.set(path, source)\", () => {\n        it(\"should throw an `OperationNotAllowed` error\", async () => {\n            var nullStore = new EmptyStore();\n            try {\n                await nullStore.set(\"/path/to/doc1\", \"source of doc 1\");\n                throw new Error(\"Id didn't throw\");\n            } catch (error) {\n                expect(error).to.be.instanceof(errors.OperationNotAllowed);\n                expect(error.message).to.equal(\"Operation not allowed: SET /path/to/doc1\");\n            }\n        });\n    });        \n\n    describe(\"nullStore.delete(path)\", () => {\n        it(\"should throw an `OperationNotAllowed` error\", async () => {\n            var nullStore = new EmptyStore();\n            try {\n                await nullStore.delete(\"/path/to/doc1\");\n                throw new Error(\"Id didn't throw\");\n            } catch (error) {\n                expect(error).to.be.instanceof(errors.OperationNotAllowed);\n                expect(error.message).to.equal(\"Operation not allowed: DELETE /path/to/doc1\");\n            }\n        });\n    });        \n});    \n\n\n//# sourceURL=webpack:///../empty-store.js?");

/***/ }),

/***/ "../environment.js":
/*!*************************!*\
  !*** ../environment.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nconst Path = __webpack_require__(/*! path */ \"../../node_modules/path-browserify/index.js\");\n\nvar expression = __webpack_require__(/*! ../lib/expression */ \"../../lib/expression.js\");\nvar document = __webpack_require__(/*! ../lib/document */ \"../../lib/document.js\");\nvar Environment = __webpack_require__(/*! ../lib/environment */ \"../../lib/environment.js\");\nvar EmptyStore = __webpack_require__(/*! ../lib/stores/empty */ \"../../lib/stores/empty.js\");\nvar MemoryStore = __webpack_require__(/*! ../lib/stores/memory */ \"../../lib/stores/memory.js\");\n\n\n\ndescribe(\"Environment class\", () => {\n    \n    it(\"should contain the passed options.globals object or {}\", () => {\n        var globals = {};\n        var env = new Environment({globals});\n        expect(globals.isPrototypeOf(env.globals)).to.be.true;\n        \n        var env = new Environment();\n        expect(Object.keys(env.globals).length).to.equal(1);\n        \n        var globals = [1,2,3];\n        var env = new Environment({globals});\n        expect(globals.isPrototypeOf(env.globals)).to.be.false;\n        expect(Object.keys(env.globals).length).to.equal(1);\n    });\n    \n    it(\"should contains the passed options.scope or MemoryStore\", () => {\n        var store = new EmptyStore;\n        var env = new Environment({store});\n        expect(env.store).to.equal(store);\n        \n        var env = new Environment();\n        expect(env.store).to.be.instanceof(MemoryStore);\n        \n        var store = {get:()=>\"\"};\n        var env = new Environment({store});\n        expect(env.store).to.be.instanceof(MemoryStore);\n        \n    });\n    \n    describe(\"doc = environment.createDocument(source, presets)\", () => {\n        \n        it(\"should return an object\", async () => {\n            var env = new Environment();\n            var doc = env.createDocument(\"/\", \"source\");\n            expect(doc).to.be.an(\"object\");\n        });\n        \n        describe(\"doc.id\", () => {\n            it(\"should contain the passed document id in normalized form\", () => {\n                var env = new Environment();\n                \n                var doc = env.createDocument('/path/[ ] to/x/../doc?x=1&y=2', \"...\");\n                expect(doc.id).to.equal('/path/[ ] to/doc?x=1&y=2');\n\n                var doc = env.createDocument('path/to/./doc?x=1&y=2#ha', \"...\");\n                expect(doc.id).to.equal('/path/to/doc?x=1&y=2#ha');\n\n                var doc = env.createDocument('path/to/./doc#ha', \"...\");\n                expect(doc.id).to.equal('/path/to/doc#ha');\n\n                var doc = env.createDocument('path/to/./doc/', \"...\");\n                expect(doc.id).to.equal('/path/to/doc/');\n            });\n        });\n        \n        describe(\"doc.source\", () => {\n            \n            it(\"should contain the document source\", () => {\n                var env = new Environment();\n                var source = \"this is the document source\";\n                var doc = env.createDocument('/', source);\n                expect(doc.source).to.equal(source);\n                \n            });\n        });\n        \n        describe(\"doc.evaluate\", () => {\n            \n            it(\"should contain the function returned by document.parse(doc.source)\", async () => {\n                var env = new Environment();\n                var doc = env.createDocument('/', \"<% y = 2*x %>\");\n                expect(doc.evaluate).to.be.a(\"function\");\n                \n                var context = document.createContext({x:10});\n                var docNS = await doc.evaluate(context);\n                expect(docNS.y).to.equal(20);\n            });\n            \n            it(\"should return always the same function (parse only once)\", async () => {\n                var env = new Environment();\n                var doc = env.createDocument('/', \"...\");\n                expect(doc.evaluate).to.equal(doc.evaluate);\n            });\n        });\n        \n        describe(\"context = doc.createContext(...namespace)\", () => {\n            \n            it(\"should return a context\", async () => {\n                var env = new Environment();\n                var doc = env.createDocument('/', \"...\");\n                var docContext = doc.createContext();\n\n                var rootContext = Object.getPrototypeOf(document.expression.createContext());\n                expect(rootContext.isPrototypeOf(docContext)).to.be.true;\n            });\n            \n            it(\"should contain the names contained in the passed namespaces\", async () => {\n                var env = new Environment();\n                var doc = env.createDocument('/', \"...\");\n                var context = doc.createContext({x:10, y:20}, {y:30});\n                expect(context.x).to.equal(10);\n                expect(context.y).to.equal(30);\n            });\n            \n            it(\"should contain the names contained in the `globals` namespaces passed to the environment constructor\", () => {\n                var env = new Environment({\n                    globals: {x:10, y:20}\n                });\n                var doc = env.createDocument('/', \"...\");\n                var context = doc.createContext({y:30});\n                expect(context.x).to.equal(10);\n                expect(context.y).to.equal(30);\n            });\n            \n            it(\"should contain the names contained in the `presets` namespace\", () => {\n                var env = new Environment();\n                var doc = env.createDocument('/', \"...\", {x:10, y:20});\n                var context = doc.createContext({y:30});\n                expect(context.x).to.equal(10);\n                expect(context.y).to.equal(20);\n            });\n            \n            it(\"should contain a `argns` object with all the parameters defined in the id query string\", () => {\n                var env = new Environment();\n                var doc = env.createDocument('/path/to/doc?x=10&s=abc', \"...\");\n                var context = doc.createContext();\n                expect(context.argns).to.deep.equal({x:10, s:'abc'});\n            });\n            \n            it(\"should contain the property `import` mapping to a function\", async () => {\n                var env = new Environment({\n                    protocols: {\n                        ppp: {get: path => `Doc source @ ppp:${Path.join('/',path)}`}\n                    }\n                });\n                var doc = await env.createDocument(`/`, \"...\");\n                var context = doc.createContext();\n                expect(context.import).to.be.a(\"function\");\n            });\n            \n            describe(\"docNS = context.import(uri, ...namespaces)\", () => {\n                \n                it(\"should load, evaluate and return the namespace of the olo-document mapped to `uri`\", async () => {\n                    \n                    class TestStore extends EmptyStore {\n                        get (path) {\n                            return `<% i = \"${Path.join('/',path)}\" %>`;\n                        }\n                    }                    \n                    \n                    var env = new Environment({\n                        store: new TestStore()\n                    });\n                    var doc1 = env.createDocument(`/path/to/doc1`, '...');\n                    var context1 = doc1.createContext();\n                    var doc2_ns = await context1.import(\"/path/to/doc2\");\n                    expect(doc2_ns.i).to.equal(\"/path/to/doc2\");\n                });                    \n                \n                it(\"should resolve `uri` relative to the calling document URI\", async () => {\n\n                    class TestStore extends EmptyStore {\n                        get (path) {\n                            return `<% i = \"${Path.join('/',path)}\" %>`;\n                        }\n                    }                    \n\n                    var env = new Environment({\n                        store: new TestStore()\n                    });\n                    var doc1 = await env.createDocument(`/path/to/doc1`, \"...\");\n                    var context1 = doc1.createContext();\n                    \n                    var doc2_ns = await context1.import(\"./doc2\");\n                    expect(doc2_ns.i).to.equal(\"/path/to/doc2\");\n\n                    var doc3_ns = await context1.import(\"../to_doc3\");\n                    expect(doc3_ns.i).to.equal(\"/path/to_doc3\");\n\n                    var doc4_ns = await context1.import(\"/path_to/doc4\");\n                    expect(doc4_ns.i).to.equal(\"/path_to/doc4\");\n                    \n                    var dir = await env.createDocument(`/path/to/`, \"...\");\n                    var context2 = dir.createContext();\n                    \n                    var doc5_ns = await context2.import(\"./doc5\");\n                    expect(doc5_ns.i).to.equal(\"/path/to/doc5\");\n\n                    var doc6_ns = await context2.import(\"../to_doc6\");\n                    expect(doc6_ns.i).to.equal(\"/path/to_doc6\");\n\n                    var doc7_ns = await context2.import(\"/path_to/doc7\");\n                    expect(doc7_ns.i).to.equal(\"/path_to/doc7\");\n                });\n                \n                it(\"should cache the imported documents\", async () => {\n                    var counter = 0;\n\n                    class TestStore extends EmptyStore {\n                        get (path) {\n                            counter += 1;\n                            return `<% i = \"${Path.join('/',path)}\" %>`;\n                        }\n                    }                    \n\n                    var env = new Environment({\n                        store: new TestStore()\n                    });\n\n                    var doc1 = await env.createDocument(`ppp:/path/to/doc1`);\n                    var context1 = doc1.createContext();\n                    expect(counter).to.equal(0);\n\n                    var doc2_NS = await context1.import(\"/path/to/doc2\");\n                    expect(counter).to.equal(1);\n                    \n                    var doc2_NS = await context1.import(\"/path/to/doc2\");\n                    expect(counter).to.equal(1);\n                    \n                    var doc3_NS = await context1.import(\"/path/to/doc3\");\n                    expect(counter).to.equal(2);\n                });\n            });        \n        });        \n    });\n    \n    describe(\"environment.render\", () => {\n        \n        it(\"should delegate to `document.render`\", () => {\n            var render = document.render;\n            document.render = value => [value];\n            var env = new Environment();\n            expect(env.render(10)).to.deep.equal([10]);\n            expect(env.render({x:1})).to.deep.equal([{x:1}]);\n            document.render = render;\n        });\n    });\n    \n    describe(\"doc = await environment.readDocument(id)\", () => {\n        \n        it(\"should call the store.get method\", async () => {\n            var pathParameter;\n            \n            class TestStore extends EmptyStore {\n                get (path) {\n                    pathParameter = path;\n                }\n            }\n            \n            var env = new Environment({\n                store: new TestStore()\n            });\n            \n            await env.readDocument(\"/path/to/doc\");            \n            expect(pathParameter).to.equal(\"/path/to/doc\");\n        });        \n        \n        it(\"should return a document with source given by the proper protocol get handler\", async () => {\n            class TestStore extends EmptyStore {\n                get (path) {\n                    return `Doc source @ ${path}`;\n                }\n            }\n            \n            var env = new Environment({\n                store: new TestStore()\n            });\n            \n            var doc = await env.readDocument(`/path/to/doc`);\n            expect(doc.id).to.equal(`/path/to/doc`);\n            expect(doc.source).to.equal(\"Doc source @ /path/to/doc\");\n        });\n    });\n    \n    describe(\"await environment.writeDocument(path, source)\", () => {\n        \n        it(\"should call the store.set method\", async () => {\n            var writtenSource;\n            \n            class TestStore extends EmptyStore {\n                set (path, source) {\n                    writtenSource = source;\n                }\n            }\n            \n            var env = new Environment({\n                store: new TestStore()\n            });\n            \n            await env.writeDocument(\"/path/to/doc\", \"Doc source @ /path/to/doc\");            \n            expect(writtenSource).to.equal(\"Doc source @ /path/to/doc\");\n        });        \n    });\n\n    describe(\"await environment.deleteDocument(path)\", () => {\n        \n        it(\"should call the store.get method\", async () => {\n            var pathParameter;\n            \n            class TestStore extends EmptyStore {\n                delete (path) {\n                    pathParameter = path;\n                }\n            }\n            \n            var env = new Environment({\n                store: new TestStore()\n            });\n            \n            await env.deleteDocument(\"/path/to/doc\");            \n            expect(pathParameter).to.equal(\"/path/to/doc\");\n        });        \n    });\n});\n\n\n//# sourceURL=webpack:///../environment.js?");

/***/ }),

/***/ "../expression.js":
/*!************************!*\
  !*** ../expression.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar {parse, createContext, Exception, createTuple} = __webpack_require__(/*! ../lib/expression */ \"../../lib/expression.js\");\nvar evaluate = (source, context) => parse(source)(context);\n\nconst isTuple = value => typeof value[Symbol.iterator] === \"function\";\n\n\nclass ExceptionExpected extends Error {};\n\nasync function expectException (testFn, message) {\n    try {\n        await testFn();\n        throw new ExceptionExpected();\n    } catch (e) {\n        expect(e).to.be.instanceof(Exception);\n        expect(e.message).to.equal(message);\n    }    \n}\n\n\ndescribe(\"expression\", () => {\n    \n    \n    // CORE\n    \n    describe(\"numeric literals\", () => {\n        \n        it(\"should evaluate decimal numeric literals to numbers\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"10\", ctx)).to.equal(10);\n            expect(await evaluate(\"0\", ctx)).to.equal(0);\n            expect(await evaluate(\"-10\", ctx)).to.equal(-10);\n            expect(await evaluate(\"3.2\", ctx)).to.equal(3.2);\n            expect(await evaluate(\"-3.2\", ctx)).to.equal(-3.2);\n            expect(await evaluate(\"1.2e3\", ctx)).to.equal(1200);\n        });\n    });\n    \n    describe(\"string literals\", () => {\n    \n        it(`should evaluate string literals between double quotes '\"\"'`, async () => {\n            var ctx = createContext();\n            expect(await evaluate(`\"abc\"`, ctx)).to.equal(\"abc\");\n            expect(await evaluate(`\"\"`, ctx)).to.equal(\"\");\n        });        \n    \n        it(\"should evaluate string literals between single quotes `''`\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(`'def'`, ctx)).to.equal(\"def\");\n            expect(await evaluate(`''`, ctx)).to.equal(\"\");\n        });        \n    \n        it(\"should evaluate string literals between accent quotes '``'\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"`ghi`\", ctx)).to.equal(\"ghi\");\n            expect(await evaluate(\"``\", ctx)).to.equal(\"\");\n        });        \n    });\n    \n    describe(\"tuples: `exp1, exp2, exp3, ...`\", () => {\n    \n        it(\"should return the comma-separated values as an iterable\", async () => {\n            var ctx = createContext();\n            var tuple = await evaluate(\"10,'abc'\", ctx);\n            expect(isTuple(tuple)).to.be.true;\n            expect(Array.from(tuple)).to.deep.equal([10,\"abc\"]);            \n        });\n    \n        it(\"should flatten tuples of tuples: `(X,Y),Z` results in `X,Y,Z`\", async () => {\n            var ctx = createContext();\n            var tuple = await evaluate(\"1,(2,3),4,(5,(6,7)),8,9\", ctx);\n            expect(isTuple(tuple)).to.be.true;\n            expect(Array.from(tuple)).to.deep.equal([1,2,3,4,5,6,7,8,9]);\n        });\n    \n        it(\"should ignore empty tuples when flattening tuples: `X,(),Y` results in `X,Y`\", async () => {\n            var ctx = createContext();\n    \n            var tuple = await evaluate(\"1,(),2\", ctx);\n            expect(isTuple(tuple)).to.be.true;\n            expect(Array.from(tuple)).to.deep.equal([1,2]);\n    \n            var tuple = await evaluate(\"(),(1,(),2),(),3\", ctx);\n            expect(isTuple(tuple)).to.be.true;\n            expect(Array.from(tuple)).to.deep.equal([1,2,3]);            \n        });\n    \n        it(\"should evaluate empty tuples `()` as null\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"\", ctx)).to.equal(null);\n            expect(await evaluate(\"()\", ctx)).to.equal(null);\n            expect(await evaluate(\"(), (), ()\", ctx)).to.equal(null);\n        });\n    \n        it(\"should evaluate 1-uples (x,()) as x\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"(), 10, ()\", ctx)).to.equal(10);\n        });\n    });\n    \n    describe(\"lists: `[expression]`\", () => {\n    \n        it(\"should return an array\", async () => {\n            var ctx = createContext();\n    \n            var list = await evaluate(\"[1,'abc',3]\", ctx);\n            expect(list).to.deep.equal([1,\"abc\",3]);\n    \n            var list = await evaluate(\"[1]\", ctx);\n            expect(list).to.deep.equal([1]);\n    \n            var list = await evaluate(\"[]\", ctx);\n            expect(list).to.deep.equal([]);\n        });\n    \n        it(\"should not flatten deep lists\", async () => {\n            var ctx = createContext();\n            var list = await evaluate(\"[[1,2],3,4,[]]\", ctx)\n            expect(list).to.deep.equal([[1,2],3,4,[]]);            \n        });\n    });\n    \n    describe(\"name resolution\", () => {\n    \n        it(\"should return the value mapped to the name in the current context\", async () => {\n            var ctx = createContext({a:10, _b:20, __c__:\"xxx\"});\n            expect(await evaluate(\"a\", ctx)).to.equal(10);\n            expect(await evaluate(\"_b\", ctx)).to.equal(20);\n            expect(await evaluate(\"__c__\", ctx)).to.equal(\"xxx\");\n        });\n    \n        it(\"should return `null` (empty tuple) if the name is not mapped\", async () => {\n            var ctx = createContext({a:10, _b:20});\n            expect(await evaluate(\"d\", ctx)).to.equal(null);\n        });        \n    \n        it(\"should throw an error if an invalid name is used\", async () => {\n            var ctx = createContext({$a:10});\n    \n            try {\n                expect(await evaluate(\"$a\", ctx)).to.equal(10);            \n                throw new ExceptionExpected();                \n            } catch (e) {\n                expect(e).to.not.be.instanceof(ExceptionExpected);\n            }\n    \n            try {\n                expect(await evaluate(\"1x\", ctx)).to.equal(10);            \n                throw new ExceptionExpected();                \n            } catch (e) {\n                expect(e).to.not.be.instanceof(ExceptionExpected);\n            }\n        });\n    \n        it(\"should not return properties inherited from javascript Object\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"isPrototypeOf\", ctx)).to.be.null;\n            expect(await evaluate(\"hasOwnProperty\", ctx)).to.be.null;\n        });\n    \n        describe(\"name resolution in a child context\", () => {\n    \n            it(\"should return the child name value if name is mapped in the child context\", async () => {\n                var ctx = createContext({a:10, b:20});\n                var cctx = Object.create(Object.assign(ctx, {a:100}));\n                expect(await evaluate(\"a\", cctx)).to.equal(100);\n            });\n    \n            it(\"should return the parent name value if name is not mapped in the child context\", async () => {\n                var ctx = createContext({a:10, b:20});\n                var cctx = Object.create(Object.assign(ctx, {a:100}));\n                expect(await evaluate(\"b\", cctx)).to.equal(20);\n            });\n    \n            it(\"should return null if the name is not mapped in the child context nor in the parent context\", async () => {\n                var ctx = createContext({a:10, b:20});\n                var cctx = Object.create(Object.assign(ctx, {a:100}));\n                expect(await evaluate(\"c\", cctx)).to.equal(null);                            \n            });\n        });\n    });\n    \n    describe(\"TRUE constant\", () => {\n        it(\"should return true\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"TRUE\", ctx)).to.equal(true);\n        });\n    });\n    \n    describe(\"FALSE constant\", () => {\n        it(\"should return false\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"FALSE\", ctx)).to.equal(false);\n        });\n    });\n\n    describe(\"labelling operation `name: expression`\", () => {        \n        \n        it(\"should create a new name in the current context and map it to the given value\", async () => {\n            var ctx = createContext();                        \n            await evaluate(\"x: 10\", ctx);\n            expect(ctx.x).to.equal(10);            \n        });\n    \n        it(\"should assign a tuple of values to a tuple of names\", async () => {\n            var ctx = createContext();            \n            await evaluate(\"(a,b,c) : (1,2,3)\", ctx);\n            expect(ctx.a).to.equal(1);        \n            expect(ctx.b).to.equal(2);        \n            expect(ctx.c).to.equal(3);        \n        });\n    \n        it(\"should assign null to the last names if the values tuple is smaller than the names tuple\", async () => {\n            var ctx = createContext();\n            await evaluate(\"(a,b,c,d) : (10,20)\", ctx);\n            expect(ctx.a).to.equal(10);        \n            expect(ctx.b).to.equal(20);        \n            expect(ctx.c).to.be.null;                    \n            expect(ctx.d).to.be.null;                    \n        });\n    \n        it(\"should assign to the last name the tuple of remaining values if the names tuple is smaller than the values tuple\", async () => {\n            var ctx = createContext();\n    \n            await evaluate(\"(a,b) : (100,200,300)\", ctx);\n            expect(ctx.a).to.equal(100);        \n            expect(isTuple(ctx.b)).to.be.true;\n            expect(Array.from(ctx.b)).to.deep.equal([200,300]);\n    \n            await evaluate(\"c : (10,20,30)\", ctx);\n            expect(isTuple(ctx.c)).to.be.true;\n            expect(Array.from(ctx.c)).to.deep.equal([10,20,30]);\n        });\n    \n        it(\"should overwrite an existing name-value mapping\", async () => {\n            var ctx = createContext({a:1});\n            await evaluate(\"a : 2\", ctx);            \n            await evaluate(\"a : 3\", ctx);            \n            expect(ctx.a).to.equal(3);\n        });        \n        \n        it(\"should return the expression value\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"x: 10\", ctx)).to.equal(10);  \n            \n            var val = await evaluate(\"(a,b,c) : (1,2,3)\", ctx);\n            expect(Array.from(val)).to.deep.equal([1,2,3]);\n                      \n            var val = await evaluate(\"(a,b,c,d) : (10,20)\", ctx);\n            expect(Array.from(val)).to.deep.equal([10,20]);\n\n            var val = await evaluate(\"(a,b) : (100,200,300)\", ctx);\n            expect(Array.from(val)).to.deep.equal([100,200,300]);\n\n            var val = await evaluate(\"c : (10,20,30)\", ctx);\n            expect(Array.from(val)).to.deep.equal([10,20,30]);\n        });\n    });\n        \n    describe(\"assignment operation: name = expression\", () => {        \n    \n        it(\"should return null\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"x = 10\", ctx)).to.equal(null);            \n        });\n    \n        it(\"should create a new name in the current context and map it to the given value\", async () => {\n            var ctx = createContext();                        \n            await evaluate(\"x = 10\", ctx);\n            expect(ctx.x).to.equal(10);            \n        });\n    \n        it(\"should assign a tuple of values to a tuple of names\", async () => {\n            var ctx = createContext();            \n            await evaluate(\"(a,b,c) = (1,2,3)\", ctx);\n            expect(ctx.a).to.equal(1);        \n            expect(ctx.b).to.equal(2);        \n            expect(ctx.c).to.equal(3);        \n        });\n    \n        it(\"should assign null to the last names if the values tuple is smaller than the names tuple\", async () => {\n            var ctx = createContext();\n            await evaluate(\"(a,b,c,d) = (10,20)\", ctx);\n            expect(ctx.a).to.equal(10);        \n            expect(ctx.b).to.equal(20);        \n            expect(ctx.c).to.be.null;                    \n            expect(ctx.d).to.be.null;                    \n        });\n    \n        it(\"should assign to the last name the tuple of remaining values if the names tuple is smaller than the values tuple\", async () => {\n            var ctx = createContext();\n    \n            await evaluate(\"(a,b) = (100,200,300)\", ctx);\n            expect(ctx.a).to.equal(100);        \n            expect(isTuple(ctx.b)).to.be.true;\n            expect(Array.from(ctx.b)).to.deep.equal([200,300]);\n    \n            await evaluate(\"c = (10,20,30)\", ctx);\n            expect(isTuple(ctx.c)).to.be.true;\n            expect(Array.from(ctx.c)).to.deep.equal([10,20,30]);\n        });\n    \n        it(\"should overwrite an existing name-value mapping\", async () => {\n            var ctx = createContext({a:1});\n            await evaluate(\"a = 2\", ctx);            \n            await evaluate(\"a = 3\", ctx);            \n            expect(ctx.a).to.equal(3);\n        });        \n    });\n    \n    describe(\"namespace definition: {expression}\", () => {\n    \n        it(\"return an object with the mapped names\", async () => {\n            var ctx = createContext();                    \n            expect(await evaluate(\"{x=1, y:2, z=3}\", ctx)).to.deep.equal({x:1,y:2,z:3});\n        });\n    \n        it(\"should ignore the non-assignment operations\", async () => {\n            var ctx = createContext();                    \n            expect(await evaluate(\"{x=1, 10, y=2, z=3}\", ctx)).to.deep.equal({x:1,y:2,z:3});\n        });\n    \n        it(\"should not assign the names to the parent context\", async () => {\n            var ctx = createContext({x:10});                    \n            expect(await evaluate(\"{x=20}\", ctx)).to.deep.equal({x:20});\n            expect(ctx.x).to.equal(10);\n        });\n    });\n    \n    describe(\"function definition: names_tuple -> expression\", () => {\n    \n        it(\"should return a function resolving the expression in a context augumented with the argument names\", async () => {\n            var ctx = createContext();        \n            var foo = await evaluate(\"(x, y) -> [y,x]\", ctx);\n            expect(foo).to.be.a(\"function\");\n            expect(await foo(10,20)).to.deep.equal([20,10]);\n        });\n    \n        it(\"should follow the assignment rules when mapping argument names to parameters\", async () => {\n            var ctx = createContext();        \n    \n            var foo = await evaluate(\"(x, y) -> {a=x,b=y}\", ctx);\n            expect(await foo(10)).to.deep.equal({a:10, b:null});            \n    \n            var retval = await foo(10,20,30);\n            expect(retval.a).to.equal(10);\n            expect(isTuple(retval.b)).to.be.true;\n            expect(Array.from(retval.b)).to.deep.equal([20,30]);\n        });\n    \n        it(\"should be righ-to-left associative\", async () => {\n            var ctx = createContext();        \n    \n            var foo = await evaluate(\"x -> y -> {a=x,b=y}\", ctx);\n            var foo10 = await foo(10);\n            expect(foo10).to.be.a(\"function\");\n            expect(await foo10(20)).to.deep.equal({a:10, b:20});                        \n        });\n    });\n    \n    describe(\"'apply' operation: X Y\", async () => {\n    \n        describe(\"when X is a function\", () => {\n    \n            it(\"should call the function with the parameter Y and return its return value\", async () => {\n                var ctx = createContext({\n                    double: x => 2 * x,\n                    sum: (x,y) => x + y\n                });                    \n                expect(await evaluate(\"(x -> [x]) 10\", ctx)).to.deep.equal([10]);\n                expect(await evaluate(\"((x, y) -> [y,x])(10, 20)\", ctx)).to.deep.equal([20,10]);\n                expect(await evaluate(\"double 25\", ctx)).to.equal(50);\n                expect(await evaluate(\"sum(10, 20)\", ctx)).to.equal(30);\n            });\n        });\n    \n        describe(\"when X is a string\", async () => {\n    \n            it(\"shoudl return the character at Y if Y is an integer\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"'abcdef' 2\", ctx)).to.equal('c');                    \n            });\n    \n            it(\"should consider only the integer part of Y if Y is a decimal number\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"'abcdef' 2.3\", ctx)).to.equal('c');                                        \n            });\n    \n            it(\"should consider negative indexes as relative to the string end\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"'abcdef' (-2)\", ctx)).to.equal('e');                                        \n            });\n    \n            it(\"should return an empty string if Y is an out of range number\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"'abcdef' 100\", ctx)).to.equal(\"\");\n                expect(await evaluate(\"'abcdef' (-100)\", ctx)).to.equal(\"\");                                                            \n            });\n    \n            it(\"should return an empty string if Y is not a number\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"'abcdef' '2'\", ctx)).to.equal(\"\");  \n                expect(await evaluate(\"'abcdef' (1,3)\", ctx)).to.equal(\"\");  \n            });     \n        });\n    \n        describe(\"when X is a list\", () => {\n    \n            it(\"shoudl return the item at index Y if Y is an integer\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"['a','b','c','d','e','f'] 2\", ctx)).to.equal('c');                    \n            });\n    \n            it(\"should consider only the integer part of Y if it is a decimal number\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"['a','b','c','d','e','f'] 2.3\", ctx)).to.equal('c');                                        \n            });\n    \n            it(\"should consider a negative indexe Y as relative to the list end\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"['a','b','c','d','e','f'] (-2)\", ctx)).to.equal('e');                                                            \n            });\n    \n            it(\"should return null if the index Y is out of range\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"['a','b','c','d','e','f'] 100\", ctx)).to.equal(null);                                                            \n                expect(await evaluate(\"['a','b','c','d','e','f'] (-100)\", ctx)).to.equal(null);                                                            \n            });\n    \n            it(\"should return null if Y is not a number\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"['a','b','c','d','e','f'] '2'\", ctx)).to.equal(null);                                                            \n                expect(await evaluate(\"['a','b','c','d','e','f'] (2,4)\", ctx)).to.equal(null);                                                            \n            });\n        });\n    \n        describe(\"when X is a namespace\", () => {\n    \n            it(\"should return the value mapped to the name Y\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"{a=1,b=2,c=3} 'c'\", ctx)).to.equal(3);\n            });\n    \n            it(\"should return null if Y is not a valid name\", async () => {                    \n                var ctx = createContext();\n                expect(await evaluate(\"{a=1,b=2,c=3} 1\", ctx)).to.equal(null);\n                expect(await evaluate(\"{a=1,b=2,c=3} '$key'\", ctx)).to.equal(null);\n                expect(await evaluate(\"{a=1,b=2,c=3} ('a','b')\", ctx)).to.equal(null);\n            });\n    \n            it(\"should return null if Y is a name not mapped to any value\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"{a=1,b=2,c=3} 'd'\", ctx)).to.equal(null);\n            });\n    \n            it(\"should delegate to `X.__apply__` if it exists and it is a function\", async () => {\n                var ctx = createContext();\n    \n                var val = await evaluate(\"{__apply__ = s -> ['val of', s]}('x')\", ctx);\n                expect(val).to.deep.equal([\"val of\", \"x\"]);\n    \n                var val = await evaluate(\"{__apply__ = (x,y) -> ['val:', y, x]}(10,20)\", ctx);\n                expect(val).to.deep.equal([\"val:\", 20, 10]);\n    \n                val = await evaluate(\"{__apply__=1, a=2}('a')\", ctx);\n                expect(val).to.equal(2);\n            });            \n        });\n    \n        describe(\"when X is a number\", () => {\n    \n            it(\"should throw an exception\", async () => {\n                var ctx = createContext();\n    \n                try {\n                    await evaluate(\"(10)(1)\", ctx);\n                    throw new Error();\n                } catch (e) {\n                    expect(e).to.be.instanceof(Exception);\n                    expect(e.message).to.equal(\"Apply operation not defined between Number and Number\");\n                }\n            });            \n        });\n    \n        describe(\"when X is a boolean\", () => {\n    \n            it(\"should throw an exception\", async () => {\n                var ctx = createContext({b:true});\n    \n                try {\n                    await evaluate(\"b(1)\", ctx);\n                    throw new Error();\n                } catch (e) {\n                    expect(e).to.be.instanceof(Exception);\n                    expect(e.message).to.equal(\"Apply operation not defined between Boolean and Number\");\n                }\n            });            \n        });\n    \n        describe(\"when X is a tuple\", () => {\n    \n            it(\"should return a tuple obtained by calling the items of X\", async () => {\n                var ctx = createContext({\n                    x2: a => 2*a,\n                    x3: a => 3*a,\n                    x4: [100,200,300],\n                });\n    \n                var retval = await evaluate(\"(x2,x3,x4) 2\", ctx);\n                expect(isTuple(retval)).to.be.true;\n                expect(Array.from(retval)).to.deep.equal([4,6,300]);\n            });\n    \n            it(\"should throw an exception if any of the items of X throw an exception\", async () => {\n                var ctx = createContext({\n                    x2: a => 2*a,\n                    x3: a => 3*a,\n                    x4: [100,200,300],\n                });\n    \n                try {\n                    await evaluate(\"(x2, 10, x3)(1)\", ctx);\n                    throw new Error();\n                } catch (e) {\n                    expect(e).to.be.instanceof(Exception);\n                    expect(e.message).to.equal(\"Apply operation not defined between Number and Number\");\n                }                \n            });\n    \n            it(\"should return always null if X is an empty tuple\", async () => {\n                var ctx = createContext();\n                expect(await evaluate(\"()1\", ctx)).to.equal(null);            \n                expect(await evaluate(\"()'abc'\", ctx)).to.equal(null);            \n                expect(await evaluate(\"()[1,2,3]\", ctx)).to.equal(null);            \n                expect(await evaluate(\"()(1,2,3)\", ctx)).to.equal(null);            \n            });\n        });        \n    });    \n    \n    describe(\"sub-contexting: namespace.expression\", () => {\n    \n        it(\"should evaluate 'Y' in the 'X' context if 'X' is a namespace\", async () => {\n            var ctx = createContext({x:10});\n            await evaluate(\"ns = {y=20, z=30, _h=40}\", ctx);\n            expect(await evaluate(\"ns.y\", ctx)).to.equal(20);\n            expect(await evaluate(\"ns.[1,y,z]\", ctx)).to.deep.equal([1,20,30]);\n            expect(await evaluate(\"ns.x\", ctx)).to.equal(10);\n            expect(await evaluate(\"ns._h\", ctx)).to.equal(40);\n    \n            var ctx = createContext({ns:{x:10,y:20,z:30}});\n            expect(await evaluate(\"ns.[x,y,z]\", ctx)).to.deep.equal([10,20,30]);\n        });\n    \n        it(\"should see the global contexts\", async () => {\n            var ctx = createContext({x:10});\n            await evaluate(\"ns = {y=20}\", ctx);\n            expect(await evaluate(\"ns.x\", ctx)).to.equal(10);\n            expect(await evaluate(\"ns.y\", ctx)).to.equal(20);\n        });\n\n        it(\"should see the function parameters in a function expressions\", async () => {\n            var ctx = createContext({});\n            await evaluate(\"ns = {x=10, y=20}\", ctx);            \n            await evaluate(\"f = nsp -> nsp.(3*x+nsp.y)\", ctx);\n            expect(await evaluate(\"f ns\", ctx)).to.equal(50);\n        });\n    \n        it(\"should return a tuple obtained by sub-contexting each item of X if X is a tuple\", async () => {\n            var ctx = createContext({\n                ns1: {a:11, b:12, c:13},\n                ns2: {a:21, b:22, c:23},\n                ns3: {},\n            });\n            var value = await evaluate(\"(ns1, ns2, ns3).b\", ctx);\n            expect(isTuple(value)).to.be.true;\n            expect(Array.from(value)).to.deep.equal([12,22]);\n        });\n    \n        it(\"should return null if X is an empty tuple\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"().b\", ctx)).to.equal(null);\n        });\n    \n        it(\"should throw an exception if 'X' is of any other type\", async () => {\n            var ctx = createContext();\n            await expectException(() => evaluate(\"(10).name\", ctx), \"Namespace expected on the left side of the '.' operator\");\n            await expectException(() => evaluate(\"[].name\", ctx), \"Namespace expected on the left side of the '.' operator\");\n            await expectException(() => evaluate(\"(x->x).name\", ctx), \"Namespace expected on the left side of the '.' operator\");\n        });\n    });\n    \n    describe(\"comments\", () => {\n    \n        it(\"should ignore the text following the `#` character up to the end of the line or of the expression\", async () => {\n            var ctx = createContext();\n            var expression = `\n                # this is a comment\n                12.345 # this is another comment\n                # this is the last comment`\n            expect(await evaluate(expression, ctx)).to.equal(12.345);\n        });\n    \n        it(\"should not parse `#` characters in a string as comments\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"`this # is a string`\", ctx)).to.equal(\"this # is a string\");\n            expect(await evaluate(\"'this # is a string'\", ctx)).to.equal(\"this # is a string\");\n            expect(await evaluate(`\"this # is a string\"`, ctx)).to.equal(\"this # is a string\");\n        });\n    });\n    \n    \n    // BUILT-IN FUNCTIONS\n    \n    describe(\"bool X\", () => {\n    \n        it(\"should return X if it is a boolean\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"bool F\", ctx)).to.equal(false);\n            expect(await evaluate(\"bool T\", ctx)).to.equal(true);                \n        });\n    \n        it(\"should return true if X is a non-zero number\", async () => {\n            var ctx = createContext();            \n            expect(await evaluate(\"bool 0\", ctx)).to.equal(false);\n            expect(await evaluate(\"bool 10\", ctx)).to.equal(true);\n            expect(await evaluate(\"bool (-1)\", ctx)).to.equal(true);\n        });\n    \n        it(\"should return true if X is a non-empty string\", async () => {\n            var ctx = createContext();            \n            expect(await evaluate(\"bool ''\", ctx)).to.equal(false);\n            expect(await evaluate(\"bool 'abc'\", ctx)).to.equal(true);\n        });\n    \n        it(\"should return true if X is a non-empty list\", async () => {\n            var ctx = createContext();            \n            expect(await evaluate(\"bool []\", ctx)).to.equal(false);\n            expect(await evaluate(\"bool [1,2,3]\", ctx)).to.equal(true);\n        });\n    \n        it(\"should return true if X is a non-empty namespace\", async () => {\n            var ctx = createContext();            \n            expect(await evaluate(\"bool {}\", ctx)).to.equal(false);\n            expect(await evaluate(\"bool {a=1,b=2,c=3}\", ctx)).to.equal(true);\n        });\n    \n        it(\"should return true if X is a function\", async () => {\n            var ctx = createContext({jsFn:x=>2*x});\n            expect(await evaluate(\"bool (x->x)\", ctx)).to.equal(true);\n            expect(await evaluate(\"bool jsFn\", ctx)).to.equal(true);\n        });\n    \n        it(\"should return true if X is a tuple with at least one true item\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"bool (0,0,0)\", ctx)).to.equal(false);\n            expect(await evaluate(\"bool (0,1,-1)\", ctx)).to.equal(true);\n        });\n    \n        it(\"should return false if X is an empty tuple\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"bool ()\", ctx)).to.equal(false);\n        });\n    });\n    \n    describe(\"not X\", () => {\n    \n        it(\"should return true if X is false and false if X is true\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"not F\", ctx)).to.equal(true);\n            expect(await evaluate(\"not T\", ctx)).to.equal(false);                \n        });\n    \n        it(\"should return false if X is a non-zero number\", async () => {\n            var ctx = createContext();            \n            expect(await evaluate(\"not 0\", ctx)).to.equal(true);\n            expect(await evaluate(\"not 10\", ctx)).to.equal(false);\n            expect(await evaluate(\"not (-1)\", ctx)).to.equal(false);\n        });\n    \n        it(\"should return false if X is a non-empty string\", async () => {\n            var ctx = createContext();            \n            expect(await evaluate(\"not ''\", ctx)).to.equal(true);\n            expect(await evaluate(\"not 'abc'\", ctx)).to.equal(false);\n        });\n    \n        it(\"should return false if X is a non-empty list\", async () => {\n            var ctx = createContext();            \n            expect(await evaluate(\"not []\", ctx)).to.equal(true);\n            expect(await evaluate(\"not [1,2,3]\", ctx)).to.equal(false);\n        });\n    \n        it(\"should return false if X is a non-empty namespace\", async () => {\n            var ctx = createContext();            \n            expect(await evaluate(\"not {}\", ctx)).to.equal(true);\n            expect(await evaluate(\"not {a=1,b=2,c=3}\", ctx)).to.equal(false);\n        });\n    \n        it(\"should return false if X is a function\", async () => {\n            var ctx = createContext({jsFn:x=>2*x});\n            expect(await evaluate(\"not (x->x)\", ctx)).to.equal(false);\n            expect(await evaluate(\"not jsFn\", ctx)).to.equal(false);\n        });\n    \n        it(\"should return false if X is a tuple with at least one true item\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"not (0,0,0)\", ctx)).to.equal(true);\n            expect(await evaluate(\"not (0,1,-1)\", ctx)).to.equal(false);\n        });\n    \n        it(\"should return true if X is an empty tuple\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"not ()\", ctx)).to.equal(true);\n        });\n    });\n    \n    describe(\"str X\", () => {\n    \n        it(\"should return an empty string if X is nothing\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"str ()\", ctx)).to.equal(\"\");\n        });\n    \n        it(\"should return 'TRUE' if X is true\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"str T\", ctx)).to.equal(\"TRUE\");\n        });\n    \n        it(\"should return 'FALSE' if X is false\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"str F\", ctx)).to.equal(\"FALSE\");\n        });\n    \n        it(\"should return String(X) if X is a number\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"str 123.4\", ctx)).to.equal(\"123.4\");\n        });\n    \n        it(\"should return X itself if it is a string\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"str 'abc'\", ctx)).to.equal(\"abc\");\n        });\n    \n        it(\"should return '[[Function]]' if X is a function\", async () => {\n            var ctx = createContext({jsFn: x => 2*x});\n            expect(await evaluate(\"str(x -> 2)\", ctx)).to.equal(\"[[Function]]\");\n            expect(await evaluate(\"str jsFn\", ctx)).to.equal(\"[[Function]]\");\n        });\n    \n        it(\"should return '[[List of n items]]' when X is a list with n items\", async () => {\n            var ctx = createContext({T:true, F:false});            \n            expect(await evaluate(\"str[1,2,'abc']\", ctx)).to.equal(\"[[List of 3 items]]\")\n        });\n    \n        it(\"should return '[[Namespace of n items]]' when n is the number of items\", async () => {\n            var ctx = createContext({T:true, F:false});            \n            expect(await evaluate(\"str{a=1,b=2,c=3}\", ctx)).to.equal(\"[[Namespace of 3 items]]\");\n        });\n    \n        it(\"should return X.__str__ if it exists and it is a string\", async () => {\n            var ctx = createContext({ns:{__str__: \"ns string\"}});\n            expect(await evaluate(\"str ns\", ctx)).to.equal(\"ns string\");\n        });\n    \n        it(\"should concatenate the serialized item if X is a tuple\", async () => {\n            var ctx = createContext({T:true, F:false, sum: (x,y) => x+y});\n            expect(await evaluate(\"str('it is ',T,' that 1+2 is ',sum(1,2))\", ctx)).to.equal(\"it is TRUE that 1+2 is 3\");\n        });\n    });            \n    \n    describe(\"map fn\", () => {\n    \n        it(\"should return a function that maps its arguments one by one via fn\", async () => {\n            var ctx = createContext({T:true, F:false, fn:x=>2*x});\n            const mappingFn = await evaluate(\"map fn\", ctx);\n            expect(mappingFn).to.be.a(\"function\");\n            const mappedValues = await evaluate(\"map fn (1,2,3,4)\", ctx);\n            expect(isTuple(mappedValues)).to.be.true;\n            expect(Array.from(mappedValues)).to.deep.equal([2,4,6,8]);\n        });\n    \n        it(\"should work with any type\", async () => {\n            var ctx = createContext({T:true, F:false, fn:x=>2*x});\n            var retvals = await evaluate(\"map fn (1,2,3)\", ctx);\n            expect(isTuple(retvals)).to.be.true;\n            expect(Array.from(retvals)).to.deep.equal([2,4,6]);\n    \n            expect(await evaluate(\"map fn ()\", ctx)).to.equal(null);\n        });\n    });\n    \n    describe(\"enum X\", () => {\n        \n        describe(\"wen X is a namespace\", () => {\n            \n            it(\"should return the tuple of {name, value} pairs of the namspace\", async () => {\n                var ctx = createContext();\n                await evaluate(\"ns = {z=3, x=1, y=2}\", ctx);\n                var items = await evaluate(\"enum ns\", ctx);\n                expect(isTuple(items)).to.be.true;\n                expect(Array.from(items)).to.deep.equal([\n                    {name:'x', value:1},\n                    {name:'y', value:2},\n                    {name:'z', value:3},\n                ]);\n            });\n\n            it(\"should return the same tuple for identical namespace\", async () => {\n                var ctx = createContext();\n                \n                await evaluate(\"ns1 = {z=3, x=1, y=2}\", ctx);\n                var items1 = await evaluate(\"enum ns1\", ctx);\n\n                await evaluate(\"ns2 = {x=1, y=2, z=3}\", ctx);\n                var items2 = await evaluate(\"enum ns2\", ctx);\n                \n                expect(Array.from(items1)).to.deep.equal(Array.from(items2));\n            });\n        });\n\n        describe(\"wen X is a list\", () => {\n            \n            it(\"should return the tuple of {index, value} items of the list\", async () => {\n                var ctx = createContext();\n                await evaluate(\"ls = [10,20,30]\", ctx);\n                var items = await evaluate(\"enum ls\", ctx);\n                expect(isTuple(items)).to.be.true;\n                expect(Array.from(items)).to.deep.equal([\n                    {index:0, value:10},\n                    {index:1, value:20},\n                    {index:2, value:30},\n                ]);\n            });\n        });\n\n        describe(\"wen X is a string\", () => {\n            \n            it(\"should return the tuple of {index, value} items of the list of characters)\", async () => {\n                var ctx = createContext();\n                await evaluate(\"s = 'abc'\", ctx);\n                var items = await evaluate(\"enum s\", ctx);\n                expect(isTuple(items)).to.be.true;\n                expect(Array.from(items)).to.deep.equal([\n                    {index:0, value:'a'},\n                    {index:1, value:'b'},\n                    {index:2, value:'c'},\n                ]);\n            });\n        });\n        \n        describe(\"when X is of any other type\", () => {\n            \n            it(\"should throw an error\", async () =>{\n                var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n                var expectRangeError = (expression, xType) => expectException(() => evaluate(expression, ctx), `Enumeration not defined for ${xType} type`);\n                await expectRangeError(\"enum ()\",      'Nothing');                                                \n                await expectRangeError(\"enum T\",       'Boolean');                                                \n                await expectRangeError(\"enum F\",       'Boolean');                                                \n                await expectRangeError(\"enum 1\",       'Number');                                                \n                await expectRangeError(\"enum fn\",      'Function');                                                                \n                await expectRangeError(\"enum (1,2,3)\", 'Tuple');                                    \n            });\n        });\n    });\n    \n    describe(\"size X\", () => {\n    \n        it(\"should return the length if X is a string\", async () => {\n            var ctx = createContext();\n            var size = await evaluate(\"size 'abc'\", ctx);\n            expect(size).to.equal(3);\n        });\n    \n        it(\"should return the length if X is a list\", async () => {\n            var ctx = createContext();\n            var size = await evaluate(\"size [1,2,3]\", ctx);\n            expect(size).to.equal(3);\n        });\n    \n        it(\"should return the number of own names if X is a namespace\", async () => {\n            var ctx = createContext();            \n            var size = await evaluate(\"size {a=1,b=2,c=3}\", ctx);\n            expect(size).to.equal(3);\n    \n            ctx.o = Object.assign(Object.create({x:1,y:2}), {a:1,b:2,c:3});\n            var size = await evaluate(\"size o\", ctx);\n            expect(size).to.equal(3);\n        });\n    \n        it(\"should throw an exception if X is of any other type\", async () => {\n            var ctx = createContext();            \n            var expectSizeError = (expression, XType) => expectException(() => evaluate(expression,ctx), `Size not defined for ${XType} type`);\n            await expectSizeError(\"size TRUE\", \"Boolean\");\n            await expectSizeError(\"size 1\", \"Number\");\n            await expectSizeError(\"size (1,2,3)\", \"Tuple\");\n            await expectSizeError(\"size ()\", \"Nothing\");\n            await expectSizeError(\"size (x->2*x)\", \"Function\");\n        });\n    });\n    \n    describe(\"range n`\", () => {\n    \n        it(\"should return the tuple of all the integers between 0 and n-1\", async () => {\n            var ctx = createContext();\n            var range = await evaluate(\"range(6)\", ctx);\n            expect(isTuple(range)).to.be.true;\n            expect(Array.from(range)).to.deep.equal([0,1,2,3,4,5]);            \n        });\n    \n        it(\"should work also if n < 0\", async () => {\n            var ctx = createContext();\n            var range = await evaluate(\"range(-6)\", ctx);\n            expect(isTuple(range)).to.be.true;\n            expect(Array.from(range)).to.deep.equal([0,-1,-2,-3,-4,-5]);            \n        });\n    \n        it(\"should return an empty tuple if n is 0\", async () => {\n            var ctx = createContext();\n            var range = await evaluate(\"range 0\", ctx);\n            expect(range).to.be.null;\n        });\n\n        it(\"should truncate n if decimal\", async () => {\n            var ctx = createContext();\n            var range = await evaluate(\"range(5.9)\", ctx);\n            expect(isTuple(range)).to.be.true;\n            expect(Array.from(range)).to.deep.equal([0,1,2,3,4]);            \n    \n            var ctx = createContext();\n            var range = await evaluate(\"range(-5.1)\", ctx);\n            expect(isTuple(range)).to.be.true;\n            expect(Array.from(range)).to.deep.equal([0,-1,-2,-3,-4]);            \n\n            var ctx = createContext();\n            var range = await evaluate(\"range 0.3\", ctx);\n            expect(range).to.be.null;\n        });\n        \n        it(\"should throw an exception if n is not numbers\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            var expectRangeError = (expression, xType) => expectException(() => evaluate(expression, ctx), `Range not defined for ${xType} type`);\n            await expectRangeError(\"range ()\",    'Nothing');                                                \n            await expectRangeError(\"range T\",     'Boolean');                                                \n            await expectRangeError(\"range F\",     'Boolean');                                                \n            await expectRangeError(\"range 'abc'\", 'String');                                    \n            await expectRangeError(\"range ls\",    'List');                                    \n            await expectRangeError(\"range fn\",    'Function');                                                \n            await expectRangeError(\"range ns\",    'Namespace');                                    \n        });\n    });\n    \n    describe(\"type x\", () => {\n        \n        it(\"should return 'Nothing' if `x` is an empty tuple\", async () => {\n            expect(await evaluate(\"type()\", createContext())).to.equal(\"Nothing\");\n        });\n        \n        it(\"should return 'Boolean' if `x` is a boolean value\", async () => {\n            expect(await evaluate(\"type TRUE\", createContext())).to.equal(\"Boolean\");\n            expect(await evaluate(\"type FALSE\", createContext())).to.equal(\"Boolean\");\n        });\n        \n        it(\"should return 'Number' if `x` is a number\", async () => {\n            expect(await evaluate(\"type 1\", createContext())).to.equal(\"Number\");\n        });\n        \n        it(\"should return 'String' if `x` is a string\", async () => {\n            expect(await evaluate(\"type 'abc'\", createContext())).to.equal(\"String\");\n        });\n        \n        it(\"should return 'List' if `x` is a list\", async () => {\n            expect(await evaluate(\"type [1,2,3]\", createContext())).to.equal(\"List\");\n        });\n        \n        it(\"should return 'Namespace' if `x` is a namespace\", async () => {\n            expect(await evaluate(\"type {x:1}\", createContext())).to.equal(\"Namespace\");\n        });\n        \n        it(\"should return 'Function' if `x` is a function\", async () => {\n            expect(await evaluate(\"type(()->())\", createContext())).to.equal(\"Function\");\n        });\n        \n        it(\"should return 'Tuple' if `x` is a tuple\", async () => {\n            expect(await evaluate(\"type(1,2,3)\", createContext())).to.equal(\"Tuple\");\n        });\n    });\n        \n    describe(\"require <module-name>\", () => {\n        \n        it(\"should load the `math` module\", async () => {\n            var ctx = createContext();\n            var math = await evaluate(\"require 'math'\", ctx);\n            expect(math).to.equal(__webpack_require__(/*! ../lib/expression/stdlib/math */ \"../../lib/expression/stdlib/math.js\"));            \n        });\n\n        it(\"should load the `markdown` module\", async () => {\n            var ctx = createContext();\n            var markdown = await evaluate(\"require 'markdown'\", ctx);\n            expect(markdown).to.equal(__webpack_require__(/*! ../lib/expression/stdlib/markdown */ \"../../lib/expression/stdlib/markdown.js\"));            \n        });\n\n        it(\"should load the `path` module\", async () => {\n            var ctx = createContext();\n            var path = await evaluate(\"require 'path'\", ctx);\n            expect(path).to.equal(__webpack_require__(/*! ../lib/expression/stdlib/path */ \"../../lib/expression/stdlib/path.js\"));            \n        });\n\n        it(\"should load the `json` module\", async () => {\n            var ctx = createContext();\n            var json = await evaluate(\"require 'json'\", ctx);\n            expect(json).to.equal(__webpack_require__(/*! ../lib/expression/stdlib/json */ \"../../lib/expression/stdlib/json.js\"));            \n        });\n        \n        it(\"should load the `text` module\", async () => {\n            var ctx = createContext();\n            var text = await evaluate(\"require 'text'\", ctx);\n            expect(text).to.equal(__webpack_require__(/*! ../lib/expression/stdlib/text */ \"../../lib/expression/stdlib/text.js\"));            \n        });\n\n        it(\"should load the `list` module\", async () => {\n            var ctx = createContext();\n            var list = await evaluate(\"require 'list'\", ctx);\n            expect(list).to.equal(__webpack_require__(/*! ../lib/expression/stdlib/list */ \"../../lib/expression/stdlib/list.js\"));            \n        });\n\n        it(\"should load the `http` module\", async () => {\n            var ctx = createContext();\n            var http = await evaluate(\"require 'http'\", ctx);\n            expect(http).to.equal(__webpack_require__(/*! ../lib/expression/stdlib/http */ \"../../lib/expression/stdlib/http.js\"));            \n        });\n    });\n    \n    \n    // LOGIC OPERATORS\n    \n    describe(\"X | Y\", () => {\n    \n        it(\"should return X if `bool X` is true\", async () => {\n            var ctx = createContext({T:true, F:false});\n    \n            // true or true\n            expect(await evaluate(\"T | T\", ctx)).to.equal(true);\n            expect(await evaluate(\"T | 10\", ctx)).to.equal(true);\n            expect(await evaluate(\"10 | T\", ctx)).to.equal(10);\n            expect(await evaluate(\"10 | 10\", ctx)).to.equal(10);\n    \n            // true or false\n            expect(await evaluate(\"T | F\", ctx)).to.equal(true);\n            expect(await evaluate(\"T | 0\", ctx)).to.equal(true);\n            expect(await evaluate(\"10 | F\", ctx)).to.equal(10);\n            expect(await evaluate(\"10 | 0\", ctx)).to.equal(10);    \n        })\n    \n        it(\"should return Y if `bool X` is false\", async () => {\n            var ctx = createContext({T:true, F:false});\n    \n            // false or true\n            expect(await evaluate(\"F | T\", ctx)).to.equal(true);\n            expect(await evaluate(\"F | 10\", ctx)).to.equal(10);\n            expect(await evaluate(\"0 | T\", ctx)).to.equal(true);\n            expect(await evaluate(\"0 | 10\", ctx)).to.equal(10);\n    \n            // false or false\n            expect(await evaluate(\"F | F\", ctx)).to.equal(false);\n            expect(await evaluate(\"F | 0\", ctx)).to.equal(0);\n            expect(await evaluate(\"0 | F\", ctx)).to.equal(false);\n            expect(await evaluate(\"0 | 0\", ctx)).to.equal(0);\n        })\n    });\n    \n    describe(\"X & Y\", () => {\n    \n        it(\"should return Y if `bool X` is true\", async () => {\n            var ctx = createContext({T:true, F:false});\n    \n            // true or true\n            expect(await evaluate(\"T & T\", ctx)).to.equal(true);\n            expect(await evaluate(\"T & 10\", ctx)).to.equal(10);\n            expect(await evaluate(\"10 & T\", ctx)).to.equal(true);\n            expect(await evaluate(\"10 & 10\", ctx)).to.equal(10);\n    \n            // true or false\n            expect(await evaluate(\"T & F\", ctx)).to.equal(false);\n            expect(await evaluate(\"T & 0\", ctx)).to.equal(0);\n            expect(await evaluate(\"10 & F\", ctx)).to.equal(false);\n            expect(await evaluate(\"10 & 0\", ctx)).to.equal(0);    \n        })\n    \n        it(\"should return X if `bool X` is false\", async () => {\n            var ctx = createContext({T:true, F:false});\n    \n            // false or true\n            expect(await evaluate(\"F & T\", ctx)).to.equal(false);\n            expect(await evaluate(\"F & 10\", ctx)).to.equal(false);\n            expect(await evaluate(\"0 & T\", ctx)).to.equal(0);\n            expect(await evaluate(\"0 & 10\", ctx)).to.equal(0);\n    \n            // false or false\n            expect(await evaluate(\"F & F\", ctx)).to.equal(false);\n            expect(await evaluate(\"F & 0\", ctx)).to.equal(false);\n            expect(await evaluate(\"0 & F\", ctx)).to.equal(0);\n            expect(await evaluate(\"0 & 0\", ctx)).to.equal(0);\n        })\n    });\n    \n    describe(\"X ? Y\", () => {\n    \n        it(\"should return Y is `bool X` is true\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"T ? [1,2,3]\", ctx)).to.deep.equal([1,2,3]);\n            expect(await evaluate(\"10 ? [1,2,3]\", ctx)).to.deep.equal([1,2,3]);\n        });\n    \n        it(\"should return null if `bool X` is false\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"F ? [1,2,3]\", ctx)).to.be.null;\n            expect(await evaluate(\"0 ? [1,2,3]\", ctx)).to.be.null;\n        });\n    });    \n    \n    describe(\"X ; Y\", () => {\n    \n        it(\"should return X if it is not `null`\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"[1,2,3] ; [3,4,5]\", ctx)).to.deep.equal([1,2,3]);\n        });\n    \n        it(\"should return Y if X is `null`\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"() ; [3,4,5]\", ctx)).to.deep.equal([3,4,5]);\n        });\n    });    \n    \n    \n    // ARITHMETIC OPERATORS\n    \n    describe(\"X + Y\", () => {\n    \n        it(\"should return Y if X is nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() + ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"() + T\", ctx)).to.equal(true);\n            expect(await evaluate(\"() + F\", ctx)).to.equal(false);\n            expect(await evaluate(\"() + 10\", ctx)).to.equal(10);\n            expect(await evaluate(\"() + 'abc'\", ctx)).to.equal(\"abc\");\n            expect(await evaluate(\"() + fn\", ctx)).to.equal(ctx.fn);\n            expect(await evaluate(\"() + ls\", ctx)).to.deep.equal([1,2,3]);\n            expect(await evaluate(\"() + ns\", ctx)).to.deep.equal({a:1,b:2,c:3});\n    \n            var tuple = await evaluate(\"() + (1,2,3)\", ctx);\n            expect(isTuple(tuple)).to.be.true;\n            expect(Array.from(tuple)).to.deep.equal([1,2,3]);\n        });\n    \n        it(\"should return X if Y is nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() + ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"T + ()\", ctx)).to.equal(true);\n            expect(await evaluate(\"F + ()\", ctx)).to.equal(false);\n            expect(await evaluate(\"10 + ()\", ctx)).to.equal(10);\n            expect(await evaluate(\"'abc' + ()\", ctx)).to.equal(\"abc\");\n            expect(await evaluate(\"fn + ()\", ctx)).to.equal(ctx.fn);\n            expect(await evaluate(\"ls + ()\", ctx)).to.deep.equal([1,2,3]);\n            expect(await evaluate(\"ns + ()\", ctx)).to.deep.equal({a:1,b:2,c:3});\n    \n            var tuple = await evaluate(\"(1,2,3) + ()\", ctx);\n            expect(isTuple(tuple)).to.be.true;\n            expect(Array.from(tuple)).to.deep.equal([1,2,3]);\n        });\n    \n        it(\"should return `X||Y` if both X and Y are booleans\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"T + T\", ctx)).to.be.true;\n            expect(await evaluate(\"T + F\", ctx)).to.be.true;\n            expect(await evaluate(\"F + T\", ctx)).to.be.true;\n            expect(await evaluate(\"F + F\", ctx)).to.be.false;\n        });\n    \n        it(\"should return `X+Y` if both X and Y are numbers\", async () => {\n            var ctx = createContext();\n            expect(await evaluate(\"10 + 1\", ctx)).to.equal(11);\n            expect(await evaluate(\"10 + 0\", ctx)).to.equal(10);\n            expect(await evaluate(\"10 + (-2)\", ctx)).to.equal(8);\n        });\n    \n        it(\"should concatenate X and Y if they are both strings\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"'abc' + 'def'\", ctx)).to.equal(\"abcdef\");\n            expect(await evaluate(\"'abc' + ''\", ctx)).to.equal(\"abc\");\n            expect(await evaluate(\"'' + 'def'\", ctx)).to.equal(\"def\");\n        });\n    \n        it(\"should concatenate X and Y if they are both lists\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"[1,2,3] + [4,5,6]\", ctx)).to.deep.equal([1,2,3,4,5,6]);\n            expect(await evaluate(\"[1,2,3] + []\", ctx)).to.deep.equal([1,2,3]);\n            expect(await evaluate(\"[] + [4,5,6]\", ctx)).to.deep.equal([4,5,6]);\n        });\n    \n        it(\"should merge X and Y if they are both namespaces\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"{a=1,b=2} + {b=20,c=30}\", ctx)).to.deep.equal({a:1,b:20,c:30});\n            expect(await evaluate(\"{a=1,b=2} + {}\", ctx)).to.deep.equal({a:1,b:2});\n            expect(await evaluate(\"{} + {b=20,c=30}\", ctx)).to.deep.equal({b:20,c:30});\n        });\n    \n        it(\"should throw a runtime error for all the other singleton types\", async () => {\n            var ctx = createContext({T:true, F:false});\n            var expectSumError = (expression, XType, YType) => expectException(() => evaluate(expression,ctx), `Sum operation not defined between ${XType} and ${YType}`);\n    \n            var LTYPE = \"Boolean\"; ctx.L = true; \n            await expectSumError(\"L + 1\"       , LTYPE, \"Number\");\n            await expectSumError(\"L + 'abc'\"   , LTYPE, \"String\");\n            await expectSumError(\"L + [1,2,3]\" , LTYPE, \"List\");\n            await expectSumError(\"L + {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSumError(\"L + (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Boolean\"; ctx.L = false;\n            await expectSumError(\"L + 1\"       , LTYPE, \"Number\");\n            await expectSumError(\"L + 'abc'\"   , LTYPE, \"String\");\n            await expectSumError(\"L + [1,2,3]\" , LTYPE, \"List\");\n            await expectSumError(\"L + {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSumError(\"L + (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Number\"; ctx.L = 10;\n            await expectSumError(\"L + T\"       , LTYPE, \"Boolean\");\n            await expectSumError(\"L + F\"       , LTYPE, \"Boolean\");\n            await expectSumError(\"L + 'abc'\"   , LTYPE, \"String\");\n            await expectSumError(\"L + [1,2,3]\" , LTYPE, \"List\");\n            await expectSumError(\"L + {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSumError(\"L + (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"String\"; ctx.L = \"abc\";\n            await expectSumError(\"L + T\"       , LTYPE, \"Boolean\");\n            await expectSumError(\"L + F\"       , LTYPE, \"Boolean\");\n            await expectSumError(\"L + 1\"       , LTYPE, \"Number\");\n            await expectSumError(\"L + [1,2,3]\" , LTYPE, \"List\");\n            await expectSumError(\"L + {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSumError(\"L + (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"List\"; ctx.L = [1,2,3];\n            await expectSumError(\"L + T\"       , LTYPE, \"Boolean\");\n            await expectSumError(\"L + F\"       , LTYPE, \"Boolean\");\n            await expectSumError(\"L + 1\"       , LTYPE, \"Number\");\n            await expectSumError(\"L + 'abc'\"   , LTYPE, \"String\");\n            await expectSumError(\"L + {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSumError(\"L + (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Namespace\"; ctx.L = {a:1,b:2};\n            await expectSumError(\"L + T\"       , LTYPE, \"Boolean\");\n            await expectSumError(\"L + F\"       , LTYPE, \"Boolean\");\n            await expectSumError(\"L + 1\"       , LTYPE, \"Number\");\n            await expectSumError(\"L + 'abc'\"   , LTYPE, \"String\");\n            await expectSumError(\"L + [1,2,3]\" , LTYPE, \"List\");\n            await expectSumError(\"L + (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Function\"; ctx.L = x=>x;\n            await expectSumError(\"L + T\"       , LTYPE, \"Boolean\");\n            await expectSumError(\"L + F\"       , LTYPE, \"Boolean\");\n            await expectSumError(\"L + 1\"       , LTYPE, \"Number\");\n            await expectSumError(\"L + 'abc'\"   , LTYPE, \"String\");\n            await expectSumError(\"L + [1,2,3]\" , LTYPE, \"List\");\n            await expectSumError(\"L + {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSumError(\"L + (x->x)\"  , LTYPE, \"Function\");\n        });\n    \n        it(\"should return (x1+y1, x2+y2, ...) if X and/or Y is a tuple\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(Array.from(await evaluate(\"(T, 1, 'a', [1], {a=1}) + (F, 2, 'b', [2], {b=2})\", ctx))).to.deep.equal([true, 3, \"ab\", [1,2], {a:1,b:2}])\n            expect(Array.from(await evaluate(\"(T, 1, 'a', [1], {a=1}) + (F, 2, 'b')\", ctx))).to.deep.equal([true, 3, \"ab\", [1], {a:1}])\n            expect(Array.from(await evaluate(\"(T, 1, 'a') + (F, 2, 'b', [2], {b=2})\", ctx))).to.deep.equal([true, 3, \"ab\", [2], {b:2}])\n            expect(Array.from(await evaluate(\"10 + (1, 2, 3)\", ctx))).to.deep.equal([11, 2, 3])\n            expect(Array.from(await evaluate(\"(1, 2, 3) + 10\", ctx))).to.deep.equal([11, 2, 3])\n        });\n    });  \n    \n    describe(\"X - Y\", () => {\n    \n        it(\"should return Nothing if X is nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() - ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"() - T\", ctx)).to.equal(null);\n            expect(await evaluate(\"() - F\", ctx)).to.equal(null);\n            expect(await evaluate(\"() - 10\", ctx)).to.equal(null);\n            expect(await evaluate(\"() - 'abc'\", ctx)).to.equal(null);\n            expect(await evaluate(\"() - fn\", ctx)).to.equal(null);\n            expect(await evaluate(\"() - ls\", ctx)).to.equal(null);\n            expect(await evaluate(\"() - ns\", ctx)).to.equal(null);\n            expect(await evaluate(\"() - (1,2,3)\", ctx)).to.equal(null);\n        });\n    \n        it(\"should return Y if X is nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() - ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"T - ()\", ctx)).to.equal(true);\n            expect(await evaluate(\"F - ()\", ctx)).to.equal(false);\n            expect(await evaluate(\"10 - ()\", ctx)).to.equal(10);\n            expect(await evaluate(\"'abc' - ()\", ctx)).to.equal(\"abc\");\n            expect(await evaluate(\"fn - ()\", ctx)).to.equal(ctx.fn);\n            expect(await evaluate(\"ls - ()\", ctx)).to.deep.equal(ctx.ls);\n            expect(await evaluate(\"ns - ()\", ctx)).to.deep.equal(ctx.ns);\n            expect(Array.from(await evaluate(\"(1,2,3) - ()\", ctx))).to.deep.equal([1,2,3]);\n        });\n    \n        it(\"should return `X-Y` if both X and Y are numbers\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"10 - 1\", ctx)).to.equal(9);\n            expect(await evaluate(\"20 - 0\", ctx)).to.equal(20);\n            expect(await evaluate(\"10 - (-7)\", ctx)).to.equal(17);\n        });\n    \n        it(\"should throw a runtime error for all the other singleton types\", async () => {\n            var ctx = createContext({T:true, F:false});\n            var expectSubError = (expression, XType, YType) => expectException(() => evaluate(expression,ctx), `Subtraction operation not defined between ${XType} and ${YType}`);\n    \n            var LTYPE = \"Boolean\"; ctx.L = true;\n            await expectSubError(\"L - 10\"      , LTYPE, \"Number\");\n            await expectSubError(\"L - 'abc'\"   , LTYPE, \"String\");\n            await expectSubError(\"L - [1,2,3]\" , LTYPE, \"List\");\n            await expectSubError(\"L - {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSubError(\"L - (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Boolean\"; ctx.L = false;\n            await expectSubError(\"L - 10\"      , LTYPE, \"Number\");\n            await expectSubError(\"L - 'abc'\"   , LTYPE, \"String\");\n            await expectSubError(\"L - [1,2,3]\" , LTYPE, \"List\");\n            await expectSubError(\"L - {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSubError(\"L - (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Number\"; ctx.L = 10;\n            await expectSubError(\"L - T\"       , LTYPE, \"Boolean\");\n            await expectSubError(\"L - F\"       , LTYPE, \"Boolean\");\n            await expectSubError(\"L - 'abc'\"   , LTYPE, \"String\");\n            await expectSubError(\"L - [1,2,3]\" , LTYPE, \"List\");\n            await expectSubError(\"L - {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSubError(\"L - (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"String\"; ctx.L = \"abc\";\n            await expectSubError(\"L - T\"       , LTYPE, \"Boolean\");\n            await expectSubError(\"L - F\"       , LTYPE, \"Boolean\");\n            await expectSubError(\"L - 1\"       , LTYPE, \"Number\");\n            await expectSubError(\"L - 'abc'\"   , LTYPE, \"String\");\n            await expectSubError(\"L - [1,2,3]\" , LTYPE, \"List\");\n            await expectSubError(\"L - {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSubError(\"L - (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"List\"; ctx.L = [1,2,3];\n            await expectSubError(\"L - T\"       , LTYPE, \"Boolean\");\n            await expectSubError(\"L - F\"       , LTYPE, \"Boolean\");\n            await expectSubError(\"L - 1\"       , LTYPE, \"Number\");\n            await expectSubError(\"L - 'abc'\"   , LTYPE, \"String\");\n            await expectSubError(\"L - [1,2,3]\" , LTYPE, \"List\");\n            await expectSubError(\"L - {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSubError(\"L - (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Namespace\"; ctx.L = {a:1,b:2};\n            await expectSubError(\"L - T\"       , LTYPE, \"Boolean\");\n            await expectSubError(\"L - F\"       , LTYPE, \"Boolean\");\n            await expectSubError(\"L - 1\"       , LTYPE, \"Number\");\n            await expectSubError(\"L - 'abc'\"   , LTYPE, \"String\");\n            await expectSubError(\"L - [1,2,3]\" , LTYPE, \"List\");\n            await expectSubError(\"L - {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSubError(\"L - (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Function\"; ctx.L = x=>x;\n            await expectSubError(\"L - T\"       , LTYPE, \"Boolean\");\n            await expectSubError(\"L - F\"       , LTYPE, \"Boolean\");\n            await expectSubError(\"L - 1\"       , LTYPE, \"Number\");\n            await expectSubError(\"L - 'abc'\"   , LTYPE, \"String\");\n            await expectSubError(\"L - [1,2,3]\" , LTYPE, \"List\");\n            await expectSubError(\"L - {a=1}\"   , LTYPE, \"Namespace\");\n            await expectSubError(\"L - (x->x)\"  , LTYPE, \"Function\");\n        });\n    \n        it(\"should return (x1-y1, x2-y2, ...) if X and/or Y is a tuple\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(Array.from(await evaluate(\"(10,20,30) - (1,2,3)\", ctx))).to.deep.equal([9,18,27]);\n            expect(Array.from(await evaluate(\"(10,20,30) - (1,2)\", ctx))).to.deep.equal([9,18,30]);\n            expect(Array.from(await evaluate(\"(10,20) - (1,2,3)\", ctx))).to.deep.equal([9,18]);\n            expect(Array.from(await evaluate(\"(10,20,30) - 1\", ctx))).to.deep.equal([9,20,30]);\n            expect(await evaluate(\"10 - (1,2,3)\", ctx)).to.equal(9);\n        });\n    });      \n    \n    describe(\"X * Y\", () => {\n    \n        it(\"should return () if either X or Y is nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n    \n            expect(await evaluate(\"() * ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"() * T\", ctx)).to.equal(null);\n            expect(await evaluate(\"() * F\", ctx)).to.equal(null);\n            expect(await evaluate(\"() * 10\", ctx)).to.equal(null);\n            expect(await evaluate(\"() * 'abc'\", ctx)).to.equal(null);\n            expect(await evaluate(\"() * fn\", ctx)).to.equal(null);\n            expect(await evaluate(\"() * ls\", ctx)).to.equal(null);\n            expect(await evaluate(\"() * ns\", ctx)).to.equal(null);\n            expect(await evaluate(\"() * (1,2,3)\", ctx)).to.equal(null);\n    \n            expect(await evaluate(\"() * ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"T * ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"F * ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"10 * ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"'abc' * ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"fn * ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"ls * ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"ns * ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"(1,2,3) * ()\", ctx)).to.equal(null);\n        });\n    \n        it(\"should return `X&&Y` if both X and Y are booleans\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"T * T\", ctx)).to.equal(true);\n            expect(await evaluate(\"T * F\", ctx)).to.equal(false);\n            expect(await evaluate(\"F * T\", ctx)).to.equal(false);\n            expect(await evaluate(\"F * F\", ctx)).to.equal(false);\n        });\n    \n        it(\"should return `X*Y` if both X and Y are numbers\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"10 * 2\", ctx)).to.equal(20);\n            expect(await evaluate(\"10 * 0\", ctx)).to.equal(0);\n            expect(await evaluate(\"10 * (-2)\", ctx)).to.equal(-20);\n        });\n    \n        it(\"should concatenate X times Y if X is a number and Y is a string\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"3 * 'Abc'\", ctx)).to.equal(\"AbcAbcAbc\");\n            expect(await evaluate(\"3.1 * 'Abc'\", ctx)).to.equal(\"AbcAbcAbc\");\n            expect(await evaluate(\"3.9 * 'Abc'\", ctx)).to.equal(\"AbcAbcAbc\");\n            expect(await evaluate(\"0 * 'Abc'\", ctx)).to.equal(\"\");\n            expect(await evaluate(\"-2 * 'Abc'\", ctx)).to.equal(\"\");\n        });\n    \n        it(\"should concatenate Y times X if Y is a number and X is a string\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"'Abc' * 3\", ctx)).to.equal(\"AbcAbcAbc\");\n            expect(await evaluate(\"'Abc' * 3.1\", ctx)).to.equal(\"AbcAbcAbc\");\n            expect(await evaluate(\"'Abc' * 3.9\", ctx)).to.equal(\"AbcAbcAbc\");\n            expect(await evaluate(\"'Abc' * 0\", ctx)).to.equal(\"\");\n            expect(await evaluate(\"'Abc' * (-2)\", ctx)).to.equal(\"\");\n        });\n    \n        it(\"should concatenate X times Y if X is a number and Y is a list\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"3 * [1,2,3]\", ctx)).to.deep.equal([1,2,3,1,2,3,1,2,3]);\n            expect(await evaluate(\"3.1 * [1,2,3]\", ctx)).to.deep.equal([1,2,3,1,2,3,1,2,3]);\n            expect(await evaluate(\"3.9 * [1,2,3]\", ctx)).to.deep.equal([1,2,3,1,2,3,1,2,3]);\n            expect(await evaluate(\"0 * [1,2,3]\", ctx)).to.deep.equal([]);\n            expect(await evaluate(\"-2 * [1,2,3]\", ctx)).to.deep.equal([]);\n        });\n    \n        it(\"should concatenate Y times X if Y is a number and X is a list\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"[1,2,3] * 3\", ctx)).to.deep.equal([1,2,3,1,2,3,1,2,3]);\n            expect(await evaluate(\"[1,2,3] * 3.1\", ctx)).to.deep.equal([1,2,3,1,2,3,1,2,3]);\n            expect(await evaluate(\"[1,2,3] * 3.9\", ctx)).to.deep.equal([1,2,3,1,2,3,1,2,3]);\n            expect(await evaluate(\"[1,2,3] * 0\", ctx)).to.deep.equal([]);\n            expect(await evaluate(\"[1,2,3] * (-2)\", ctx)).to.deep.equal([]);\n        });\n    \n        it(\"should throw a runtime error for all the other singleton types\", async () => {\n            var ctx = createContext({T:true, F:false});\n            var expectMulError = (expression, XType, YType) => expectException(() => evaluate(expression,ctx), `Product operation not defined between ${XType} and ${YType}`);\n    \n            var LTYPE = \"Boolean\"; ctx.L = true; \n            await expectMulError(\"L * 10\"      , LTYPE, \"Number\");\n            await expectMulError(\"L * {a=1}\"   , LTYPE, \"Namespace\");\n            await expectMulError(\"L * (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Boolean\"; ctx.L = false; \n            await expectMulError(\"L * 10\"      , LTYPE, \"Number\");\n            await expectMulError(\"L * {a=1}\"   , LTYPE, \"Namespace\");\n            await expectMulError(\"L * (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Number\"; ctx.L = 10;\n            await expectMulError(\"L * T\"       , LTYPE, \"Boolean\");\n            await expectMulError(\"L * F\"       , LTYPE, \"Boolean\");\n            await expectMulError(\"L * {a=1}\"   , LTYPE, \"Namespace\");\n            await expectMulError(\"L * (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"String\"; ctx.L = \"abc\";\n            await expectMulError(\"L * T\"       , LTYPE, \"Boolean\");\n            await expectMulError(\"L * F\"       , LTYPE, \"Boolean\");\n            await expectMulError(\"L * 'def'\"   , LTYPE, \"String\");\n            await expectMulError(\"L * [1,2,3]\" , LTYPE, \"List\");\n            await expectMulError(\"L * {a=1}\"   , LTYPE, \"Namespace\");\n            await expectMulError(\"L * (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"List\"; ctx.L = [1,2,3];\n            await expectMulError(\"L * T\"       , LTYPE, \"Boolean\");\n            await expectMulError(\"L * F\"       , LTYPE, \"Boolean\");\n            await expectMulError(\"L * 'abc'\"   , LTYPE, \"String\");\n            await expectMulError(\"L * [4,5]\"   , LTYPE, \"List\");\n            await expectMulError(\"L * {a=1}\"   , LTYPE, \"Namespace\");\n            await expectMulError(\"L * (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Namespace\"; ctx.L = {a:1,b:2};\n            await expectMulError(\"L * T\"       , LTYPE, \"Boolean\");\n            await expectMulError(\"L * F\"       , LTYPE, \"Boolean\");\n            await expectMulError(\"L * 1\"       , LTYPE, \"Number\");\n            await expectMulError(\"L * 'abc'\"   , LTYPE, \"String\");\n            await expectMulError(\"L * [1,2,3]\" , LTYPE, \"List\");\n            await expectMulError(\"L * {a=1}\"   , LTYPE, \"Namespace\");\n            await expectMulError(\"L * (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Function\"; ctx.L = x=>x;\n            await expectMulError(\"L * T\"       , LTYPE, \"Boolean\");\n            await expectMulError(\"L * F\"       , LTYPE, \"Boolean\");\n            await expectMulError(\"L * 1\"       , LTYPE, \"Number\");\n            await expectMulError(\"L * 'abc'\"   , LTYPE, \"String\");\n            await expectMulError(\"L * [1,2,3]\" , LTYPE, \"List\");\n            await expectMulError(\"L * {a=1}\"   , LTYPE, \"Namespace\");\n            await expectMulError(\"L * (x->x)\"  , LTYPE, \"Function\");\n        });\n    \n        it(\"should return (x1*y1, x2*y2, ...) if X and/or Y is a tuple\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(Array.from(await evaluate(\"(T, 3, 'a', [1]) * (F, 2, 2, 2)\",ctx))).to.deep.equal([false, 6, \"aa\", [1,1]]);\n            expect(Array.from(await evaluate(\"(10,20,30) * (2,3,4)\",ctx))).to.deep.equal([20,60,120]);\n            expect(Array.from(await evaluate(\"(10,20,30) * (2,3)\",ctx))).to.deep.equal([20,60]);\n            expect(Array.from(await evaluate(\"(10,20) * (2,3,4)\",ctx))).to.deep.equal([20,60]);\n            expect(await evaluate(\"10 * (2,3,4)\",ctx)).to.equal(20);\n            expect(await evaluate(\"(10,20,30) * 2\",ctx)).to.equal(20);\n        });\n    });\n    \n    describe(\"X / Y\", () => {\n    \n        it(\"should return nothing if X is nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() / ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"() / T\", ctx)).to.equal(null);\n            expect(await evaluate(\"() / F\", ctx)).to.equal(null);\n            expect(await evaluate(\"() / 10\", ctx)).to.equal(null);\n            expect(await evaluate(\"() / 'abc'\", ctx)).to.equal(null);\n            expect(await evaluate(\"() / fn\", ctx)).to.equal(null);\n            expect(await evaluate(\"() / ls\", ctx)).to.equal(null);\n            expect(await evaluate(\"() / ns\", ctx)).to.equal(null);\n        });\n    \n        it(\"should return `X/Y` if both X and Y are numbers\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"10 / 2\", ctx)).to.equal(5);\n            expect(await evaluate(\"20 / 0\", ctx)).to.equal(Infinity);\n            expect(await evaluate(\"10 / (-2)\", ctx)).to.equal(-5);\n        });\n    \n        it(\"should throw a runtime error for all the other singleton types\", async () => {\n            var ctx = createContext({T:true, F:false});\n            var expectDivError = (expression, XType, YType) => expectException(() => evaluate(expression,ctx), `Division operation not defined between ${XType} and ${YType}`);\n    \n            var LTYPE = \"Boolean\"; ctx.L = true;\n            await expectDivError(\"L / ()\"      , LTYPE, \"Nothing\");\n            await expectDivError(\"L / 10\"      , LTYPE, \"Number\");\n            await expectDivError(\"L / 'abc'\"   , LTYPE, \"String\");\n            await expectDivError(\"L / [1,2,3]\" , LTYPE, \"List\");\n            await expectDivError(\"L / {a=1}\"   , LTYPE, \"Namespace\");\n            await expectDivError(\"L / (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Boolean\"; ctx.L = false;\n            await expectDivError(\"L / ()\"      , LTYPE, \"Nothing\");\n            await expectDivError(\"L / 10\"      , LTYPE, \"Number\");\n            await expectDivError(\"L / 'abc'\"   , LTYPE, \"String\");\n            await expectDivError(\"L / [1,2,3]\" , LTYPE, \"List\");\n            await expectDivError(\"L / {a=1}\"   , LTYPE, \"Namespace\");\n            await expectDivError(\"L / (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Number\"; ctx.L = 10;\n            await expectDivError(\"L / ()\"      , LTYPE, \"Nothing\");\n            await expectDivError(\"L / T\"       , LTYPE, \"Boolean\");\n            await expectDivError(\"L / F\"       , LTYPE, \"Boolean\");\n            await expectDivError(\"L / 'abc'\"   , LTYPE, \"String\");\n            await expectDivError(\"L / [1,2,3]\" , LTYPE, \"List\");\n            await expectDivError(\"L / {a=1}\"   , LTYPE, \"Namespace\");\n            await expectDivError(\"L / (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"String\"; ctx.L = \"abc\";\n            await expectDivError(\"L / ()\"      , LTYPE, \"Nothing\");\n            await expectDivError(\"L / T\"       , LTYPE, \"Boolean\");\n            await expectDivError(\"L / F\"       , LTYPE, \"Boolean\");\n            await expectDivError(\"L / 1\"       , LTYPE, \"Number\");\n            await expectDivError(\"L / 'abc'\"   , LTYPE, \"String\");\n            await expectDivError(\"L / [1,2,3]\" , LTYPE, \"List\");\n            await expectDivError(\"L / {a=1}\"   , LTYPE, \"Namespace\");\n            await expectDivError(\"L / (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"List\"; ctx.L = [1,2,3];\n            await expectDivError(\"L / ()\"      , LTYPE, \"Nothing\");\n            await expectDivError(\"L / T\"       , LTYPE, \"Boolean\");\n            await expectDivError(\"L / F\"       , LTYPE, \"Boolean\");\n            await expectDivError(\"L / 1\"       , LTYPE, \"Number\");\n            await expectDivError(\"L / 'abc'\"   , LTYPE, \"String\");\n            await expectDivError(\"L / [1,2,3]\" , LTYPE, \"List\");\n            await expectDivError(\"L / {a=1}\"   , LTYPE, \"Namespace\");\n            await expectDivError(\"L / (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Namespace\"; ctx.L = {a:1,b:2};\n            await expectDivError(\"L / ()\"      , LTYPE, \"Nothing\");\n            await expectDivError(\"L / T\"       , LTYPE, \"Boolean\");\n            await expectDivError(\"L / F\"       , LTYPE, \"Boolean\");\n            await expectDivError(\"L / 1\"       , LTYPE, \"Number\");\n            await expectDivError(\"L / 'abc'\"   , LTYPE, \"String\");\n            await expectDivError(\"L / [1,2,3]\" , LTYPE, \"List\");\n            await expectDivError(\"L / {a=1}\"   , LTYPE, \"Namespace\");\n            await expectDivError(\"L / (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Function\"; ctx.L = x=>x;\n            await expectDivError(\"L / ()\"      , LTYPE, \"Nothing\");\n            await expectDivError(\"L / T\"       , LTYPE, \"Boolean\");\n            await expectDivError(\"L / F\"       , LTYPE, \"Boolean\");\n            await expectDivError(\"L / 1\"       , LTYPE, \"Number\");\n            await expectDivError(\"L / 'abc'\"   , LTYPE, \"String\");\n            await expectDivError(\"L / [1,2,3]\" , LTYPE, \"List\");\n            await expectDivError(\"L / {a=1}\"   , LTYPE, \"Namespace\");\n            await expectDivError(\"L / (x->x)\"  , LTYPE, \"Function\");\n        });\n    \n        it(\"should return (x1/y1, x2/y2, ...) if X and/or Y is a tuple\", async () => {\n            var ctx = createContext({T:true, F:false});\n            var expectDivError = (expression, XType, YType) => expectException(() => evaluate(expression,ctx), `Division operation not defined between ${XType} and ${YType}`);\n            expect(Array.from(await evaluate(\"(10,20,30) / (2,5,3)\",ctx))).to.deep.equal([5,4,10]);\n            expect(Array.from(await evaluate(\"(10,20) / (2,5,3)\",ctx))).to.deep.equal([5,4]);\n            expect(await evaluate(\"10 / (2,5,3)\",ctx)).to.equal(5);\n            expect(await evaluate(\"() / (2,4,3)\",ctx)).to.equal(null);\n            await expectDivError(\"(10,20,30) / (2,4)\", \"Number\",\"Nothing\");\n            await expectDivError(\"(10,20,30) / 2\", \"Number\",\"Nothing\");\n        });\n    });\n    \n    describe(\"X % Y\", () => {\n    \n        it(\"should return Y if X is nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() % ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"() % T\", ctx)).to.equal(true);\n            expect(await evaluate(\"() % F\", ctx)).to.equal(false);\n            expect(await evaluate(\"() % 10\", ctx)).to.equal(10);\n            expect(await evaluate(\"() % 'abc'\", ctx)).to.equal('abc');\n            expect(await evaluate(\"() % fn\", ctx)).to.equal(ctx.fn);\n            expect(await evaluate(\"() % ls\", ctx)).to.equal(ctx.ls);\n            expect(await evaluate(\"() % ns\", ctx)).to.equal(ctx.ns);\n        });\n    \n        it(\"should return `X/Y` if both X and Y are numbers\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"10 % 4\", ctx)).to.equal(2);\n            expect(await evaluate(\"10 % (-4)\", ctx)).to.equal(2);\n        });\n    \n        it(\"should throw a runtime error for all the other singleton types\", async () => {\n            var ctx = createContext({T:true, F:false});\n            var expectModError = (expression, XType, YType) => expectException(() => evaluate(expression,ctx), `Modulo operation not defined between ${XType} and ${YType}`);\n    \n            var LTYPE = \"Boolean\"; ctx.L = true;\n            await expectModError(\"L % ()\"      , LTYPE, \"Nothing\");\n            await expectModError(\"L % 10\"      , LTYPE, \"Number\");\n            await expectModError(\"L % 'abc'\"   , LTYPE, \"String\");\n            await expectModError(\"L % [1,2,3]\" , LTYPE, \"List\");\n            await expectModError(\"L % {a=1}\"   , LTYPE, \"Namespace\");\n            await expectModError(\"L % (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Boolean\"; ctx.L = false;\n            await expectModError(\"L % ()\"      , LTYPE, \"Nothing\");\n            await expectModError(\"L % 10\"      , LTYPE, \"Number\");\n            await expectModError(\"L % 'abc'\"   , LTYPE, \"String\");\n            await expectModError(\"L % [1,2,3]\" , LTYPE, \"List\");\n            await expectModError(\"L % {a=1}\"   , LTYPE, \"Namespace\");\n            await expectModError(\"L % (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Number\"; ctx.L = 10;\n            await expectModError(\"L % ()\"      , LTYPE, \"Nothing\");\n            await expectModError(\"L % T\"       , LTYPE, \"Boolean\");\n            await expectModError(\"L % F\"       , LTYPE, \"Boolean\");\n            await expectModError(\"L % 'abc'\"   , LTYPE, \"String\");\n            await expectModError(\"L % [1,2,3]\" , LTYPE, \"List\");\n            await expectModError(\"L % {a=1}\"   , LTYPE, \"Namespace\");\n            await expectModError(\"L % (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"String\"; ctx.L = \"abc\";\n            await expectModError(\"L % ()\"      , LTYPE, \"Nothing\");\n            await expectModError(\"L % T\"       , LTYPE, \"Boolean\");\n            await expectModError(\"L % F\"       , LTYPE, \"Boolean\");\n            await expectModError(\"L % 1\"       , LTYPE, \"Number\");\n            await expectModError(\"L % 'abc'\"   , LTYPE, \"String\");\n            await expectModError(\"L % [1,2,3]\" , LTYPE, \"List\");\n            await expectModError(\"L % {a=1}\"   , LTYPE, \"Namespace\");\n            await expectModError(\"L % (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"List\"; ctx.L = [1,2,3];\n            await expectModError(\"L % ()\"      , LTYPE, \"Nothing\");\n            await expectModError(\"L % T\"       , LTYPE, \"Boolean\");\n            await expectModError(\"L % F\"       , LTYPE, \"Boolean\");\n            await expectModError(\"L % 1\"       , LTYPE, \"Number\");\n            await expectModError(\"L % 'abc'\"   , LTYPE, \"String\");\n            await expectModError(\"L % [1,2,3]\" , LTYPE, \"List\");\n            await expectModError(\"L % {a=1}\"   , LTYPE, \"Namespace\");\n            await expectModError(\"L % (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Namespace\"; ctx.L = {a:1,b:2};\n            await expectModError(\"L % ()\"      , LTYPE, \"Nothing\");\n            await expectModError(\"L % T\"       , LTYPE, \"Boolean\");\n            await expectModError(\"L % F\"       , LTYPE, \"Boolean\");\n            await expectModError(\"L % 1\"       , LTYPE, \"Number\");\n            await expectModError(\"L % 'abc'\"   , LTYPE, \"String\");\n            await expectModError(\"L % [1,2,3]\" , LTYPE, \"List\");\n            await expectModError(\"L % {a=1}\"   , LTYPE, \"Namespace\");\n            await expectModError(\"L % (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Function\"; ctx.L = x=>x;\n            await expectModError(\"L % ()\"      , LTYPE, \"Nothing\");\n            await expectModError(\"L % T\"       , LTYPE, \"Boolean\");\n            await expectModError(\"L % F\"       , LTYPE, \"Boolean\");\n            await expectModError(\"L % 1\"       , LTYPE, \"Number\");\n            await expectModError(\"L % 'abc'\"   , LTYPE, \"String\");\n            await expectModError(\"L % [1,2,3]\" , LTYPE, \"List\");\n            await expectModError(\"L % {a=1}\"   , LTYPE, \"Namespace\");\n            await expectModError(\"L % (x->x)\"  , LTYPE, \"Function\");\n        });\n    \n        it(\"should return (x1/y1, x2/y2, ...) if X and/or Y is a tuple\", async () => {\n            var ctx = createContext({T:true, F:false});\n            var expectModError = (expression, XType, YType) => expectException(() => evaluate(expression,ctx), `Modulo operation not defined between ${XType} and ${YType}`);\n            expect(Array.from(await evaluate(\"(10,20,30) % (4,7,8)\",ctx))).to.deep.equal([2,6,6]);\n            expect(Array.from(await evaluate(\"(10,20) % (4,7,8)\",ctx))).to.deep.equal([2,6,8]);\n            expect(Array.from(await evaluate(\"10 % (4,7,8)\",ctx))).to.deep.equal([2,7,8]);\n            expect(Array.from(await evaluate(\"() % (4,7,8)\",ctx))).to.deep.equal([4,7,8]);\n            await expectModError(\"(10,20,30) % (2,4)\", \"Number\",\"Nothing\");\n            await expectModError(\"(10,20,30) % 2\", \"Number\",\"Nothing\");\n        });\n    });\n    \n    describe(\"X ^ Y\", () => {\n    \n        it(\"should return nothing if X is nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() ^ ()\", ctx)).to.equal(null);\n            expect(await evaluate(\"() ^ T\", ctx)).to.equal(null);\n            expect(await evaluate(\"() ^ F\", ctx)).to.equal(null);\n            expect(await evaluate(\"() ^ 10\", ctx)).to.equal(null);\n            expect(await evaluate(\"() ^ 'abc'\", ctx)).to.equal(null);\n            expect(await evaluate(\"() ^ fn\", ctx)).to.equal(null);\n            expect(await evaluate(\"() ^ ls\", ctx)).to.equal(null);\n            expect(await evaluate(\"() ^ ns\", ctx)).to.equal(null);\n        });\n    \n        it(\"should return `X**Y` if both X and Y are numbers\", async () => {\n            var ctx = createContext({T:true, F:false});\n            expect(await evaluate(\"10 ^ 2\", ctx)).to.equal(100);\n            expect(await evaluate(\"20 ^ 0\", ctx)).to.equal(1);\n            expect(await evaluate(\"10 ^ (-2)\", ctx)).to.equal(0.01);\n        });\n    \n        it(\"should throw a runtime error for all the other singleton types\", async () => {\n            var ctx = createContext({T:true, F:false});\n            var expectPowError = (expression, XType, YType) => expectException(() => evaluate(expression,ctx), `Exponentiation operation not defined between ${XType} and ${YType}`);\n    \n            var LTYPE = \"Boolean\"; ctx.L = true;\n            await expectPowError(\"L ^ ()\"      , LTYPE, \"Nothing\");\n            await expectPowError(\"L ^ 10\"      , LTYPE, \"Number\");\n            await expectPowError(\"L ^ 'abc'\"   , LTYPE, \"String\");\n            await expectPowError(\"L ^ [1,2,3]\" , LTYPE, \"List\");\n            await expectPowError(\"L ^ {a=1}\"   , LTYPE, \"Namespace\");\n            await expectPowError(\"L ^ (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Boolean\"; ctx.L = false;\n            await expectPowError(\"L ^ ()\"      , LTYPE, \"Nothing\");\n            await expectPowError(\"L ^ 10\"      , LTYPE, \"Number\");\n            await expectPowError(\"L ^ 'abc'\"   , LTYPE, \"String\");\n            await expectPowError(\"L ^ [1,2,3]\" , LTYPE, \"List\");\n            await expectPowError(\"L ^ {a=1}\"   , LTYPE, \"Namespace\");\n            await expectPowError(\"L ^ (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Number\"; ctx.L = 10;\n            await expectPowError(\"L ^ ()\"      , LTYPE, \"Nothing\");\n            await expectPowError(\"L ^ T\"       , LTYPE, \"Boolean\");\n            await expectPowError(\"L ^ F\"       , LTYPE, \"Boolean\");\n            await expectPowError(\"L ^ 'abc'\"   , LTYPE, \"String\");\n            await expectPowError(\"L ^ [1,2,3]\" , LTYPE, \"List\");\n            await expectPowError(\"L ^ {a=1}\"   , LTYPE, \"Namespace\");\n            await expectPowError(\"L ^ (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"String\"; ctx.L = \"abc\";\n            await expectPowError(\"L ^ ()\"      , LTYPE, \"Nothing\");\n            await expectPowError(\"L ^ T\"       , LTYPE, \"Boolean\");\n            await expectPowError(\"L ^ F\"       , LTYPE, \"Boolean\");\n            await expectPowError(\"L ^ 1\"       , LTYPE, \"Number\");\n            await expectPowError(\"L ^ 'abc'\"   , LTYPE, \"String\");\n            await expectPowError(\"L ^ [1,2,3]\" , LTYPE, \"List\");\n            await expectPowError(\"L ^ {a=1}\"   , LTYPE, \"Namespace\");\n            await expectPowError(\"L ^ (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"List\"; ctx.L = [1,2,3];\n            await expectPowError(\"L ^ ()\"      , LTYPE, \"Nothing\");\n            await expectPowError(\"L ^ T\"       , LTYPE, \"Boolean\");\n            await expectPowError(\"L ^ F\"       , LTYPE, \"Boolean\");\n            await expectPowError(\"L ^ 1\"       , LTYPE, \"Number\");\n            await expectPowError(\"L ^ 'abc'\"   , LTYPE, \"String\");\n            await expectPowError(\"L ^ [1,2,3]\" , LTYPE, \"List\");\n            await expectPowError(\"L ^ {a=1}\"   , LTYPE, \"Namespace\");\n            await expectPowError(\"L ^ (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Namespace\"; ctx.L = {a:1,b:2};\n            await expectPowError(\"L ^ ()\"      , LTYPE, \"Nothing\");\n            await expectPowError(\"L ^ T\"       , LTYPE, \"Boolean\");\n            await expectPowError(\"L ^ F\"       , LTYPE, \"Boolean\");\n            await expectPowError(\"L ^ 1\"       , LTYPE, \"Number\");\n            await expectPowError(\"L ^ 'abc'\"   , LTYPE, \"String\");\n            await expectPowError(\"L ^ [1,2,3]\" , LTYPE, \"List\");\n            await expectPowError(\"L ^ {a=1}\"   , LTYPE, \"Namespace\");\n            await expectPowError(\"L ^ (x->x)\"  , LTYPE, \"Function\");\n    \n            var LTYPE = \"Function\"; ctx.L = x=>x;\n            await expectPowError(\"L ^ ()\"      , LTYPE, \"Nothing\");\n            await expectPowError(\"L ^ T\"       , LTYPE, \"Boolean\");\n            await expectPowError(\"L ^ F\"       , LTYPE, \"Boolean\");\n            await expectPowError(\"L ^ 1\"       , LTYPE, \"Number\");\n            await expectPowError(\"L ^ 'abc'\"   , LTYPE, \"String\");\n            await expectPowError(\"L ^ [1,2,3]\" , LTYPE, \"List\");\n            await expectPowError(\"L ^ {a=1}\"   , LTYPE, \"Namespace\");\n            await expectPowError(\"L ^ (x->x)\"  , LTYPE, \"Function\");\n        });\n    \n        it(\"should return (x1^y1, x2^y2, ...) if X and/or Y is a tuple\", async () => {\n            var ctx = createContext({T:true, F:false});\n            var expectPowError = (expression, XType, YType) => expectException(() => evaluate(expression,ctx), `Exponentiation operation not defined between ${XType} and ${YType}`);\n            expect(Array.from(await evaluate(\"(10,20,30) ^ (2,3,4)\",ctx))).to.deep.equal([10**2,20**3,30**4]);\n            expect(Array.from(await evaluate(\"(10,20) ^ (2,3,4)\",ctx))).to.deep.equal([10**2,20**3]);\n            expect(await evaluate(\"10 ^ (2,3,4)\",ctx)).to.equal(10**2);\n            expect(await evaluate(\"() ^ (2,3,4)\",ctx)).to.equal(null);\n            await expectPowError(\"(10,20,30) ^ (2,4)\", \"Number\",\"Nothing\");\n            await expectPowError(\"(10,20,30) ^ 2\", \"Number\",\"Nothing\");\n        });\n    });        \n    \n    \n    // COMPARISON OPERATORS\n    \n    describe(\"X == Y\", () => {\n    \n        it(\"should return true if both X and Y are nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() == ()\", ctx)).to.equal(true);            \n        });\n    \n        it(\"should return true if X and Y are both true or both false\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"T == T\", ctx)).to.equal(true);            \n            expect(await evaluate(\"F == F\", ctx)).to.equal(true);            \n            expect(await evaluate(\"T == F\", ctx)).to.equal(false);            \n            expect(await evaluate(\"F == T\", ctx)).to.equal(false);            \n        });\n    \n        it(\"should return true if X and Y are the same number\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"3 == 3\", ctx)).to.equal(true);            \n            expect(await evaluate(\"0 == 0\", ctx)).to.equal(true);            \n            expect(await evaluate(\"-3 == -3\", ctx)).to.equal(true);            \n            expect(await evaluate(\"3 == 2\", ctx)).to.equal(false);            \n            expect(await evaluate(\"0 == -4\", ctx)).to.equal(false);            \n        });\n    \n        it(\"should return true if X and Y are the same string\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"'abc' == 'abc'\", ctx)).to.equal(true);            \n            expect(await evaluate(\"'' == ''\", ctx)).to.equal(true);            \n            expect(await evaluate(\"'abc' == 'def'\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"'abc' == ''\", ctx)).to.equal(false);                        \n        });\n    \n        it(\"should return true if X and Y are both lists with equal items\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"[1,2,3] == [1,2,3]\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"[] == []\", ctx)).to.equal(true);            \n            expect(await evaluate(\"[1,2,3] == [4,5,6]\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"[1,2,3] == []\", ctx)).to.equal(false);                        \n        });\n    \n        it(\"should return true if X and Y are both namespace with sname name:value pairs\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"{a=1,b=2} == {a=1,b=2}\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"{} == {}\", ctx)).to.equal(true);            \n            expect(await evaluate(\"{a=1,b=2} == {a=1,c=2}\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"{a=1,b=2} == {a=1,b=3}\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"{a=1,b=2} == {a=1}\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"{a=1,b=2} == {}\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"{a=1} == {a=1,b=2}\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"{} == {a=1,b=2}\", ctx)).to.equal(false);                        \n        });\n    \n        it(\"should return true if X and Y are the same function\", async () => {\n            var ctx = createContext({fn1:x=>2*x, fn2:x=>2*x});\n            expect(await evaluate(\"fn1 == fn1\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"fn1 == fn2\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"(x->2*x) == (x->2*x)\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"(x->2*x) == fn1\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"fn1 == (x->2*x)\", ctx)).to.equal(false);                                    \n        });\n    \n        it(\"should return false if X and Y are of different types\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n    \n            expect(await evaluate(\"() == T\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() == F\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() == 1\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() == 'abc'\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() == ls\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() == ns\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() == fn\", ctx)).to.equal(false);                                    \n    \n            expect(await evaluate(\"T == ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"T == 1\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"T == 'abc'\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"T == ls\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"T == ns\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"T == fn\", ctx)).to.equal(false);                                    \n    \n            expect(await evaluate(\"F == ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"F == 1\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"F == 'abc'\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"F == ls\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"F == ns\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"F == fn\", ctx)).to.equal(false);                                    \n    \n            expect(await evaluate(\"1 == ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"1 == T\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"1 == F\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"1 == 'abc'\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"1 == ls\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"1 == ns\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"1 == fn\", ctx)).to.equal(false);                                    \n    \n            expect(await evaluate(\"'abc' == ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"'abc' == T\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"'abc' == F\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"'abc' == 1\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"'abc' == ls\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"'abc' == ns\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"'abc' == fn\", ctx)).to.equal(false);                                    \n    \n            expect(await evaluate(\"ls == ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ls == T\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ls == F\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ls == 1\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ls == 'abc'\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ls == ns\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ls == fn\", ctx)).to.equal(false);                                    \n    \n            expect(await evaluate(\"ns == ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ns == T\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ns == F\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ns == 1\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ns == 'abc'\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ns == ls\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ns == fn\", ctx)).to.equal(false);                                    \n    \n            expect(await evaluate(\"fn == ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"fn == T\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"fn == F\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"fn == 1\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"fn == 'abc'\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"fn == ls\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"fn == ns\", ctx)).to.equal(false);                                    \n        });\n    \n        it(\"should compare tuples with lexicographical criteria\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"(1,2,3) == (1,2,3)\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"(1,2,3) == (1,2)\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"(1,2) == (1,2,3)\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"1 == (1,2,3)\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"(1,2,3) == 1\", ctx)).to.equal(false);                                    \n        });\n    });\n    \n    describe(\"X != Y\", () => {\n    \n        it(\"should return false if both X and Y are nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() != ()\", ctx)).to.equal(false);            \n        });\n    \n        it(\"should return false if X and Y are both false or both true\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"T != T\", ctx)).to.equal(false);            \n            expect(await evaluate(\"F != F\", ctx)).to.equal(false);            \n            expect(await evaluate(\"T != F\", ctx)).to.equal(true);            \n            expect(await evaluate(\"F != T\", ctx)).to.equal(true);            \n        });\n    \n        it(\"should return false if X and Y are the same number\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"3 != 3\", ctx)).to.equal(false);            \n            expect(await evaluate(\"0 != 0\", ctx)).to.equal(false);            \n            expect(await evaluate(\"-3 != -3\", ctx)).to.equal(false);            \n            expect(await evaluate(\"3 != 2\", ctx)).to.equal(true);            \n            expect(await evaluate(\"0 != -4\", ctx)).to.equal(true);            \n        });\n    \n        it(\"should return false if X and Y are the same string\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"'abc' != 'abc'\", ctx)).to.equal(false);            \n            expect(await evaluate(\"'' != ''\", ctx)).to.equal(false);            \n            expect(await evaluate(\"'abc' != 'def'\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"'abc' != ''\", ctx)).to.equal(true);                        \n        });\n    \n        it(\"should return false if X and Y are both lists with equal items\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"[1,2,3] != [1,2,3]\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"[] != []\", ctx)).to.equal(false);            \n            expect(await evaluate(\"[1,2,3] != [4,5,6]\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"[1,2,3] != []\", ctx)).to.equal(true);                        \n        });\n    \n        it(\"should return false if X and Y are both namespace with sname name:value pairs\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"{a=1,b=2} != {a=1,b=2}\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"{} != {}\", ctx)).to.equal(false);            \n            expect(await evaluate(\"{a=1,b=2} != {a=1,c=2}\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"{a=1,b=2} != {a=1,b=3}\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"{a=1,b=2} != {a=1}\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"{a=1,b=2} != {}\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"{a=1} != {a=1,b=2}\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"{} != {a=1,b=2}\", ctx)).to.equal(true);                        \n        });\n    \n        it(\"should return false if X and Y are the same function\", async () => {\n            var ctx = createContext({fn1:x=>2*x, fn2:x=>2*x});\n            expect(await evaluate(\"fn1 != fn1\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"fn1 != fn2\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"(x->2*x) != (x->2*x)\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"(x->2*x) != fn1\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"fn1 != (x->2*x)\", ctx)).to.equal(true);                                    \n        });\n    \n        it(\"should return true if X and Y are of different types\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n    \n            expect(await evaluate(\"() != T\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() != F\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() != 1\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() != 'abc'\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() != ls\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() != ns\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() != fn\", ctx)).to.equal(true);                                    \n    \n            expect(await evaluate(\"T != ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"T != 1\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"T != 'abc'\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"T != ls\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"T != ns\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"T != fn\", ctx)).to.equal(true);                                    \n    \n            expect(await evaluate(\"F != ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"F != 1\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"F != 'abc'\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"F != ls\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"F != ns\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"F != fn\", ctx)).to.equal(true);                                    \n    \n            expect(await evaluate(\"1 != ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"1 != T\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"1 != F\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"1 != 'abc'\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"1 != ls\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"1 != ns\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"1 != fn\", ctx)).to.equal(true);                                    \n    \n            expect(await evaluate(\"'abc' != ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"'abc' != T\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"'abc' != F\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"'abc' != 1\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"'abc' != ls\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"'abc' != ns\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"'abc' != fn\", ctx)).to.equal(true);                                    \n    \n            expect(await evaluate(\"ls != ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ls != T\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ls != F\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ls != 1\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ls != 'abc'\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ls != ns\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ls != fn\", ctx)).to.equal(true);                                    \n    \n            expect(await evaluate(\"ns != ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ns != T\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ns != F\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ns != 1\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ns != 'abc'\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ns != ls\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ns != fn\", ctx)).to.equal(true);                                    \n    \n            expect(await evaluate(\"fn != ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"fn != T\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"fn != F\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"fn != 1\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"fn != 'abc'\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"fn != ls\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"fn != ns\", ctx)).to.equal(true);                                    \n        });\n    \n        it(\"should compare tuples with lexicographical criteria\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"(1,2,3) != (1,2,3)\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"(1,2,3) != (1,2)\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"(1,2) != (1,2,3)\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"1 != (1,2,3)\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"(1,2,3) != 1\", ctx)).to.equal(true);                                    \n        });\n    });    \n    \n    describe(\"X < Y\", () => {\n    \n        it(\"should return false if both X and Y are nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() < ()\", ctx)).to.equal(false);            \n        });\n    \n        it(\"should return true if X is false and Y is true\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"T < T\", ctx)).to.equal(false);            \n            expect(await evaluate(\"F < F\", ctx)).to.equal(false);            \n            expect(await evaluate(\"T < F\", ctx)).to.equal(false);            \n            expect(await evaluate(\"F < T\", ctx)).to.equal(true);            \n        });\n    \n        it(\"should return true if X is a lower number than Y\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"1 < 2\", ctx)).to.equal(true);            \n            expect(await evaluate(\"0 < 2\", ctx)).to.equal(true);            \n            expect(await evaluate(\"-1 < 2\", ctx)).to.equal(true);            \n            expect(await evaluate(\"2 < 1\", ctx)).to.equal(false);            \n            expect(await evaluate(\"2 < 0\", ctx)).to.equal(false);            \n            expect(await evaluate(\"2 < (-2)\", ctx)).to.equal(false);            \n            expect(await evaluate(\"2 < 2\", ctx)).to.equal(false);            \n        });\n    \n        it(\"should return true if X and Y are both strings and X precedes Y alphabetically\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"'abc' < 'def'\", ctx)).to.equal(true);            \n            expect(await evaluate(\"'abc' < 'abd'\", ctx)).to.equal(true);            \n            expect(await evaluate(\"'ab' < 'abc'\", ctx)).to.equal(true);            \n            expect(await evaluate(\"'' < 'abc'\", ctx)).to.equal(true);            \n            expect(await evaluate(\"'abc' < 'abc'\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"'abd' < 'abc'\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"'abc' < 'ab'\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"'abc' < ''\", ctx)).to.equal(false);                        \n        });\n    \n        it(\"should return true if X and Y are both lists and X precedes Y lexicographically\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"[1,2,3] < [4,5,6]\", ctx)).to.equal(true);            \n            expect(await evaluate(\"[1,2,3] < [1,2,4]\", ctx)).to.equal(true);            \n            expect(await evaluate(\"[1,2] < [1,2,4]\", ctx)).to.equal(true);\n            expect(await evaluate(\"[] < [1,2,3]\", ctx)).to.equal(true);            \n            expect(await evaluate(\"[1,2,3] < [1,2,3]\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"[1,2,4] < [1,2,3]\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"[1,2,4] < [1,2]\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"[1,2,3] < []\", ctx)).to.equal(false);                        \n        });\n    \n        it(\"should return true if X is nothing and Y is not\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() < ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() < T\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() < F\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() < 1\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() < 'abc'\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() < ls\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() < ns\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() < fn\", ctx)).to.equal(true);                                                \n        });\n    \n        it(\"should return false if Y is nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() < ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"T < ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"F < ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"1 < ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"'abc' < ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ls < ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ns < ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"fn < ()\", ctx)).to.equal(false);                                                            \n        });\n    \n        it(\"should throw an exception for any other type combination\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            var expectCmpError = (expression, xType, yType) => expectException(() => evaluate(expression, ctx), `Comparison operation not defined between ${xType} and ${yType}`);\n    \n            var xType='Boolean'; ctx.x = false;\n            await expectCmpError(\"x < 1\",     xType, 'Number');                                    \n            await expectCmpError(\"x < 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x < ls\",    xType, 'List');                                    \n            await expectCmpError(\"x < ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x < fn\",    xType, 'Function');                                                \n    \n            var xType='Boolean'; ctx.x = true;\n            await expectCmpError(\"x < 1\",     xType, 'Number');                                    \n            await expectCmpError(\"x < 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x < ls\",    xType, 'List');                                    \n            await expectCmpError(\"x < ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x < fn\",    xType, 'Function');                                                \n    \n            var xType='Number'; ctx.x = 10;\n            await expectCmpError(\"x < T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x < F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x < 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x < ls\",    xType, 'List');                                    \n            await expectCmpError(\"x < ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x < fn\",    xType, 'Function');                                                \n    \n            var xType='String'; ctx.x = 'abc';\n            await expectCmpError(\"x < T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x < F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x < 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x < ls\",    xType, 'List');                                    \n            await expectCmpError(\"x < ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x < fn\",    xType, 'Function');                                                \n    \n            var xType='List'; ctx.x = [1,2,3];\n            await expectCmpError(\"x < T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x < F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x < 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x < 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x < ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x < fn\",    xType, 'Function');                                                \n    \n            var xType='Namespace'; ctx.x = {a:1,b:2};\n            await expectCmpError(\"x < T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x < F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x < 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x < 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x < ls\",    xType, 'List');                                    \n            await expectCmpError(\"x < ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x < fn\",    xType, 'Function');                                                \n    \n            var xType='Function'; ctx.x = x=>2*x;\n            await expectCmpError(\"x < T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x < F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x < 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x < 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x < ls\",    xType, 'List');                                    \n            await expectCmpError(\"x < ns\",    xType, 'Namespace');                                                \n            await expectCmpError(\"x < fn\",    xType, 'Function');                                                \n        });\n    \n        it(\"should compare tuples with lexicographical criteria\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"(1,2,3) < (4,5,6)\", ctx)).to.equal(true);            \n            expect(await evaluate(\"(1,2,3) < (1,2,4)\", ctx)).to.equal(true);            \n            expect(await evaluate(\"(1,2) < (1,2,4)\", ctx)).to.equal(true);            \n            expect(await evaluate(\"() < (1,2,3)\", ctx)).to.equal(true);            \n            expect(await evaluate(\"(1,2,3) < (1,2,3)\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"(1,2,4) < (1,2,3)\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"(1,2,4) < (1,2)\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"(1,2,3) < ()\", ctx)).to.equal(false);                        \n        });\n    });\n    \n    describe(\"X >= Y\", () => {\n    \n        it(\"should return true if both X and Y are nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() >= ()\", ctx)).to.equal(true);            \n        });\n    \n        it(\"should return false if X is false and Y is true\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"T >= T\", ctx)).to.equal(true);            \n            expect(await evaluate(\"F >= F\", ctx)).to.equal(true);     \n            expect(await evaluate(\"T >= F\", ctx)).to.equal(true);            \n            expect(await evaluate(\"F >= T\", ctx)).to.equal(false);            \n        });\n    \n        it(\"should return false if X is a lower number than Y\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"1 >= 2\", ctx)).to.equal(false);            \n            expect(await evaluate(\"0 >= 2\", ctx)).to.equal(false);            \n            expect(await evaluate(\"-1 >= 2\", ctx)).to.equal(false);            \n            expect(await evaluate(\"2 >= 1\", ctx)).to.equal(true);            \n            expect(await evaluate(\"2 >= 0\", ctx)).to.equal(true);            \n            expect(await evaluate(\"2 >= (-2)\", ctx)).to.equal(true);            \n            expect(await evaluate(\"2 >= 2\", ctx)).to.equal(true);            \n        });\n    \n        it(\"should return false if X and Y are both strings and X precedes Y alphabetically\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"'abc' >= 'def'\", ctx)).to.equal(false);            \n            expect(await evaluate(\"'abc' >= 'abd'\", ctx)).to.equal(false);            \n            expect(await evaluate(\"'ab' >= 'abc'\", ctx)).to.equal(false);            \n            expect(await evaluate(\"'' >= 'abc'\", ctx)).to.equal(false);            \n            expect(await evaluate(\"'abc' >= 'abc'\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"'abd' >= 'abc'\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"'abc' >= 'ab'\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"'abc' >= ''\", ctx)).to.equal(true);                        \n        });\n    \n        it(\"should return false if X and Y are both lists and X precedes Y lexicographically\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"[1,2,3] >= [4,5,6]\", ctx)).to.equal(false);            \n            expect(await evaluate(\"[1,2,3] >= [1,2,4]\", ctx)).to.equal(false);            \n            expect(await evaluate(\"[1,2] >= [1,2,4]\", ctx)).to.equal(false);            \n            expect(await evaluate(\"[] >= [1,2,3]\", ctx)).to.equal(false);            \n            expect(await evaluate(\"[1,2,3] >= [1,2,3]\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"[1,2,4] >= [1,2,3]\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"[1,2,4] >= [1,2]\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"[1,2,3] >= []\", ctx)).to.equal(true);                        \n        });\n    \n        it(\"should return false if X is nothing and Y is not\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() >= ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() >= T\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() >= F\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() >= 1\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() >= 'abc'\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() >= ls\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() >= ns\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() >= fn\", ctx)).to.equal(false);                                                \n        });\n    \n        it(\"should return true if Y is nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() >= ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"T >= ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"F >= ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"1 >= ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"'abc' >= ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ls >= ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ns >= ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"fn >= ()\", ctx)).to.equal(true);                                                            \n        });\n    \n        it(\"should throw an exception for any other type combination\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            var expectCmpError = (expression, xType, yType) => expectException(() => evaluate(expression, ctx), `Comparison operation not defined between ${xType} and ${yType}`);\n    \n            var xType='Boolean'; ctx.x = false;\n            await expectCmpError(\"x >= 1\",     xType, 'Number');                                    \n            await expectCmpError(\"x >= 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x >= ls\",    xType, 'List');                                    \n            await expectCmpError(\"x >= ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x >= fn\",    xType, 'Function');                                                \n    \n            var xType='Boolean'; ctx.x = true;\n            await expectCmpError(\"x >= 1\",     xType, 'Number');                                    \n            await expectCmpError(\"x >= 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x >= ls\",    xType, 'List');                                    \n            await expectCmpError(\"x >= ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x >= fn\",    xType, 'Function');                                                \n    \n            var xType='Number'; ctx.x = 10;\n            await expectCmpError(\"x >= T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x >= F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x >= 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x >= ls\",    xType, 'List');                                    \n            await expectCmpError(\"x >= ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x >= fn\",    xType, 'Function');                                                \n    \n            var xType='String'; ctx.x = 'abc';\n            await expectCmpError(\"x >= T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x >= F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x >= 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x >= ls\",    xType, 'List');                                    \n            await expectCmpError(\"x >= ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x >= fn\",    xType, 'Function');                                                \n    \n            var xType='List'; ctx.x = [1,2,3];\n            await expectCmpError(\"x >= T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x >= F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x >= 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x >= 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x >= ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x >= fn\",    xType, 'Function');                                                \n    \n            var xType='Namespace'; ctx.x = {a:1,b:2};\n            await expectCmpError(\"x >= T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x >= F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x >= 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x >= 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x >= ls\",    xType, 'List');                                    \n            await expectCmpError(\"x >= ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x >= fn\",    xType, 'Function');                                                \n    \n            var xType='Function'; ctx.x = x=>2*x;\n            await expectCmpError(\"x >= T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x >= F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x >= 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x >= 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x >= ls\",    xType, 'List');                                    \n            await expectCmpError(\"x >= ns\",    xType, 'Namespace');                                                \n            await expectCmpError(\"x >= fn\",    xType, 'Function');                                                \n        });\n    \n        it(\"should compare tuples with lexicographical criteria\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"(1,2,3) >= (4,5,6)\", ctx)).to.equal(false);            \n            expect(await evaluate(\"(1,2,3) >= (1,2,4)\", ctx)).to.equal(false);            \n            expect(await evaluate(\"(1,2) >= (1,2,4)\", ctx)).to.equal(false);            \n            expect(await evaluate(\"() >= (1,2,3)\", ctx)).to.equal(false);            \n            expect(await evaluate(\"(1,2,3) >= (1,2,3)\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"(1,2,4) >= (1,2,3)\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"(1,2,4) >= (1,2)\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"(1,2,3) >= ()\", ctx)).to.equal(true);                        \n        });\n    });    \n    \n    describe(\"X > Y\", () => {\n    \n        it(\"should return false if both X and Y are nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() > ()\", ctx)).to.equal(false);            \n        });\n    \n        it(\"should return true if X is true and Y is false\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"T > T\", ctx)).to.equal(false);            \n            expect(await evaluate(\"F > F\", ctx)).to.equal(false);            \n            expect(await evaluate(\"T > F\", ctx)).to.equal(true);            \n            expect(await evaluate(\"F > T\", ctx)).to.equal(false);            \n        });\n    \n        it(\"should return true if X is a higher number than Y\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"1 > 2\", ctx)).to.equal(false);            \n            expect(await evaluate(\"0 > 2\", ctx)).to.equal(false);            \n            expect(await evaluate(\"-1 > 2\", ctx)).to.equal(false);            \n            expect(await evaluate(\"2 > 1\", ctx)).to.equal(true);            \n            expect(await evaluate(\"2 > 0\", ctx)).to.equal(true);            \n            expect(await evaluate(\"2 > (-2)\", ctx)).to.equal(true);            \n            expect(await evaluate(\"2 > 2\", ctx)).to.equal(false);            \n        });\n    \n        it(\"should return true if X and Y are both strings and X follows Y alphabetically\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"'abc' > 'def'\", ctx)).to.equal(false);            \n            expect(await evaluate(\"'abc' > 'abd'\", ctx)).to.equal(false);            \n            expect(await evaluate(\"'ab' > 'abc'\", ctx)).to.equal(false);            \n            expect(await evaluate(\"'' > 'abc'\", ctx)).to.equal(false);            \n            expect(await evaluate(\"'abc' > 'abc'\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"'abd' > 'abc'\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"'abc' > 'ab'\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"'abc' > ''\", ctx)).to.equal(true);                        \n        });\n    \n        it(\"should return true if X and Y are both lists and X follows Y lexicographically\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"[1,2,3] > [4,5,6]\", ctx)).to.equal(false);            \n            expect(await evaluate(\"[1,2,3] > [1,2,4]\", ctx)).to.equal(false);            \n            expect(await evaluate(\"[1,2] > [1,2,4]\", ctx)).to.equal(false);            \n            expect(await evaluate(\"[] > [1,2,3]\", ctx)).to.equal(false);            \n            expect(await evaluate(\"[1,2,3] > [1,2,3]\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"[1,2,4] > [1,2,3]\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"[1,2,4] > [1,2]\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"[1,2,3] > []\", ctx)).to.equal(true);                        \n        });\n    \n        it(\"should return false if X is nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() > ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() > T\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() > F\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() > 1\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() > 'abc'\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() > ls\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() > ns\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"() > fn\", ctx)).to.equal(false);                                                \n        });\n    \n        it(\"should return true if Y is nothing and X is not\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() > ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"T > ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"F > ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"1 > ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"'abc' > ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ls > ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"ns > ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"fn > ()\", ctx)).to.equal(true);                                                            \n        });\n    \n        it(\"should throw an exception for any other type combination\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            var expectCmpError = (expression, xType, yType) => expectException(() => evaluate(expression, ctx), `Comparison operation not defined between ${xType} and ${yType}`);\n    \n            var xType='Boolean'; ctx.x = false;\n            await expectCmpError(\"x > 1\",     xType, 'Number');                                    \n            await expectCmpError(\"x > 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x > ls\",    xType, 'List');                                    \n            await expectCmpError(\"x > ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x > fn\",    xType, 'Function');                                                \n    \n            var xType='Boolean'; ctx.x = true;\n            await expectCmpError(\"x > 1\",     xType, 'Number');                                    \n            await expectCmpError(\"x > 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x > ls\",    xType, 'List');                                    \n            await expectCmpError(\"x > ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x > fn\",    xType, 'Function');                                                \n    \n            var xType='Number'; ctx.x = 10;\n            await expectCmpError(\"x > T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x > F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x > 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x > ls\",    xType, 'List');                                    \n            await expectCmpError(\"x > ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x > fn\",    xType, 'Function');                                                \n    \n            var xType='String'; ctx.x = 'abc';\n            await expectCmpError(\"x > T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x > F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x > 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x > ls\",    xType, 'List');                                    \n            await expectCmpError(\"x > ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x > fn\",    xType, 'Function');                                                \n    \n            var xType='List'; ctx.x = [1,2,3];\n            await expectCmpError(\"x > T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x > F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x > 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x > 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x > ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x > fn\",    xType, 'Function');                                                \n    \n            var xType='Namespace'; ctx.x = {a:1,b:2};\n            await expectCmpError(\"x > T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x > F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x > 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x > 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x > ls\",    xType, 'List');                                    \n            await expectCmpError(\"x > ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x > fn\",    xType, 'Function');                                                \n    \n            var xType='Function'; ctx.x = x=>2*x;\n            await expectCmpError(\"x > T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x > F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x > 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x > 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x > ls\",    xType, 'List');                                    \n            await expectCmpError(\"x > ns\",    xType, 'Namespace');                                                \n            await expectCmpError(\"x > fn\",    xType, 'Function');                                                \n        });\n    \n        it(\"should compare tuples with lexicographical criteria\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"(1,2,3) > (4,5,6)\", ctx)).to.equal(false);            \n            expect(await evaluate(\"(1,2,3) > (1,2,4)\", ctx)).to.equal(false);            \n            expect(await evaluate(\"(1,2) > (1,2,4)\", ctx)).to.equal(false);            \n            expect(await evaluate(\"() > (1,2,3)\", ctx)).to.equal(false);            \n            expect(await evaluate(\"(1,2,3) > (1,2,3)\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"(1,2,4) > (1,2,3)\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"(1,2,4) > (1,2)\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"(1,2,3) > ()\", ctx)).to.equal(true);                        \n        });\n    });\n    \n    describe(\"X <= Y\", () => {\n    \n        it(\"should return true if both X and Y are nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() <= ()\", ctx)).to.equal(true);            \n        });\n    \n        it(\"should return false if X is true and Y is false\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"T <= T\", ctx)).to.equal(true);            \n            expect(await evaluate(\"F <= F\", ctx)).to.equal(true);            \n            expect(await evaluate(\"T <= F\", ctx)).to.equal(false);            \n            expect(await evaluate(\"F <= T\", ctx)).to.equal(true);            \n        });\n    \n        it(\"should return false if X is a higher number than Y\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"1 <= 2\", ctx)).to.equal(true);            \n            expect(await evaluate(\"0 <= 2\", ctx)).to.equal(true);            \n            expect(await evaluate(\"-1 <= 2\", ctx)).to.equal(true);            \n            expect(await evaluate(\"2 <= 1\", ctx)).to.equal(false);            \n            expect(await evaluate(\"2 <= 0\", ctx)).to.equal(false);            \n            expect(await evaluate(\"2 <= (-2)\", ctx)).to.equal(false);            \n            expect(await evaluate(\"2 <= 2\", ctx)).to.equal(true);            \n        });\n    \n        it(\"should return false if X and Y are both strings and X follows Y alphabetically\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"'abc' <= 'def'\", ctx)).to.equal(true);            \n            expect(await evaluate(\"'abc' <= 'abd'\", ctx)).to.equal(true);            \n            expect(await evaluate(\"'ab' <= 'abc'\", ctx)).to.equal(true);            \n            expect(await evaluate(\"'' <= 'abc'\", ctx)).to.equal(true);            \n            expect(await evaluate(\"'abc' <= 'abc'\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"'abd' <= 'abc'\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"'abc' <= 'ab'\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"'abc' <= ''\", ctx)).to.equal(false);                        \n        });\n    \n        it(\"should return false if X and Y are both lists and X follows Y lexicographically\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"[1,2,3] <= [4,5,6]\", ctx)).to.equal(true);            \n            expect(await evaluate(\"[1,2,3] <= [1,2,4]\", ctx)).to.equal(true);            \n            expect(await evaluate(\"[1,2] <= [1,2,4]\", ctx)).to.equal(true);            \n            expect(await evaluate(\"[] <= [1,2,3]\", ctx)).to.equal(true);            \n            expect(await evaluate(\"[1,2,3] <= [1,2,3]\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"[1,2,4] <= [1,2,3]\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"[1,2,4] <= [1,2]\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"[1,2,3] <= []\", ctx)).to.equal(false);                        \n        });\n    \n        it(\"should return true if X is nothing\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() <= ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() <= T\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() <= F\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() <= 1\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() <= 'abc'\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() <= ls\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() <= ns\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"() <= fn\", ctx)).to.equal(true);                                                \n        });\n    \n        it(\"should return false if Y is nothing and X is not\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"() <= ()\", ctx)).to.equal(true);                                    \n            expect(await evaluate(\"T <= ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"F <= ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"1 <= ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"'abc' <= ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ls <= ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"ns <= ()\", ctx)).to.equal(false);                                    \n            expect(await evaluate(\"fn <= ()\", ctx)).to.equal(false);                                                            \n        });\n    \n        it(\"should throw an exception for any other type combination\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            var expectCmpError = (expression, xType, yType) => expectException(() => evaluate(expression, ctx), `Comparison operation not defined between ${xType} and ${yType}`);\n    \n            var xType='Boolean'; ctx.x = false;\n            await expectCmpError(\"x <= 1\",     xType, 'Number');                                    \n            await expectCmpError(\"x <= 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x <= ls\",    xType, 'List');                                    \n            await expectCmpError(\"x <= ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x <= fn\",    xType, 'Function');                                                \n    \n            var xType='Boolean'; ctx.x = true;\n            await expectCmpError(\"x <= 1\",     xType, 'Number');                                    \n            await expectCmpError(\"x <= 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x <= ls\",    xType, 'List');                                    \n            await expectCmpError(\"x <= ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x <= fn\",    xType, 'Function');                                                \n    \n            var xType='Number'; ctx.x = 10;\n            await expectCmpError(\"x <= T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x <= F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x <= 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x <= ls\",    xType, 'List');                                    \n            await expectCmpError(\"x <= ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x <= fn\",    xType, 'Function');                                                \n    \n            var xType='String'; ctx.x = 'abc';\n            await expectCmpError(\"x <= T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x <= F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x <= 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x <= ls\",    xType, 'List');                                    \n            await expectCmpError(\"x <= ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x <= fn\",    xType, 'Function');                                                \n    \n            var xType='List'; ctx.x = [1,2,3];\n            await expectCmpError(\"x <= T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x <= F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x <= 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x <= 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x <= ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x <= fn\",    xType, 'Function');                                                \n    \n            var xType='Namespace'; ctx.x = {a:1,b:2};\n            await expectCmpError(\"x <= T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x <= F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x <= 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x <= 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x <= ls\",    xType, 'List');                                    \n            await expectCmpError(\"x <= ns\",    xType, 'Namespace');                                    \n            await expectCmpError(\"x <= fn\",    xType, 'Function');                                                \n    \n            var xType='Function'; ctx.x = x=>2*x;\n            await expectCmpError(\"x <= T\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x <= F\",     xType, 'Boolean');                                    \n            await expectCmpError(\"x <= 10\",    xType, 'Number');                                    \n            await expectCmpError(\"x <= 'abc'\", xType, 'String');                                    \n            await expectCmpError(\"x <= ls\",    xType, 'List');                                    \n            await expectCmpError(\"x <= ns\",    xType, 'Namespace');                                                \n            await expectCmpError(\"x <= fn\",    xType, 'Function');                                                \n        });\n    \n        it(\"should compare tuples with lexicographical criteria\", async () => {\n            var ctx = createContext({fn:()=>{}, ls:[1,2,3], ns:{a:1,b:2,c:3}, T:true, F:false});\n            expect(await evaluate(\"(1,2,3) <= (4,5,6)\", ctx)).to.equal(true);            \n            expect(await evaluate(\"(1,2,3) <= (1,2,4)\", ctx)).to.equal(true);            \n            expect(await evaluate(\"(1,2) <= (1,2,4)\", ctx)).to.equal(true);            \n            expect(await evaluate(\"() <= (1,2,3)\", ctx)).to.equal(true);            \n            expect(await evaluate(\"(1,2,3) <= (1,2,3)\", ctx)).to.equal(true);                        \n            expect(await evaluate(\"(1,2,4) <= (1,2,3)\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"(1,2,4) <= (1,2)\", ctx)).to.equal(false);                        \n            expect(await evaluate(\"(1,2,3) <= ()\", ctx)).to.equal(false);                        \n        });\n    });\n    \n    \n    // MISCELLANEOUS\n    \n    describe(\"string templates\", () => {\n    \n        it(\"should evaluate the expressions between ${...} when the string is enclosed between accent quotes\", async () => {\n            var ctx = createContext({y:2});\n            expect(await evaluate(\"`x = ${1+y}`\", ctx)).to.equal(\"x = 3\");\n        });\n    \n        it(\"should evaluate the expressions in a child context\", async () => {\n            var ctx = createContext({x:10, y:20});\n            expect(await evaluate(\"`${x=2}x+y = ${x+y}`\", ctx)).to.equal(\"x+y = 22\");\n            expect(ctx.x).to.equal(10);\n        });\n    });\n    \n    describe(\"operators precedence and grouping\", () => {\n    \n        it(\"should execute assignment operations (`=`) before pairing operations (`,`)\", async () => {\n            var ctx = createContext();\n    \n            await evaluate(\"x = 1,2,3\", ctx);\n            expect(ctx.x).to.equal(1);\n    \n            await evaluate(\"x = (1,2,3)\", ctx);\n            expect(isTuple(ctx.x)).to.be.true;\n            expect(Array.from(ctx.x)).to.deep.equal([1,2,3]);\n        });\n    \n        it(\"should execute function definitions (`->`) before assignment operations (`=`)\", async () => {\n            var ctx = createContext();\n    \n            await evaluate(\"f = x -> [x]\", ctx);\n            expect(ctx.f).to.be.a(\"function\");\n            expect(await ctx.f(1)).to.deep.equal([1]);\n    \n            var retval = await evaluate(\"1, f = x -> [x], 2\", ctx);\n            expect(ctx.f).to.be.a(\"function\");\n            expect(isTuple(retval)).to.be.true;\n            expect(Array.from(retval)).to.deep.equal([1,2]);\n        });\n    \n        it(\"should execure `;` operations before function definitions (`->`)\", async () => {\n            var ctx = createContext({T:true, F:false});                        \n            expect(await evaluate(\"f = (x) -> x ; 1\", ctx)).to.equal(null);\n            expect(await ctx.f(3)).to.equal(3);\n            expect(await ctx.f()).to.equal(1);\n        });\n    \n        it(\"should execure `?` operations before `;` operations\", async () => {\n            var ctx = createContext({T:true, F:false});                        \n            expect(await evaluate(\"f = (x,y) -> x ? 1 ; y ? 2 ; 3\", ctx)).to.equal(null);\n            expect(await ctx.f(true, false)).to.equal(1);\n            expect(await ctx.f(true, true)).to.equal(1);\n            expect(await ctx.f(false, true)).to.equal(2);\n            expect(await ctx.f(false, false)).to.equal(3);            \n        });\n    \n        it(\"should execute logic operations (`&` and `|`) before `?` and `;` operations\", async () => {\n            var ctx = createContext({T:true, F:false});            \n            expect(await evaluate(\"f = (x,y) -> x & y ? 1 ; x | y ? 2 ; 3\", ctx)).to.equal(null);\n            expect(await ctx.f(true, true)).to.equal(1);\n            expect(await ctx.f(true, false)).to.equal(2);\n            expect(await ctx.f(false, true)).to.equal(2);\n            expect(await ctx.f(false, false)).to.equal(3);            \n        });\n    \n        it(\"should execute comparison operations (`==`,`!=`,`<`,`<=`,`>=`,`>`) before logic operations (`&` and `|`)\", async () => {\n            var ctx = createContext({T:true, F:false});            \n            expect(await evaluate(\"f = x -> x==0 ? 'null' ; 0.01<=x & x<0.1 ? 'small' ; 1000>x & x>=100 ? 'big' ; 'huge' \", ctx)).to.equal(null);\n            expect(await ctx.f(0)).to.equal('null');\n            expect(await ctx.f(0.01)).to.equal('small');\n            expect(await ctx.f(0.09)).to.equal('small');\n            expect(await ctx.f(999)).to.equal('big');\n            expect(await ctx.f(100)).to.equal('big');\n            expect(await ctx.f(1000)).to.equal('huge');\n        });\n    \n        it(\"should execute sum (`+`) and subtraction (`-`) operations before comparison operations (`==`,`!=`,`<`,`<=`,`>=`,`>`)\", async () => {\n            var ctx = createContext({T:true, F:false});            \n            expect(await evaluate(\"1+1<4 & 8-3==5\",ctx)).to.equal(true);\n        });\n    \n        it(\"should execute product (`*`) division (`/`) and modulo (`%`) operations before sum and subtraction operations (`+` and `-`)\", async () => {\n            var ctx = createContext({T:true, F:false});            \n            expect(await evaluate(\"1+2*3-10/5+8%5\",ctx)).to.equal(8);\n        });\n    \n        it(\"should execute exponentiation (`^`) operations before product (`*`) division (`/`) and modulo (`%`) operations\", async () => {\n            var ctx = createContext({T:true, F:false});            \n            expect(await evaluate(\"1+2*3^2-10/5+8%5\",ctx)).to.equal(20);\n        });\n    \n        it(\"should execute subcontexting (`.`) and function calls before arithmetic operations\", async () => {\n            var ctx = createContext({double:x=>2*x, b:10});                        \n            expect(await evaluate(\"double 2+3\", ctx)).to.equal(7);\n            expect(await evaluate(\"double(2+3)\", ctx)).to.equal(10);\n    \n            expect(await evaluate(\"{a=1,b=2}.a+b\", ctx)).to.equal(11);\n            expect(await evaluate(\"{a=1,b=2}.(a+b)\", ctx)).to.equal(3);            \n    \n            expect(await evaluate(\"{f=x->2*x}.f 2\", ctx)).to.equal(4);\n            expect(await evaluate(\"(x->{a=2*x}) 4 . a\", ctx)).to.equal(8);\n        });\n    });\n});\n\n\n//# sourceURL=webpack:///../expression.js?");

/***/ }),

/***/ "../memory-store.js":
/*!**************************!*\
  !*** ../memory-store.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar MemoryStore = __webpack_require__(/*! ../lib/stores/memory */ \"../../lib/stores/memory.js\");\n\n\n\ndescribe(\"MemoryStore\", () => {\n    \n    it(\"should work as a Map object, with paths as keys\", () => {\n        var memStore = new MemoryStore();\n        memStore.set('/path/to/doc', \"Doc source @ /path/to/doc\");\n        expect(memStore.get('/path/to/doc')).to.equal(\"Doc source @ /path/to/doc\")\n        memStore.delete('/path/to/doc');\n        expect(memStore._content.has('/path/to/doc')).to.be.false;\n    });\n    \n    it(\"should normalize the path\", () => {\n        var memStore = new MemoryStore();\n        memStore.set('path/to/doc', \"Doc source @ /path/to/doc\");\n        expect(memStore.get('/path/to/doc')).to.equal(\"Doc source @ /path/to/doc\")\n        expect(memStore.get('path/to/./doc')).to.equal(\"Doc source @ /path/to/doc\")\n        memStore.delete('/path/to/a/../doc');\n        expect(memStore._content.has('/path/to/doc')).to.be.false;\n        \n    });\n    \n    it(\"should ignore the constructor parameters\", () => {\n        var memStore = new MemoryStore(['kay','vale']);\n        expect(memStore._content.size).to.equal(0);\n    });\n    \n    describe(\"source = memStore.get(path)\", () => {\n        \n        it(\"should return an empty string if the path doesn't exist\", () => {\n            var memStore = new MemoryStore();\n            expect(memStore.get('/path/to/doc')).to.equal(\"\")                \n        });            \n    });        \n\n    describe(\"memStore.set(path, source)\", () => {\n        \n        it(\"should stringify the source parameter\", () => {\n            var memStore = new MemoryStore();\n            memStore.set('path/to/doc', {\n                toString: () => \"Doc source @ /path/to/doc\"\n            });\n            expect(memStore.get('/path/to/doc')).to.equal(\"Doc source @ /path/to/doc\")\n        });\n    });        \n});    \n\n\n//# sourceURL=webpack:///../memory-store.js?");

/***/ }),

/***/ "../router-store.js":
/*!**************************!*\
  !*** ../router-store.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var expect = __webpack_require__(/*! chai */ \"../../node_modules/chai/index.js\").expect;\nvar document = __webpack_require__(/*! ../lib/document */ \"../../lib/document.js\");\nvar errors = __webpack_require__(/*! ../lib/stores/store-errors */ \"../../lib/stores/store-errors.js\");\nvar MemoryStore = __webpack_require__(/*! ../lib/stores/memory */ \"../../lib/stores/memory.js\");\nvar RouterStore = __webpack_require__(/*! ../lib/stores/router */ \"../../lib/stores/router.js\");\n\n\n\n\n\n\ndescribe(\"RouterStore\", () => {\n    \n    describe(`source = router.get(path)`, () => {\n        \n        it(\"should delegate to the matching mounted store\", async () => {\n            var store1 = new MemoryStore();\n            store1.set('/path/to/doc', \"doc @ store1\");\n            var store2 = new MemoryStore();\n            store2.set('/path/to/doc', \"doc @ store2\");\n            var router = new RouterStore({\n                s1: store1,\n                s2: store2\n            });\n            expect(await router.get('/s1/path/to/doc')).to.equal(\"doc @ store1\");\n            expect(await router.get('/s2/path/to/doc')).to.equal(\"doc @ store2\");\n        });\n        \n        it(\"should return an empty document if no match is found\", async () => {\n            var store1 = new MemoryStore();\n            store1.set('/path/to/doc', \"doc @ store1\");\n            var store2 = new MemoryStore();\n            store2.set('/path/to/doc', \"doc @ store2\");\n            var router = new RouterStore({\n                s1: store1,\n                s2: store2\n            });\n            expect(await router.get('/s3/path/to/doc')).to.equal(\"\");\n        })\n\n        it(\"should return a document containing the `__children__` list when asking for `/`\", async () => {\n            var store1 = new MemoryStore();\n            store1.set('/path/to/doc', \"doc @ store1\");\n            var store2 = new MemoryStore();\n            store2.set('/path/to/doc', \"doc @ store2\");\n            var router = new RouterStore({\n                s1: store1,\n                s2: store2\n            });\n            var doc = await router.get(`/`);\n            var docns = await document.parse(doc)(document.createContext());\n            expect(docns.children.sort()).to.deep.equal([\"/s1/\", \"/s2/\"]);\n            \n        });\n    });\n    \n    describe(`source = router.set(path, source)`, () => {\n        \n        it(\"should delegate to the matching mounted store\", async () => {\n            var store1 = new MemoryStore();\n            var store2 = new MemoryStore();\n            var router = new RouterStore({\n                s1: store1,\n                s2: store2\n            });                \n            await router.set('/s1/path/to/doc', \"doc @ store1\");\n            await router.set('s2/path/to/doc', \"doc @ store2\");\n            expect(await store1.get('/path/to/doc')).to.equal(\"doc @ store1\");\n            expect(await store2.get('/path/to/doc')).to.equal(\"doc @ store2\");\n        });\n        \n        it(\"should throw an error if no match is found\", async () => {\n            var router = new RouterStore();\n            try {\n                await router.set('/s1/path/to/doc', \"...\");\n                throw new Error(\"Id did not throw\");\n            } catch (error) {\n                expect(error).to.be.instanceof(errors.OperationNotAllowed);\n                expect(error.message).to.equal('Operation not allowed: SET /s1/path/to/doc')\n            }\n        });\n        \n        it(\"should throw an error if trying to set the root path\", async () => {\n            var router = new RouterStore({s1: new MemoryStore()});\n            try {\n                await router.set('/', \"...\");\n                throw new Error(\"Id did not throw\");\n            } catch (error) {\n                expect(error).to.be.instanceof(errors.OperationNotAllowed);\n                expect(error.message).to.equal('Operation not allowed: SET /')\n            }                                \n        });\n    });\n    \n    describe(`source = router.get(path)`, () => {\n        \n        it(\"should delegate to the matching mounted store\", async () => {\n            var store1 = new MemoryStore();\n            var store2 = new MemoryStore();\n            var router = new RouterStore({\n                s1: store1,\n                s2: store2\n            });                \n            await store1.set('/path/to/doc', \"doc @ store1\");\n            await router.delete('/s1/path/to/doc');\n            expect(store1.get('/path/to/doc')).to.equal(\"\");\n        });\n        \n        it(\"should throw an error if no match is found\", async () => {\n            var router = new RouterStore();\n            try {\n                await router.delete('/s1/path/to/doc');\n                throw new Error(\"Id did not throw\");\n            } catch (error) {\n                expect(error).to.be.instanceof(errors.OperationNotAllowed);\n                expect(error.message).to.equal('Operation not allowed: DELETE /s1/path/to/doc')\n            }                \n        })\n\n        it(\"should throw an error if trying to delete the root path\", async () => {\n            var router = new RouterStore({s1: new MemoryStore()});\n            try {\n                await router.delete('/');\n                throw new Error(\"Id did not throw\");\n            } catch (error) {\n                expect(error).to.be.instanceof(errors.OperationNotAllowed);\n                expect(error.message).to.equal('Operation not allowed: DELETE /')\n            }                                \n        });\n    });\n});\n\n\n//# sourceURL=webpack:///../router-store.js?");

/***/ })

/******/ });